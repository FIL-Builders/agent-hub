{
  "exports": [
    {
      "name": "ethers",
      "kind": "SourceFile",
      "signature": "export { version } from \"./_version.js\";\n\nexport {\n    decodeBytes32String, encodeBytes32String,\n\n    AbiCoder,\n    ConstructorFragment, ErrorFragment, EventFragment, Fragment, FallbackFragment, FunctionFragment, NamedFragment, ParamType, StructFragment,\n\n    checkResultErrors, ErrorDescription, Ind",
      "doc": "",
      "tags": []
    },
    {
      "name": "version",
      "kind": "VariableDeclaration",
      "signature": "version: string = \"6.15.0\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBytes32String",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBytes32String(_bytes: BytesLike): string {\n    const data = getBytes(_bytes, \"bytes\");\n\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) { throw new Error(\"invalid bytes32 - not 32 bytes long\"); }\n    if (data[31] !== 0) { throw new Error(\"invalid byt",
      "doc": "Encodes the Bytes32-encoded %%bytes%% into a string.",
      "tags": []
    },
    {
      "name": "encodeBytes32String",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBytes32String(text: string): string {\n\n    // Get the bytes\n    const bytes = toUtf8Bytes(text);\n\n    // Check we have room for null-termination\n    if (bytes.length > 31) { throw new Error(\"bytes32 string must be less than 32 bytes\"); }\n\n    // Zero-pad (implicitly null-termin",
      "doc": "Encodes %%text%% as a Bytes32 string.",
      "tags": []
    },
    {
      "name": "AbiCoder",
      "kind": "ClassDeclaration",
      "signature": "export class AbiCoder {\n\n    #getCoder(param: ParamType): Coder {\n        if (param.isArray()) {\n            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n\n        if (param.isTuple()) {\n            return new TupleCoder(param.components.map((c)",
      "doc": "The **AbiCoder** is a low-level class responsible for encoding JavaScript\nvalues into binary data and decoding binary data into JavaScript values.",
      "tags": []
    },
    {
      "name": "ConstructorFragment",
      "kind": "ClassDeclaration",
      "signature": "export class ConstructorFragment extends Fragment {\n\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n  ",
      "doc": "A Fragment which represents a constructor.",
      "tags": []
    },
    {
      "name": "ErrorFragment",
      "kind": "ClassDeclaration",
      "signature": "export class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n\n    /",
      "doc": "A Fragment which represents a //Custom Error//.",
      "tags": []
    },
    {
      "name": "EventFragment",
      "kind": "ClassDeclaration",
      "signature": "export class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    readonly anonymous!: boolean;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>, anonymous: boolean) {\n        super(guard, \"even",
      "doc": "A Fragment which represents an Event.",
      "tags": []
    },
    {
      "name": "Fragment",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    readonly type!: FragmentType;\n\n    /**\n     *  The inputs for the fragment.\n     */\n    readonly inputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType,",
      "doc": "An abstract class to represent An individual fragment from a parse ABI.",
      "tags": []
    },
    {
      "name": "FallbackFragment",
      "kind": "ClassDeclaration",
      "signature": "export class FallbackFragment extends Fragment {\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean) {\n        super(guard, \"fallback\", inputs);\n        Object.d",
      "doc": "A Fragment which represents a method.",
      "tags": []
    },
    {
      "name": "FunctionFragment",
      "kind": "ClassDeclaration",
      "signature": "export class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    readonly constant!: boolean;\n\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    readonly outputs!: ReadonlyArray<",
      "doc": "A Fragment which represents a method.",
      "tags": []
    },
    {
      "name": "NamedFragment",
      "kind": "ClassDeclaration",
      "signature": "export abstract class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    readonly name!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, type, inputs);",
      "doc": "An abstract class to represent An individual fragment\nwhich has a name from a parse ABI.",
      "tags": []
    },
    {
      "name": "ParamType",
      "kind": "ClassDeclaration",
      "signature": "export class ParamType {\n\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    readonly name!: string;\n\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    readonly type!: string;\n\n    /**\n     *  T",
      "doc": "Each input and output of a [[Fragment]] is an Array of **ParamType**.",
      "tags": []
    },
    {
      "name": "StructFragment",
      "kind": "ClassDeclaration",
      "signature": "export class StructFragment extends NamedFragment {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n\n ",
      "doc": "A Fragment which represents a structure.",
      "tags": []
    },
    {
      "name": "checkResultErrors",
      "kind": "FunctionDeclaration",
      "signature": "export function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any):",
      "doc": "Returns all errors found in a [[Result]].\n\nSince certain errors encountered when creating a [[Result]] do\nnot impact the ability to continue parsing data, they are\ndeferred until they are actually accessed. Hence a faulty string\nin an Event that is never used does not impact the program flow.\n\nHowever, sometimes it may be useful to access, identify or\nvalidate correctness of a [[Result]].",
      "tags": [
        {
          "tagName": "_docloc",
          "text": "api/abi"
        }
      ]
    },
    {
      "name": "checkResultErrors.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "ErrorDescription",
      "kind": "ClassDeclaration",
      "signature": "export class ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    readonly fragment!: ErrorFragment;\n\n    /**\n     *  The name of the Error.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    readonly args!: Result;\n\n ",
      "doc": "When using the [[Interface-parseError]] to automatically match an\nerror for a call result for parsing, an **ErrorDescription** is returned.",
      "tags": []
    },
    {
      "name": "Indexed",
      "kind": "ClassDeclaration",
      "signature": "export class Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _isIndexed!: boolean;\n\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard f",
      "doc": "An **Indexed** is used as a value when a value that does not\nfit within a topic (i.e. not a fixed-length, 32-byte type). It\nis the ``keccak256`` of the value, and used for types such as\narrays, tuples, bytes and strings.",
      "tags": []
    },
    {
      "name": "Interface",
      "kind": "ClassDeclaration",
      "signature": "export class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if",
      "doc": "An Interface abstracts many of the low-level details for\nencoding and decoding the data on the blockchain.\n\nAn ABI provides information on how to encode data to send to\na Contract, how to decode the results and events and how to\ninterpret revert errors.\n\nThe ABI can be specified by [any supported format](InterfaceAbi).",
      "tags": []
    },
    {
      "name": "LogDescription",
      "kind": "ClassDeclaration",
      "signature": "export class LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The name of the Event.\n     */\n    readonly name!: string;\n\n    /**\n     *  The full Event signature.\n     */\n    readonly signature!: string;\n\n    ",
      "doc": "When using the [[Interface-parseLog]] to automatically match a Log to its event\nfor parsing, a **LogDescription** is returned.",
      "tags": []
    },
    {
      "name": "Result",
      "kind": "ClassDeclaration",
      "signature": "export class Result extends Array<any> {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @privat",
      "doc": "A [[Result]] is a sub-class of Array, which allows accessing any\nof its values either positionally by its index or, if keys are\nprovided by its name.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/abi"
        }
      ]
    },
    {
      "name": "TransactionDescription",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    readonly fragment!: FunctionFragment;\n\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments pas",
      "doc": "When using the [[Interface-parseTransaction]] to automatically match\na transaction data to its function for parsing,\na **TransactionDescription** is returned.",
      "tags": []
    },
    {
      "name": "Typed",
      "kind": "ClassDeclaration",
      "signature": "export class Typed {\n\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    readonly type!: string;\n\n    /**\n     *  The actual value.\n     */\n    readonly value!: any;\n\n    readonly #options: any;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _typedSymbol!: Symbol;\n\n    /**\n     * ",
      "doc": "The **Typed** class to wrap values providing explicit type information.",
      "tags": []
    },
    {
      "name": "getAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getAddress(address: string): string {\n\n    assertArgument(typeof(address) === \"string\", \"invalid address\", \"address\", address);\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) { address = \"0x\" + address; }\n\n",
      "doc": "Returns a normalized and checksumed address for %%address%%.\nThis accepts non-checksum addresses, checksum addresses and\n[[getIcapAddress]] formats.\n\nThe checksum in Ethereum uses the capitalization (upper-case\nvs lower-case) of the characters within an address to encode\nits checksum, which offers, on average, a checksum of 15-bits.\n\nIf %%address%% contains both upper-case and lower-case, it is\nassumed to already be a checksum address and its checksum is\nvalidated, and if the address fails its expected checksum an\nerror is thrown.\n\nIf you wish the checksum of %%address%% to be ignore, it should\nbe converted to lower-case (i.e. ``.toLowercase()``) before\nbeing passed in. This should be a very rare situation though,\nthat you wish to bypass the safegaurds in place to protect\nagainst an address that has been incorrectly copied from another\nsource.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Adds the checksum (via upper-casing specific letters)\ngetAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n//_result:\n\n// Converts ICAP address and adds checksum\ngetAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n//_result:\n\n// Throws an error if an address contains mixed case,\n// but the checksum fails\ngetAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_error:"
        }
      ]
    },
    {
      "name": "getIcapAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getIcapAddress(address: string): string {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(",
      "doc": "The [ICAP Address format](link-icap) format is an early checksum\nformat which attempts to be compatible with the banking\nindustry [IBAN format](link-wiki-iban) for bank accounts.\n\nIt is no longer common or a recommended format.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\ngetIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n//_result:\n\ngetIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n//_result:\n\n// Throws an error if the ICAP checksum is wrong\ngetIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n//_error:"
        }
      ]
    },
    {
      "name": "getCreateAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getCreateAddress(tx: { from: string, nonce: BigNumberish }): string {\n    const from = getAddress(tx.from);\n    const nonce = getBigInt(tx.nonce, \"tx.nonce\");\n\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length %",
      "doc": "Returns the address that would result from a ``CREATE`` for %%tx%%.\n\nThis can be used to compute the address a contract will be\ndeployed to by an EOA when sending a deployment transaction (i.e.\nwhen the ``to`` address is ``null``).\n\nThis can also be used to compute the address a contract will be\ndeployed to by a contract, by using the contract's address as the\n``to`` and the contract's nonce.",
      "tags": [
        {
          "tagName": "example",
          "text": "  from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n  nonce = 5;\n\n  getCreateAddress({ from, nonce });\n  //_result:"
        }
      ]
    },
    {
      "name": "getCreate2Address",
      "kind": "FunctionDeclaration",
      "signature": "export function getCreate2Address(_from: string, _salt: BytesLike, _initCodeHash: BytesLike): string {\n    const from = getAddress(_from);\n    const salt = getBytes(_salt, \"salt\");\n    const initCodeHash = getBytes(_initCodeHash, \"initCodeHash\");\n\n    assertArgument(salt.length === 32, \"salt must be",
      "doc": "Returns the address that would result from a ``CREATE2`` operation\nwith the given %%from%%, %%salt%% and %%initCodeHash%%.\n\nTo compute the %%initCodeHash%% from a contract's init code, use\nthe [[keccak256]] function.\n\nFor a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].",
      "tags": [
        {
          "tagName": "example",
          "text": "  // The address of the contract\n  from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n\n  // The salt\n  salt = id(\"HelloWorld\")\n\n  // The hash of the initCode\n  initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n  initCodeHash = keccak256(initCode)\n\n  getCreate2Address(from, salt, initCodeHash)\n  //_result:"
        }
      ]
    },
    {
      "name": "isAddressable",
      "kind": "FunctionDeclaration",
      "signature": "export function isAddressable(value: any): value is Addressable {\n    return (value && typeof(value.getAddress) === \"function\");\n}",
      "doc": "Returns true if %%value%% is an object which implements the\n[[Addressable]] interface.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Wallets and AbstractSigner sub-classes\nisAddressable(Wallet.createRandom())\n//_result:\n\n// Contracts\ncontract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\nisAddressable(contract)\n//_result:"
        }
      ]
    },
    {
      "name": "isAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function isAddress(value: any): value is string {\n    try {\n        getAddress(value);\n        return true;\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%value%% is a valid address.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Valid address\nisAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_result:\n\n// Valid ICAP address\nisAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n//_result:\n\n// Invalid checksum\nisAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n//_result:\n\n// Invalid ICAP checksum\nisAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_result:\n\n// Not an address (an ENS name requires a provided and an\n// asynchronous API to access)\nisAddress(\"ricmoo.eth\")\n//_result:"
        }
      ]
    },
    {
      "name": "resolveAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function resolveAddress(target: AddressLike, resolver?: null | NameResolver): string | Promise<string> {\n\n    if (typeof(target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) { return getAddress(target); }\n\n        assert(resolver != null, \"ENS resolution requires a provider\"",
      "doc": "Resolves to an address for the %%target%%, which may be any\nsupported address type, an [[Addressable]] or a Promise which\nresolves to an address.\n\nIf an ENS name is provided, but that name has not been correctly\nconfigured a [[UnconfiguredNameError]] is thrown.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n\n// Addresses are return synchronously\nresolveAddress(addr, provider)\n//_result:\n\n// Address promises are resolved asynchronously\nresolveAddress(Promise.resolve(addr))\n//_result:\n\n// ENS names are resolved asynchronously\nresolveAddress(\"dai.tokens.ethers.eth\", provider)\n//_result:\n\n// Addressable objects are resolved asynchronously\ncontract = new Contract(addr, [ ])\nresolveAddress(contract, provider)\n//_result:\n\n// Unconfigured ENS names reject\nresolveAddress(\"nothing-here.ricmoo.eth\", provider)\n//_error:\n\n// ENS names require a NameResolver object passed in\n// (notice the provider was omitted)\nresolveAddress(\"nothing-here.ricmoo.eth\")\n//_error:"
        }
      ]
    },
    {
      "name": "ZeroAddress",
      "kind": "VariableDeclaration",
      "signature": "ZeroAddress: string = \"0x0000000000000000000000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "WeiPerEther",
      "kind": "VariableDeclaration",
      "signature": "WeiPerEther: bigint = BigInt(\"1000000000000000000\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "MaxUint256",
      "kind": "VariableDeclaration",
      "signature": "MaxUint256: bigint = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinInt256",
      "kind": "VariableDeclaration",
      "signature": "MinInt256: bigint = BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\") * BigInt(-1)",
      "doc": "",
      "tags": []
    },
    {
      "name": "MaxInt256",
      "kind": "VariableDeclaration",
      "signature": "MaxInt256: bigint = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "N",
      "kind": "VariableDeclaration",
      "signature": "N: bigint = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "ZeroHash",
      "kind": "VariableDeclaration",
      "signature": "ZeroHash: string = \"0x0000000000000000000000000000000000000000000000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "EtherSymbol",
      "kind": "VariableDeclaration",
      "signature": "EtherSymbol: string = \"\\u039e\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "MessagePrefix",
      "kind": "VariableDeclaration",
      "signature": "MessagePrefix: string = \"\\x19Ethereum Signed Message:\\n\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "BaseContract",
      "kind": "ClassDeclaration",
      "signature": "export class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  meth",
      "doc": "",
      "tags": []
    },
    {
      "name": "Contract",
      "kind": "ClassDeclaration",
      "signature": "export class Contract extends _ContractBase() { }",
      "doc": "A [[BaseContract]] with no type guards on its methods or events.",
      "tags": []
    },
    {
      "name": "ContractFactory",
      "kind": "ClassDeclaration",
      "signature": "export class ContractFactory<A extends Array<any> = Array<any>, I = BaseContract> {\n\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    readonly bytecode!: string;\n\n    /**\n    ",
      "doc": "A **ContractFactory** is used to deploy a Contract to the blockchain.",
      "tags": []
    },
    {
      "name": "ContractEventPayload",
      "kind": "ClassDeclaration",
      "signature": "export class ContractEventPayload extends ContractUnknownEventPayload {\n\n    /**\n     *  The matching event.\n     */\n    declare readonly fragment: EventFragment;\n\n    /**\n     *  The log, with parsed properties.\n     */\n    declare readonly log: EventLog;\n\n    /**\n     *  The parsed arguments passe",
      "doc": "A **ContractEventPayload** is included as the last parameter to\nContract Events when the event is known.",
      "tags": []
    },
    {
      "name": "ContractTransactionReceipt",
      "kind": "ClassDeclaration",
      "signature": "export class ContractTransactionReceipt extends TransactionReceipt {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionReceipt) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  The",
      "doc": "A **ContractTransactionReceipt** includes the parsed logs from a\n[[TransactionReceipt]].",
      "tags": []
    },
    {
      "name": "ContractTransactionResponse",
      "kind": "ClassDeclaration",
      "signature": "export class ContractTransactionResponse extends TransactionResponse {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionResponse) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  ",
      "doc": "A **ContractTransactionResponse** will return a\n[[ContractTransactionReceipt]] when waited on.",
      "tags": []
    },
    {
      "name": "ContractUnknownEventPayload",
      "kind": "ClassDeclaration",
      "signature": "export  class ContractUnknownEventPayload extends EventPayload<ContractEventName> {\n    /**\n     *  The log with no matching events.\n     */\n    readonly log!: Log;\n\n    /**\n     *  @_event:\n     */\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, log: Lo",
      "doc": "A **ContractUnknownEventPayload** is included as the last parameter to\nContract Events when the event does not match any events in the ABI.",
      "tags": []
    },
    {
      "name": "EventLog",
      "kind": "ClassDeclaration",
      "signature": "export class EventLog extends Log {\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The matching event.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    readonly args",
      "doc": "An **EventLog** contains additional properties parsed from the [[Log]].",
      "tags": []
    },
    {
      "name": "UndecodedEventLog",
      "kind": "ClassDeclaration",
      "signature": "export class UndecodedEventLog extends Log {\n\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    readonly error!: Error;\n\n    /**\n     * @_ignore:\n     */\n    constructor(log: Log, error: Error) {\n        super(log, log.provider);\n        defineProperties<UndecodedEventLo",
      "doc": "An **EventLog** contains additional properties parsed from the [[Log]].",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "FunctionDeclaration",
      "signature": "export function computeHmac(algorithm: \"sha256\" | \"sha512\", _key: BytesLike, _data: BytesLike): string {\n    const key = getBytes(_key, \"key\");\n    const data = getBytes(_data, \"data\");\n    return hexlify(__computeHmac(algorithm, key, data));\n}",
      "doc": "Return the HMAC for %%data%% using the %%key%% key with the underlying\n%%algo%% used for compression.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nkey = id(\"some-secret\")\n\n// Compute the HMAC\ncomputeHmac(\"sha256\", key, \"0x1337\")\n//_result:\n\n// To compute the HMAC of UTF-8 data, the data must be\n// converted to UTF-8 bytes\ncomputeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\n//_result:"
        }
      ]
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function randomBytes(length: number): Uint8Array {\n    return __randomBytes(length);\n}",
      "doc": "Return %%length%% bytes of cryptographically secure random data.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nrandomBytes(8)\n//_result:"
        }
      ]
    },
    {
      "name": "randomBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function keccak256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}",
      "doc": "Compute the cryptographic KECCAK256 hash of %%data%%.\n\nThe %%data%% **must** be a data representation, to compute the\nhash of UTF-8 data use the [[id]] function.",
      "tags": [
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nkeccak256(\"0x\")\n//_result:\n\nkeccak256(\"0x1337\")\n//_result:\n\nkeccak256(new Uint8Array([ 0x13, 0x37 ]))\n//_result:\n\n// Strings are assumed to be DataHexString, otherwise it will\n// throw. To hash UTF-8 data, see the note above.\nkeccak256(\"Hello World\")\n//_error:"
        }
      ]
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "FunctionDeclaration",
      "signature": "export function ripemd160(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__ripemd160(data));\n}",
      "doc": "Compute the cryptographic RIPEMD-160 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nripemd160(\"0x\")\n//_result:\n\nripemd160(\"0x1337\")\n//_result:\n\nripemd160(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "FunctionDeclaration",
      "signature": "export function sha256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha256(data));\n}",
      "doc": "Compute the cryptographic SHA2-256 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nsha256(\"0x\")\n//_result:\n\nsha256(\"0x1337\")\n//_result:\n\nsha256(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "FunctionDeclaration",
      "signature": "export function sha512(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha512(data));\n}",
      "doc": "Compute the cryptographic SHA2-512 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nsha512(\"0x\")\n//_result:\n\nsha512(\"0x1337\")\n//_result:\n\nsha512(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "FunctionDeclaration",
      "signature": "export function pbkdf2(_password: BytesLike, _salt: BytesLike, iterations: number, keylen: number, algo: \"sha256\" | \"sha512\"): string {\n    const password = getBytes(_password, \"password\");\n    const salt = getBytes(_salt, \"salt\");\n    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo",
      "doc": "Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\nthe %%salt%% and using %%iterations%% of %%algo%%.\n\nThis PBKDF is outdated and should not be used in new projects, but is\nrequired to decrypt older files.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the PBKDF2\npbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n//_result:"
        }
      ]
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "FunctionDeclaration",
      "signature": "export async function scrypt(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number, progress?: ProgressCallback): Promise<string> {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(await __scryptAsync(passwd, salt, ",
      "doc": "The [[link-wiki-scrypt]] uses a memory and cpu hard method of\nderivation to increase the resource cost to brute-force a password\nfor a given key.\n\nThis means this algorithm is intentionally slow, and can be tuned to\nbecome slower. As computation and memory speed improve over time,\nincreasing the difficulty maintains the cost of an attacker.\n\nFor example, if a target time of 5 seconds is used, a legitimate user\nwhich knows their password requires only 5 seconds to unlock their\naccount. A 6 character password has 68 billion possibilities, which\nwould require an attacker to invest over 10,000 years of CPU time. This\nis of course a crude example (as password generally aren't random),\nbut demonstrates to value of imposing large costs to decryption.\n\nFor this reason, if building a UI which involved decrypting or\nencrypting datsa using scrypt, it is recommended to use a\n[[ProgressCallback]] (as event short periods can seem lik an eternity\nif the UI freezes). Including the phrase //\"decrypting\"// in the UI\ncan also help, assuring the user their waiting is for a good reason.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        },
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the scrypt\nscrypt(passwordBytes, salt, 1024, 8, 1, 16)\n//_result:"
        }
      ]
    },
    {
      "name": "scrypt.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "FunctionDeclaration",
      "signature": "export function scryptSync(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number): string {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(__scryptSync(passwd, salt, N, r, p, dkLen));\n}",
      "doc": "Provides a synchronous variant of [[scrypt]].\n\nThis will completely lock up and freeze the UI in a browser and will\nprevent any event loop from progressing. For this reason, it is\npreferred to use the [async variant](scrypt).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        },
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the scrypt\nscryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n//_result:"
        }
      ]
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "lock",
      "kind": "FunctionDeclaration",
      "signature": "function lock(): void {\n    computeHmac.lock();\n    keccak256.lock();\n    pbkdf2.lock();\n    randomBytes.lock();\n    ripemd160.lock();\n    scrypt.lock();\n    scryptSync.lock();\n    sha256.lock();\n    sha512.lock();\n    randomBytes.lock();\n}",
      "doc": "Once called, prevents any future change to the underlying cryptographic\nprimitives using the ``.register`` feature for hooks.",
      "tags": []
    },
    {
      "name": "Signature",
      "kind": "ClassDeclaration",
      "signature": "export class Signature {\n    #r: string;\n    #s: string;\n    #v: 27 | 28;\n    #networkV: null | bigint;\n\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n   ",
      "doc": "A Signature",
      "tags": [
        {
          "tagName": "TODO",
          "text": ""
        },
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Signing"
        }
      ]
    },
    {
      "name": "SigningKey",
      "kind": "ClassDeclaration",
      "signature": "export class SigningKey {\n    #privateKey: string;\n\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey: BytesLike) {\n        assertArgument(dataLength(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = h",
      "doc": "A **SigningKey** provides high-level access to the elliptic curve\ncryptography (ECC) operations and key management.",
      "tags": []
    },
    {
      "name": "id",
      "kind": "FunctionDeclaration",
      "signature": "export function id(value: string): string {\n    return keccak256(toUtf8Bytes(value));\n}",
      "doc": "A simple hashing function which operates on UTF-8 strings to\ncompute an 32-byte identifier.\n\nThis simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\nthe [[keccak256]].",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nid(\"hello world\")\n//_result:"
        }
      ]
    },
    {
      "name": "ensNormalize",
      "kind": "FunctionDeclaration",
      "signature": "export function ensNormalize(name: string): string {\n    try {\n        if (name.length === 0) { throw new Error(\"empty label\"); }\n        return ens_normalize(name);\n    } catch (error: any) {\n        assertArgument(false, `invalid ENS name (${ error.message })`, \"name\", name);\n    }\n}",
      "doc": "Returns the ENS %%name%% normalized.",
      "tags": []
    },
    {
      "name": "isValidName",
      "kind": "FunctionDeclaration",
      "signature": "export function isValidName(name: string): name is string {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns ``true`` if %%name%% is a valid ENS name.",
      "tags": []
    },
    {
      "name": "namehash",
      "kind": "FunctionDeclaration",
      "signature": "export function namehash(name: string): string {\n    assertArgument(typeof(name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n\n    assertArgument(name.length, `invalid ENS name (empty label)`, \"name\", name);\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSp",
      "doc": "Returns the [[link-namehash]] for %%name%%.",
      "tags": []
    },
    {
      "name": "dnsEncode",
      "kind": "FunctionDeclaration",
      "signature": "export function dnsEncode(name: string, _maxLength?: number): string {\n    const length = (_maxLength != null) ? _maxLength: 63;\n\n    assertArgument(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        assertAr",
      "doc": "Returns the DNS encoded %%name%%.\n\nThis is used for various parts of ENS name resolution, such\nas the wildcard resolution.",
      "tags": []
    },
    {
      "name": "hashAuthorization",
      "kind": "FunctionDeclaration",
      "signature": "export function hashAuthorization(auth: AuthorizationRequest): string {\n    assertArgument(typeof(auth.address) === \"string\", \"invalid address for hashAuthorization\", \"auth.address\", auth);\n    return keccak256(concat([\n        \"0x05\", encodeRlp([\n            (auth.chainId != null) ? toBeArray(auth.",
      "doc": "Computes the [[link-eip-7702]] authorization digest to sign.",
      "tags": []
    },
    {
      "name": "verifyAuthorization",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyAuthorization(auth: AuthorizationRequest, sig: SignatureLike): string {\n    return recoverAddress(hashAuthorization(auth), sig);\n}",
      "doc": "Return the address of the private key that produced\nthe signature %%sig%% during signing for %%message%%.",
      "tags": []
    },
    {
      "name": "hashMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function hashMessage(message: Uint8Array | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(MessagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}",
      "doc": "Computes the [[link-eip-191]] personal-sign message digest to sign.\n\nThis prefixes the message with [[MessagePrefix]] and the decimal length\nof %%message%% and computes the [[keccak256]] digest.\n\nIf %%message%% is a string, it is converted to its UTF-8 bytes\nfirst. To compute the digest of a [[DataHexString]], it must be converted\nto [bytes](getBytes).",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nhashMessage(\"Hello World\")\n//_result:\n\n// Hashes the SIX (6) string characters, i.e.\n// [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\nhashMessage(\"0x4243\")\n//_result:\n\n// Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\nhashMessage(getBytes(\"0x4243\"))\n//_result:\n\n// ...which is equal to using data\nhashMessage(new Uint8Array([ 0x42, 0x43 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "verifyMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyMessage(message: Uint8Array | string, sig: SignatureLike): string {\n    const digest = hashMessage(message);\n    return recoverAddress(digest, sig);\n}",
      "doc": "Return the address of the private key that produced\nthe signature %%sig%% during signing for %%message%%.",
      "tags": []
    },
    {
      "name": "solidityPacked",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPacked(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, in",
      "doc": "Computes the [[link-solc-packed]] representation of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "solidityPackedKeccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPackedKeccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _keccak256(solidityPacked(types, values));\n}",
      "doc": "Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "solidityPackedSha256",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPackedSha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _sha256(solidityPacked(types, values));\n}",
      "doc": "Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "TypedDataEncoder",
      "kind": "ClassDeclaration",
      "signature": "export class TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only rema",
      "doc": "A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\nfor signed typed data.\n\nThis is useful for those that wish to compute various components of a\ntyped data hash, primary types, or sub-components, but generally the\nhigher level [[Signer-signTypedData]] is more useful.",
      "tags": []
    },
    {
      "name": "verifyTypedData",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}",
      "doc": "Compute the address used to sign the typed data for the %%signature%%.",
      "tags": []
    },
    {
      "name": "getDefaultProvider",
      "kind": "FunctionDeclaration",
      "signature": "export function getDefaultProvider(network?: string | Networkish | WebSocketLike, options?: any): AbstractProvider {\n    if (options == null) { options = { }; }\n\n    const allowService = (name: string) => {\n        if (options[name] === \"-\") { return false; }\n        if (typeof(options.exclusive) ==",
      "doc": "Returns a default provider for %%network%%.\n\nIf %%network%% is a [[WebSocketLike]] or string that begins with\n``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\nby that WebSocket or URL.\n\nIf %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\na [[JsonRpcProvider]] is returned connected to that URL.\n\nOtherwise, a default provider is created backed by well-known public\nWeb3 backends (such as [[link-infura]]) using community-provided API\nkeys.\n\nThe %%options%% allows specifying custom API keys per backend (setting\nan API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\ncan be set to either a backend name or and array of backend names, which\nwill whitelist **only** those backends.\n\nCurrent backend strings supported are:\n- ``\"alchemy\"``\n- ``\"ankr\"``\n- ``\"cloudflare\"``\n- ``\"chainstack\"``\n- ``\"etherscan\"``\n- ``\"infura\"``\n- ``\"publicPolygon\"``\n- ``\"quicknode\"``",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Connect to a local Geth node\nprovider = getDefaultProvider(\"http://localhost:8545/\");\n\n// Connect to Ethereum mainnet with any current and future\n// third-party services available\nprovider = getDefaultProvider(\"mainnet\");\n\n// Connect to Polygon, but only allow Etherscan and\n// INFURA and use \"MY_API_KEY\" in calls to Etherscan.\nprovider = getDefaultProvider(\"matic\", {\netherscan: \"MY_API_KEY\",\nexclusive: [ \"etherscan\", \"infura\" ]\n});"
        }
      ]
    },
    {
      "name": "getDefaultProvider.#subs",
      "kind": "PropertyDeclaration",
      "signature": "#subs: Map<string, Sub>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#plugins",
      "kind": "PropertyDeclaration",
      "signature": "#plugins: Map<string, AbstractProviderPlugin>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#pausedState",
      "kind": "PropertyDeclaration",
      "signature": "#pausedState: null | boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#destroyed",
      "kind": "PropertyDeclaration",
      "signature": "#destroyed: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#networkPromise",
      "kind": "PropertyDeclaration",
      "signature": "#networkPromise: null | Promise<Network>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#anyNetwork",
      "kind": "PropertyDeclaration",
      "signature": "readonly #anyNetwork: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#performCache",
      "kind": "PropertyDeclaration",
      "signature": "#performCache: Map<string, Promise<any>>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#lastBlockNumber",
      "kind": "PropertyDeclaration",
      "signature": "#lastBlockNumber: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#nextTimer",
      "kind": "PropertyDeclaration",
      "signature": "#nextTimer: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#timers",
      "kind": "PropertyDeclaration",
      "signature": "#timers: Map<number, { timer: null | Timer, func: () => void, time: number }>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#disableCcipRead",
      "kind": "PropertyDeclaration",
      "signature": "#disableCcipRead: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#options",
      "kind": "PropertyDeclaration",
      "signature": "#options: Required<AbstractProviderOptions>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.pollingInterval",
      "kind": "GetAccessor",
      "signature": "get pollingInterval(): number { return this.#options.pollingInterval; }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.provider",
      "kind": "GetAccessor",
      "signature": "get provider(): this { return this; }",
      "doc": "Returns ``this``, to allow an **AbstractProvider** to implement\nthe [[ContractRunner]] interface.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.plugins",
      "kind": "GetAccessor",
      "signature": "get plugins(): Array<AbstractProviderPlugin> {\n        return Array.from(this.#plugins.values());\n    }",
      "doc": "Returns all the registered plug-ins.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.attachPlugin",
      "kind": "MethodDeclaration",
      "signature": "attachPlugin(plugin: AbstractProviderPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name,  plugin.connect(this));\n        return this;\n    }",
      "doc": "Attach a new plug-in.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getPlugin",
      "kind": "MethodDeclaration",
      "signature": "getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }",
      "doc": "Get a plugin by name.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.disableCcipRead",
      "kind": "GetAccessor",
      "signature": "get disableCcipRead(): boolean { return this.#disableCcipRead; }",
      "doc": "Prevent any CCIP-read operation, regardless of whether requested\nin a [[call]] using ``enableCcipRead``.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#perform",
      "kind": "MethodDeclaration",
      "signature": "async #perform<T = any>(req: PerformActionRequest): Promise<T> {\n        const timeout = this.#options.cacheTimeout;\n\n        // Caching disabled\n        if (timeout < 0) { return await this._perform(req); }\n\n        // Create a tag\n        const tag = getTag(req.method, req);\n\n        let perform =",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.ccipReadFetch",
      "kind": "MethodDeclaration",
      "signature": "async ccipReadFetch(tx: PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n     ",
      "doc": "Resolves to the data for executing the CCIP-read operations.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapBlock",
      "kind": "MethodDeclaration",
      "signature": "_wrapBlock(value: BlockParams, network: Network): Block {\n        return new Block(formatBlock(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a block before\nreturning it, to add additional properties or an alternate\nsub-class of [[Block]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapLog",
      "kind": "MethodDeclaration",
      "signature": "_wrapLog(value: LogParams, network: Network): Log {\n        return new Log(formatLog(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a log before\nreturning it, to add additional properties or an alternate\nsub-class of [[Log]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapTransactionReceipt",
      "kind": "MethodDeclaration",
      "signature": "_wrapTransactionReceipt(value: TransactionReceiptParams, network: Network): TransactionReceipt {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a transaction\nreceipt before returning it, to add additional properties or an\nalternate sub-class of [[TransactionReceipt]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapTransactionResponse",
      "kind": "MethodDeclaration",
      "signature": "_wrapTransactionResponse(tx: TransactionResponseParams, network: Network): TransactionResponse {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a transaction\nresponse before returning it, to add additional properties or an\nalternate sub-class of [[TransactionResponse]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._detectNetwork",
      "kind": "MethodDeclaration",
      "signature": "_detectNetwork(): Promise<Network> {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }",
      "doc": "Resolves to the Network, forcing a network detection using whatever\ntechnique the sub-class requires.\n\nSub-classes **must** override this.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._perform",
      "kind": "MethodDeclaration",
      "signature": "async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        assert(false, `unsupported method: ${ req.method }`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }",
      "doc": "Sub-classes should use this to perform all built-in operations. All\nmethods sanitizes and normalizes the values passed into this.\n\nSub-classes **must** override this.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBlockNumber",
      "kind": "MethodDeclaration",
      "signature": "async getBlockNumber(): Promise<number> {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) { this.#lastBlockNumber = blockNumber; }\n        return blockNumber;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getAddress",
      "kind": "MethodDeclaration",
      "signature": "_getAddress(address: AddressLike): string | Promise<string> {\n        return resolveAddress(address, this);\n    }",
      "doc": "Returns or resolves to the address for %%address%%, resolving ENS\nnames and [[Addressable]] objects and returning if already an\naddress.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getBlockTag",
      "kind": "MethodDeclaration",
      "signature": "_getBlockTag(blockTag?: BlockTag): string | Promise<string> {\n        if (blockTag == null) { return \"latest\"; }\n\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            ca",
      "doc": "Returns or resolves to a valid block tag for %%blockTag%%, resolving\nnegative values and returning if already a valid block tag.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getFilter",
      "kind": "MethodDeclaration",
      "signature": "_getFilter(filter: Filter | FilterByBlockHash): PerformActionFilter | Promise<PerformActionFilter> {\n\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || [ ]).map((t) => {\n            if (t == null) { return null; }\n            if (Array.isArray(t)) {\n",
      "doc": "Returns or resolves to a filter for %%filter%%, resolving any ENS\nnames or [[Addressable]] object and returning if already a valid\nfilter.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getTransactionRequest",
      "kind": "MethodDeclaration",
      "signature": "_getTransactionRequest(_request: TransactionRequest): PerformActionTransaction | Promise<PerformActionTransaction> {\n        const request = <PerformActionTransaction>copyRequest(_request);\n\n        const promises: Array<Promise<void>> = [ ];\n        [ \"to\", \"from\" ].forEach((key) => {\n            i",
      "doc": "Returns or resolves to a transaction for %%request%%, resolving\nany ENS names or [[Addressable]] and returning if already a valid\ntransaction.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getNetwork",
      "kind": "MethodDeclaration",
      "signature": "async getNetwork(): Promise<Network> {\n\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n            ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getFeeData",
      "kind": "MethodDeclaration",
      "signature": "async getFeeData(): Promise<FeeData> {\n        const network = await this.getNetwork();\n\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await resolveProperties({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((a",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.estimateGas",
      "kind": "MethodDeclaration",
      "signature": "async estimateGas(_tx: TransactionRequest): Promise<bigint> {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) { tx = await tx; }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#call",
      "kind": "MethodDeclaration",
      "signature": "async #call(tx: PerformActionTransaction, blockTag: string, attempt: number): Promise<string> {\n        assert (attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n             reason: \"TOO_MANY_REDIRECTS\",\n             transaction: Object.assign({ }, tx, { b",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#checkNetwork",
      "kind": "MethodDeclaration",
      "signature": "async #checkNetwork<T>(promise: Promise<T>): Promise<T> {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.call",
      "kind": "MethodDeclaration",
      "signature": "async call(_tx: TransactionRequest): Promise<string> {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getAccountValue",
      "kind": "MethodDeclaration",
      "signature": "async #getAccountValue(request: _PerformAccountRequest, _address: AddressLike, _blockTag?: BlockTag): Promise<any> {\n        let address: string | Promise<string> = this._getAddress(_address);\n        let blockTag: string | Promise<string> = this._getBlockTag(_blockTag);\n\n        if (typeof(address)",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBalance",
      "kind": "MethodDeclaration",
      "signature": "async getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint> {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionCount",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number> {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getCode",
      "kind": "MethodDeclaration",
      "signature": "async getCode(address: AddressLike, blockTag?: BlockTag): Promise<string> {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getStorage",
      "kind": "MethodDeclaration",
      "signature": "async getStorage(address: AddressLike, _position: BigNumberish, blockTag?: BlockTag): Promise<string> {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.broadcastTransaction",
      "kind": "MethodDeclaration",
      "signature": "async broadcastTransaction(signedTx: string): Promise<TransactionResponse> {\n        const { blockNumber, hash, network } = await resolveProperties({\n             blockNumber: this.getBlockNumber(),\n             hash: this._perform({\n                 method: \"broadcastTransaction\",\n                 ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getBlock",
      "kind": "MethodDeclaration",
      "signature": "async #getBlock(block: BlockTag | string, includeTransactions: boolean): Promise<any> {\n        // @TODO: Add CustomBlockPlugin check\n\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBlock",
      "kind": "MethodDeclaration",
      "signature": "async getBlock(block: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) { return nul",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransaction",
      "kind": "MethodDeclaration",
      "signature": "async getTransaction(hash: string): Promise<null | TransactionResponse> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) { return null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionReceipt",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionReceipt(hash: string): Promise<null | TransactionReceipt> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) {",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionResult",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionResult(hash: string): Promise<null | string> {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) { return null; }\n       ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getLogs",
      "kind": "MethodDeclaration",
      "signature": "async getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>> {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) { filter = await filter; }\n\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getProvider",
      "kind": "MethodDeclaration",
      "signature": "_getProvider(chainId: number): AbstractProvider {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getResolver",
      "kind": "MethodDeclaration",
      "signature": "async getResolver(name: string): Promise<null | EnsResolver> {\n        return await EnsResolver.fromName(this, name);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getAvatar",
      "kind": "MethodDeclaration",
      "signature": "async getAvatar(name: string): Promise<null | string> {\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAvatar(); }\n        return null;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.resolveName",
      "kind": "MethodDeclaration",
      "signature": "async resolveName(name: string): Promise<null | string>{\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAddress(); }\n        return null;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.lookupAddress",
      "kind": "MethodDeclaration",
      "signature": "async lookupAddress(address: string): Promise<null | string> {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n\n        try {\n\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.waitForTransaction",
      "kind": "MethodDeclaration",
      "signature": "async waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms != null) ? _confirms: 1;\n        if (confirms === 0) { return this.getTransactionReceipt(hash); }\n\n        return new Promise(async (re",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.waitForBlock",
      "kind": "MethodDeclaration",
      "signature": "async waitForBlock(blockTag?: BlockTag): Promise<Block> {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._clearTimeout",
      "kind": "MethodDeclaration",
      "signature": "_clearTimeout(timerId: number): void {\n        const timer = this.#timers.get(timerId);\n        if (!timer) { return; }\n        if (timer.timer) { clearTimeout(timer.timer); }\n        this.#timers.delete(timerId);\n    }",
      "doc": "Clear a timer created using the [[_setTimeout]] method.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._setTimeout",
      "kind": "MethodDeclaration",
      "signature": "_setTimeout(_func: () => void, timeout?: number): number {\n        if (timeout == null) { timeout = 0; }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n\n        if (this.paused) {\n            this.#tim",
      "doc": "Create a timer that will execute %%func%% after at least %%timeout%%\n(in ms). If %%timeout%% is unspecified, then %%func%% will execute\nin the next event loop.\n\n[Pausing](AbstractProvider-paused) the provider will pause any\nassociated timers.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._forEachSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_forEachSubscriber(func: (s: Subscriber) => void): void {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }",
      "doc": "Perform %%func%% on each subscriber.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new PollingBlockSubscri",
      "doc": "Sub-classes may override this to customize subscription\nimplementations.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._recoverSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) { sub.subscriber.stop(); }\n                sub.subscriber = newSub;\n                if (sub.started) { new",
      "doc": "If a [[Subscriber]] fails and needs to replace itself, this\nmethod may be used.\n\nFor example, this is used for providers when using the\n``eth_getFilterChanges`` method, which can return null if state\nfilters are not supported by the backend, allowing the Subscriber\nto swap in a [[PollingEventSubscriber]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#hasSub",
      "kind": "MethodDeclaration",
      "signature": "async #hasSub(event: ProviderEvent, emitArgs?: Array<any>): Promise<null | Sub> {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getSub",
      "kind": "MethodDeclaration",
      "signature": "async #getSub(event: ProviderEvent): Promise<Sub> {\n        const subscription = await getSubscription(event, this);\n\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n          ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.on",
      "kind": "MethodDeclaration",
      "signature": "async on(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.once",
      "kind": "MethodDeclaration",
      "signature": "async once(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.emit",
      "kind": "MethodDeclaration",
      "signature": "async emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean> {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.len",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.listenerCount",
      "kind": "MethodDeclaration",
      "signature": "async listenerCount(event?: ProviderEvent): Promise<number> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        let total = 0;\n        for (const { listeners } of this.#subs.values()",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.listeners",
      "kind": "MethodDeclaration",
      "signature": "async listeners(event?: ProviderEvent): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return  [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result: Array<Listener> = [ ];\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.off",
      "kind": "MethodDeclaration",
      "signature": "async off(event: ProviderEvent, listener?: Listener): Promise<this> {\n        const sub = await this.#hasSub(event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { su",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.removeAllListeners",
      "kind": "MethodDeclaration",
      "signature": "async removeAllListeners(event?: ProviderEvent): Promise<this> {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) { subscriber.stop(); }\n            this.#subs.delete(tag);\n        } else {\n            for (const [ tag, { start",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.addListener",
      "kind": "MethodDeclaration",
      "signature": "async addListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return await this.on(event, listener);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.removeListener",
      "kind": "MethodDeclaration",
      "signature": "async removeListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return this.off(event, listener);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.destroyed",
      "kind": "GetAccessor",
      "signature": "get destroyed(): boolean {\n        return this.#destroyed;\n    }",
      "doc": "If this provider has been destroyed using the [[destroy]] method.\n\nOnce destroyed, all resources are reclaimed, internal event loops\nand timers are cleaned up and no further requests may be sent to\nthe provider.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.destroy",
      "kind": "MethodDeclaration",
      "signature": "destroy(): void {\n        // Stop all listeners\n        this.removeAllListeners();\n\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n\n        this.#destroyed = true;\n    }",
      "doc": "Sub-classes may use this to shutdown any sockets or release their\nresources and reject any pending requests.\n\nSub-classes **must** call ``super.destroy()``.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.paused",
      "kind": "GetAccessor",
      "signature": "get paused(): boolean { return (this.#pausedState != null); }",
      "doc": "Whether the provider is currently paused.\n\nA paused provider will not emit any events, and generally should\nnot make any requests to the network, but that is up to sub-classes\nto manage.\n\nSetting ``paused = true`` is identical to calling ``.pause(false)``,\nwhich will buffer any events that occur while paused until the\nprovider is unpaused.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.pause",
      "kind": "MethodDeclaration",
      "signature": "pause(dropWhilePaused?: boolean): void {\n        this.#lastBlockNumber = -1;\n\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) { return; }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                op",
      "doc": "Pause the provider. If %%dropWhilePaused%%, any events that occur\nwhile paused are dropped, otherwise all events will be emitted once\nthe provider is unpaused.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.resume",
      "kind": "MethodDeclaration",
      "signature": "resume(): void {\n        if (this.#pausedState == null) { return; }\n\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n    ",
      "doc": "Resume the provider.",
      "tags": []
    },
    {
      "name": "Block",
      "kind": "ClassDeclaration",
      "signature": "export class Block implements BlockParams, Iterable<string> {\n\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  ",
      "doc": "A **Block** represents the data associated with a full block on\nEthereum.",
      "tags": []
    },
    {
      "name": "FeeData",
      "kind": "ClassDeclaration",
      "signature": "export class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    readonly gasPrice!: null | bigint;\n\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of",
      "doc": "A **FeeData** wraps all the fee-related values associated with\nthe network.",
      "tags": []
    },
    {
      "name": "Log",
      "kind": "ClassDeclaration",
      "signature": "export class Log implements LogParams {\n\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransacti",
      "doc": "A **Log** in Ethereum represents an event that has been included in a\ntransaction using the ``LOG*`` opcodes, which are most commonly used by\nSolidity's emit for announcing events.",
      "tags": []
    },
    {
      "name": "TransactionReceipt",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionReceipt implements TransactionReceiptParams, Iterable<Log> {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The address the transaction was sent to.\n     */\n  ",
      "doc": "A **TransactionReceipt** includes additional information about a\ntransaction that is only available after it has been mined.",
      "tags": []
    },
    {
      "name": "TransactionResponse",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionResponse implements TransactionLike<string>, TransactionResponseParams {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The bl",
      "doc": "A **TransactionResponse** includes all properties about a transaction\nthat was sent to the network, which may or may not be included in a\nblock.\n\nThe [[TransactionResponse-isMined]] can be used to check if the\ntransaction has been mined as well as type guard that the otherwise\npossibly ``null`` properties are defined.",
      "tags": []
    },
    {
      "name": "AbstractSigner",
      "kind": "ClassDeclaration",
      "signature": "export abstract class AbstractSigner<P extends null | Provider = null | Provider> implements Signer {\n    /**\n     *  The provider this signer is connected to.\n     */\n    readonly provider!: P;\n\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider?: P) {\n",
      "doc": "An **AbstractSigner** includes most of teh functionality required\nto get a [[Signer]] working as expected, but requires a few\nSigner-specific methods be overridden.",
      "tags": []
    },
    {
      "name": "NonceManager",
      "kind": "ClassDeclaration",
      "signature": "export class NonceManager extends AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer!: Signer;\n\n    #noncePromise: null | Promise<number>;\n    #delta: number;\n\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer: Signer) {\n  ",
      "doc": "A **NonceManager** wraps another [[Signer]] and automatically manages\nthe nonce, ensuring serialized and sequential nonces are used during\ntransaction.",
      "tags": []
    },
    {
      "name": "VoidSigner",
      "kind": "ClassDeclaration",
      "signature": "export class VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    readonly address!: string;\n\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address: string, provider?: null | Provider) {\n        ",
      "doc": "A **VoidSigner** is a class deisgned to allow an address to be used\nin any API which accepts a Signer, but for which there are no\ncredentials available to perform any actual signing.\n\nThis for example allow impersonating an account for the purpose of\nstatic calls or estimating gas, but does not allow sending transactions.",
      "tags": []
    },
    {
      "name": "AbstractProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AbstractProvider implements Provider {\n\n    #subs: Map<string, Sub>;\n    #plugins: Map<string, AbstractProviderPlugin>;\n\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState: null | boolean;\n\n    #destroyed: boolean;\n\n    #networkPromise: null | Promise<Netwo",
      "doc": "An **AbstractProvider** provides a base class for other sub-classes to\nimplement the [[Provider]] API by normalizing input arguments and\nformatting output results as well as tracking events for consistent\nbehaviour on an eventually-consistent network.",
      "tags": []
    },
    {
      "name": "FallbackProvider",
      "kind": "ClassDeclaration",
      "signature": "export class FallbackProvider extends AbstractProvider {\n\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    readonly quorum: number;\n\n    /**\n     *  @_ignore:\n     */\n    readonly eventQuorum: number;\n\n    /**\n     *  @_ignore:\n     */\n    ",
      "doc": "A **FallbackProvider** manages several [[Providers]] providing\nresilience by switching between slow or misbehaving nodes, security\nby requiring multiple backends to aggree and performance by allowing\nfaster backends to respond earlier.",
      "tags": []
    },
    {
      "name": "JsonRpcApiProvider",
      "kind": "ClassDeclaration",
      "signature": "export abstract class JsonRpcApiProvider extends AbstractProvider {\n\n    #options: Required<JsonRpcApiProviderOptions>;\n\n    // The next ID to use for the JSON-RPC ID field\n    #nextId: number;\n\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads: Array<Payload>;\n ",
      "doc": "The JsonRpcApiProvider is an abstract class and **MUST** be\nsub-classed.\n\nIt provides the base for all JSON-RPC-based Provider interaction.\n\nSub-classing Notes:\n- a sub-class MUST override _send\n- a sub-class MUST call the `_start()` method once connected",
      "tags": []
    },
    {
      "name": "JsonRpcProvider",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect: FetchRequest;\n\n    constructor(url?: string | FetchRequest, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        if (url == null) { url = \"http:/\\/localhost:8545\"; }\n        super(network, options);\n\n     ",
      "doc": "The JsonRpcProvider is one of the most common Providers,\nwhich performs all operations over HTTP (or HTTPS) requests.\n\nEvents are processed by polling the backend for the current block\nnumber; when it advances, all block-base events are then checked\nfor updates.",
      "tags": []
    },
    {
      "name": "JsonRpcSigner",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcSigner extends AbstractSigner<JsonRpcApiProvider> {\n    address!: string;\n\n    constructor(provider: JsonRpcApiProvider, address: string) {\n        super(provider);\n        address = getAddress(address);\n        defineProperties<JsonRpcSigner>(this, { address });\n    }\n\n    conne",
      "doc": "",
      "tags": []
    },
    {
      "name": "BrowserProvider",
      "kind": "ClassDeclaration",
      "signature": "export class BrowserProvider extends JsonRpcApiPollingProvider {\n    #request: (method: string, params: Array<any> | Record<string, any>) => Promise<any>;\n\n    #providerInfo: null | Eip6963ProviderInfo;\n\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%",
      "doc": "A **BrowserProvider** is intended to wrap an injected provider which\nadheres to the [[link-eip-1193]] standard, which most (if not all)\ncurrently do.",
      "tags": []
    },
    {
      "name": "AlchemyProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AlchemyProvider extends JsonRpcProvider implements CommunityResourcable {\n    readonly apiKey!: string;\n\n    constructor(_network?: Networkish, apiKey?: null | string) {\n        if (_network == null) { _network = \"mainnet\"; }\n        const network = Network.from(_network);\n        if (a",
      "doc": "The **AlchemyProvider** connects to the [[link-alchemy]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-alchemy-signup).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty"
        }
      ]
    },
    {
      "name": "AnkrProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AnkrProvider extends JsonRpcProvider implements CommunityResourcable {\n\n    /**\n     *  The API key for the Ankr connection.\n     */\n    readonly apiKey!: string;\n\n    /**\n     *  Create a new **AnkrProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n",
      "doc": "The **AnkrProvider** connects to the [[link-ankr]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-ankr-signup).",
      "tags": []
    },
    {
      "name": "BlockscoutProvider",
      "kind": "ClassDeclaration",
      "signature": "export class BlockscoutProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API key.\n     */\n    readonly apiKey!: null | string;\n\n    /**\n     *  Creates a new **BlockscoutProvider**.\n     */\n    constructor(_network?: Networkish, apiKey?: null | string) {\n        ",
      "doc": "The **BlockscoutProvider** connects to the [[link-blockscout]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-blockscout).",
      "tags": []
    },
    {
      "name": "ChainstackProvider",
      "kind": "ClassDeclaration",
      "signature": "export class ChainstackProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API key for the Chainstack connection.\n     */\n    readonly apiKey!: string;\n\n    /**\n     *  Creates a new **ChainstackProvider**.\n     */\n    constructor(_network?: Networkish, apiKey?: nu",
      "doc": "The **ChainstackProvider** connects to the [[link-chainstack]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-chainstack).",
      "tags": []
    },
    {
      "name": "CloudflareProvider",
      "kind": "ClassDeclaration",
      "signature": "export class CloudflareProvider extends JsonRpcProvider {\n    constructor(_network?: Networkish) {\n        if (_network == null) { _network = \"mainnet\"; }\n        const network = Network.from(_network);\n        assertArgument(network.name === \"mainnet\", \"unsupported network\", \"network\", _network);\n ",
      "doc": "About Cloudflare...",
      "tags": []
    },
    {
      "name": "EtherscanProvider",
      "kind": "ClassDeclaration",
      "signature": "export class EtherscanProvider extends AbstractProvider {\n\n    /**\n     *  The connected network.\n     */\n    readonly network!: Network;\n\n    /**\n     *  The API key or null if using the community provided bandwidth.\n     */\n    readonly apiKey!: null | string;\n\n    readonly #plugin: null | Ethersc",
      "doc": "The **EtherscanBaseProvider** is the super-class of\n[[EtherscanProvider]], which should generally be used instead.\n\nSince the **EtherscanProvider** includes additional code for\n[[Contract]] access, in //rare cases// that contracts are not\nused, this class can reduce code size.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "InfuraProvider",
      "kind": "ClassDeclaration",
      "signature": "export class InfuraProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    readonly projectId!: string;\n\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This should not\n  ",
      "doc": "The **InfuraProvider** connects to the [[link-infura]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-infura-signup).",
      "tags": []
    },
    {
      "name": "InfuraWebSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    readonly projectId!: string;\n\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This s",
      "doc": "The **InfuraWebSocketProvider** connects to the [[link-infura]]\nWebSocket end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-infura-signup).",
      "tags": []
    },
    {
      "name": "PocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class PocketProvider extends JsonRpcProvider implements CommunityResourcable {\n\n    /**\n     *  The Application ID for the Pocket connection.\n     */\n    readonly applicationId!: string;\n\n    /**\n     *  The Application Secret for making authenticated requests\n     *  to the Pocket connection",
      "doc": "The **PocketProvider** connects to the [[link-pocket]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-pocket-signup).",
      "tags": []
    },
    {
      "name": "QuickNodeProvider",
      "kind": "ClassDeclaration",
      "signature": "export class QuickNodeProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API token.\n     */\n    readonly token!: string;\n\n    /**\n     *  Creates a new **QuickNodeProvider**.\n     */\n    constructor(_network?: Networkish, token?: null | string) {\n        if (_netw",
      "doc": "The **QuickNodeProvider** connects to the [[link-quicknode]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API token is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-quicknode).",
      "tags": []
    },
    {
      "name": "IpcSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class IpcSocketProvider extends SocketProvider {\n    #socket: Socket;\n\n    /**\n     *  The connected socket.\n     */\n    get socket(): Socket { return this.#socket; }\n\n    constructor(path: string, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n ",
      "doc": "An **IpcSocketProvider** connects over an IPC socket on the host\nwhich provides fast access to the node, but requires the node and\nthe script run on the same machine.",
      "tags": []
    },
    {
      "name": "SocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class SocketProvider extends JsonRpcApiProvider {\n    #callbacks: Map<number, { payload: JsonRpcPayload, resolve: (r: any) => void, reject: (e: Error) => void }>;\n\n    // Maps each filterId to its subscriber\n    #subs: Map<number | string, SocketSubscriber>;\n\n    // If any events come in befo",
      "doc": "A **SocketProvider** is backed by a long-lived connection over a\nsocket, which can subscribe and receive real-time messages over\nits communication channel.",
      "tags": []
    },
    {
      "name": "WebSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class WebSocketProvider extends SocketProvider {\n    #connect: null | WebSocketCreator;\n\n    #websocket: null | WebSocketLike;\n    get websocket(): WebSocketLike {\n        if (this.#websocket == null) { throw new Error(\"websocket closed\"); }\n        return this.#websocket;\n    }\n\n    construc",
      "doc": "A JSON-RPC provider which is backed by a WebSocket.\n\nWebSockets are often preferred because they retain a live connection\nto a server, which permits more instant access to events.\n\nHowever, this incurs higher server infrasturture costs, so additional\nresources may be required to host your own WebSocket nodes and many\nthird-party services charge additional fees for WebSocket endpoints.",
      "tags": []
    },
    {
      "name": "EnsResolver",
      "kind": "ClassDeclaration",
      "signature": "export class EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider!: AbstractProvider;\n\n    /**\n     *  The address of the resolver.\n     */\n    address!: string;\n\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name!: string;\n\n    // For EIP-2544 names,",
      "doc": "A connected object to a resolved ENS name resolver, which can be\nused to query additional details.",
      "tags": []
    },
    {
      "name": "Network",
      "kind": "ClassDeclaration",
      "signature": "export class Network {\n    #name: string;\n    #chainId: bigint;\n\n    #plugins: Map<string, NetworkPlugin>;\n\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */\n    constructor(name: string, chainId: BigNumberish) {\n        this.#name = name;\n        this.#chainId = getBig",
      "doc": "A **Network** provides access to a chain's properties and allows\nfor plug-ins to extend functionality.",
      "tags": []
    },
    {
      "name": "EnsPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class EnsPlugin extends NetworkPlugin {\n\n    /**\n     *  The ENS Registrty Contract address.\n     */\n    readonly address!: string;\n\n    /**\n     *  The chain ID that the ENS contract lives on.\n     */\n    readonly targetNetwork!: number;\n\n    /**\n     *  Creates a new **EnsPlugin** connected",
      "doc": "An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\nContract address and the target network to use when using that\ncontract.\n\nVarious testnets have their own instance of the contract to use, but\nin general, the mainnet instance supports multi-chain addresses and\nshould be used.",
      "tags": []
    },
    {
      "name": "EtherscanPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class EtherscanPlugin extends NetworkPlugin {\n    /**\n     *  The Etherscan API base URL.\n     */\n    readonly baseUrl!: string;\n\n    /**\n     *  Creates a new **EtherscanProvider** which will use\n     *  %%baseUrl%%.\n     */\n    constructor(baseUrl: string) {\n        super(EtherscanPluginId)",
      "doc": "A Network can include an **EtherscanPlugin** to provide\na custom base URL.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "FeeDataNetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class FeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #feeDataFunc: (provider: Provider) => Promise<FeeData>;\n\n    /**\n     *  The fee data function provided to the constructor.\n     */\n    get feeDataFunc(): (provider: Provider) => Promise<FeeData> {\n        return this.#feeDataFun",
      "doc": "A **FeeDataNetworkPlugin** allows a network to provide and alternate\nmeans to specify its fee data.\n\nFor example, a network which does not support [[link-eip-1559]] may\nchoose to use a Gas Station site to approximate the gas price.",
      "tags": []
    },
    {
      "name": "FetchUrlFeeDataNetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #url: string;\n    readonly #processFunc: (f: () => Promise<FeeData>, p: Provider, r: FetchRequest) => Promise<{ gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint }>;\n\n    /**\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "GasCostPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class GasCostPlugin extends NetworkPlugin implements GasCostParameters {\n    /**\n     *  The block number to treat these values as valid from.\n     *\n     *  This allows a hardfork to have updated values included as well as\n     *  mulutiple hardforks to be supported.\n     */\n    readonly eff",
      "doc": "A **GasCostPlugin** allows a network to provide alternative values when\ncomputing the intrinsic gas required for a transaction.",
      "tags": []
    },
    {
      "name": "NetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class NetworkPlugin {\n    /**\n     *  The name of the plugin.\n     *\n     *  It is recommended to use reverse-domain-notation, which permits\n     *  unique names with a known authority as well as hierarchal entries.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **NetworkP",
      "doc": "A **NetworkPlugin** provides additional functionality on a [[Network]].",
      "tags": []
    },
    {
      "name": "MulticoinProviderPlugin",
      "kind": "ClassDeclaration",
      "signature": "export abstract class MulticoinProviderPlugin implements AbstractProviderPlugin {\n    /**\n     *  The name.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name: string) {\n        defineProperties<MulticoinProviderP",
      "doc": "A provider plugin super-class for processing multicoin address types.",
      "tags": []
    },
    {
      "name": "SocketBlockSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newHeads\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"block\", parseInt",
      "doc": "A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n``\"block\"`` events.",
      "tags": []
    },
    {
      "name": "SocketEventSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketEventSubscriber extends SocketSubscriber {\n    #logFilter: string;\n\n    /**\n     *  The filter.\n     */\n    get logFilter(): EventFilter { return JSON.parse(this.#logFilter); }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider, filter: EventFilter) {\n    ",
      "doc": "A **SocketEventSubscriber** listens for event logs.",
      "tags": []
    },
    {
      "name": "SocketPendingSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketPendingSubscriber extends SocketSubscriber {\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newPendingTransactions\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(",
      "doc": "A **SocketPendingSubscriber** listens for pending transacitons and emits\n``\"pending\"`` events.",
      "tags": []
    },
    {
      "name": "SocketSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketSubscriber implements Subscriber {\n    #provider: SocketProvider;\n\n    #filter: string;\n\n    /**\n     *  The filter.\n     */\n    get filter(): Array<any> { return JSON.parse(this.#filter); }\n\n    #filterId: null | Promise<string |number>;\n    #paused: null | boolean;\n\n    #emitPro",
      "doc": "A **SocketSubscriber** uses a socket transport to handle events and\nshould use [[_emit]] to manage the events.",
      "tags": []
    },
    {
      "name": "UnmanagedSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class UnmanagedSubscriber implements Subscriber {\n    /**\n     *  The name fof the event.\n     */\n    name!: string;\n\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name: string) { defineProperties<UnmanagedSubscriber>(this, { name }); }\n\n    start(): ",
      "doc": "An **UnmanagedSubscriber** is useful for events which do not require\nany additional management, such as ``\"debug\"`` which only requires\nemit in synchronous event loop triggered calls.",
      "tags": []
    },
    {
      "name": "copyRequest",
      "kind": "FunctionDeclaration",
      "signature": "export function copyRequest(req: TransactionRequest): PreparedTransactionRequest {\n    const result: any = { };\n\n    // These could be addresses, ENS names or Addressables\n    if (req.to) { result.to = req.to; }\n    if (req.from) { result.from = req.from; }\n\n    if (req.data) { result.data = hexlify",
      "doc": "Returns a copy of %%req%% with all properties coerced to their strict\ntypes.",
      "tags": []
    },
    {
      "name": "copyRequest.type",
      "kind": "PropertySignature",
      "signature": "type?: number;",
      "doc": "The transaction type.",
      "tags": []
    },
    {
      "name": "copyRequest.to",
      "kind": "PropertySignature",
      "signature": "to?: AddressLike;",
      "doc": "The target of the transaction.",
      "tags": []
    },
    {
      "name": "copyRequest.from",
      "kind": "PropertySignature",
      "signature": "from?: AddressLike;",
      "doc": "The sender of the transaction.",
      "tags": []
    },
    {
      "name": "copyRequest.nonce",
      "kind": "PropertySignature",
      "signature": "nonce?: number;",
      "doc": "The nonce of the transaction, used to prevent replay attacks.",
      "tags": []
    },
    {
      "name": "copyRequest.gasLimit",
      "kind": "PropertySignature",
      "signature": "gasLimit?: bigint;",
      "doc": "The maximum amount of gas to allow this transaction to consume.",
      "tags": []
    },
    {
      "name": "copyRequest.gasPrice",
      "kind": "PropertySignature",
      "signature": "gasPrice?: bigint;",
      "doc": "The gas price to use for legacy transactions or transactions on\nlegacy networks.\n\nMost of the time the ``max*FeePerGas`` is preferred.",
      "tags": []
    },
    {
      "name": "copyRequest.maxPriorityFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxPriorityFeePerGas?: bigint;",
      "doc": "The [[link-eip-1559]] maximum priority fee to pay per gas.",
      "tags": []
    },
    {
      "name": "copyRequest.maxFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxFeePerGas?: bigint;",
      "doc": "The [[link-eip-1559]] maximum total fee to pay per gas. The actual\nvalue used is protocol enforced to be the block's base fee.",
      "tags": []
    },
    {
      "name": "copyRequest.data",
      "kind": "PropertySignature",
      "signature": "data?: string;",
      "doc": "The transaction data.",
      "tags": []
    },
    {
      "name": "copyRequest.value",
      "kind": "PropertySignature",
      "signature": "value?: bigint;",
      "doc": "The transaction value (in wei).",
      "tags": []
    },
    {
      "name": "copyRequest.chainId",
      "kind": "PropertySignature",
      "signature": "chainId?: bigint;",
      "doc": "The chain ID for the network this transaction is valid on.",
      "tags": []
    },
    {
      "name": "copyRequest.accessList",
      "kind": "PropertySignature",
      "signature": "accessList?: AccessList;",
      "doc": "The [[link-eip-2930]] access list. Storage slots included in the access\nlist are //warmed// by pre-loading them, so their initial cost to\nfetch is guaranteed, but then each additional access is cheaper.",
      "tags": []
    },
    {
      "name": "copyRequest.authorizationList",
      "kind": "PropertySignature",
      "signature": "authorizationList?: Array<Authorization>;",
      "doc": "The [[link-eip-7702]] authorizations (if any).",
      "tags": []
    },
    {
      "name": "copyRequest.customData",
      "kind": "PropertySignature",
      "signature": "customData?: any;",
      "doc": "A custom object, which can be passed along for network-specific\nvalues.",
      "tags": []
    },
    {
      "name": "copyRequest.blockTag",
      "kind": "PropertySignature",
      "signature": "blockTag?: BlockTag;",
      "doc": "When using ``call`` or ``estimateGas``, this allows a specific\nblock to be queried. Many backends do not support this and when\nunsupported errors are silently squelched and ``\"latest\"`` is used.",
      "tags": []
    },
    {
      "name": "copyRequest.enableCcipRead",
      "kind": "PropertySignature",
      "signature": "enableCcipRead?: boolean;",
      "doc": "When using ``call``, this enables CCIP-read, which permits the\nprovider to be redirected to web-based content during execution,\nwhich is then further validated by the contract.\n\nThere are potential security implications allowing CCIP-read, as\nit could be used to expose the IP address or user activity during\nthe fetch to unexpected parties.",
      "tags": []
    },
    {
      "name": "showThrottleMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function showThrottleMessage(service: string): void {\n    if (shown.has(service)) { return; }\n    shown.add(service);\n\n    console.log(\"========= NOTICE =========\")\n    console.log(`Request-Rate Exceeded for ${ service } (this message will not be repeated)`);\n    console.log(\"\");\n    console.",
      "doc": "Displays a warning in the console when the community resource is\nbeing used too heavily by the app, recommending the developer\nacquire their own credentials instead of using the community\ncredentials.\n\nThe notification will only occur once per service.",
      "tags": []
    },
    {
      "name": "accessListify",
      "kind": "FunctionDeclaration",
      "signature": "export function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.le",
      "doc": "Returns a [[AccessList]] from any ethers-supported access-list structure.",
      "tags": []
    },
    {
      "name": "accessListify.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "authorizationify",
      "kind": "FunctionDeclaration",
      "signature": "export function authorizationify(auth: AuthorizationLike): Authorization {\n    return {\n        address: getAddress(auth.address),\n        nonce: getBigInt((auth.nonce != null) ? auth.nonce: 0),\n        chainId: getBigInt((auth.chainId != null)? auth.chainId: 0),\n        signature: Signature.from(au",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.address",
      "kind": "PropertySignature",
      "signature": "address: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.nonce",
      "kind": "PropertySignature",
      "signature": "nonce: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.chainId",
      "kind": "PropertySignature",
      "signature": "chainId: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.signature",
      "kind": "PropertySignature",
      "signature": "signature: Signature;",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function computeAddress(key: string | SigningKey): string {\n    let pubkey: string;\n    if (typeof(key) === \"string\") {\n        pubkey = SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).subs",
      "doc": "Returns the address for the %%key%%.\n\nThe key may be any standard form of public key or a private key.",
      "tags": []
    },
    {
      "name": "recoverAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\n}",
      "doc": "Returns the recovered address for the private key that was\nused to sign %%digest%% that resulted in %%signature%%.",
      "tags": []
    },
    {
      "name": "Transaction",
      "kind": "ClassDeclaration",
      "signature": "export class Transaction implements TransactionLike<string> {\n    #type: null | number;\n    #to: null | string;\n    #data: string;\n    #nonce: number;\n    #gasLimit: bigint;\n    #gasPrice: null | bigint;\n    #maxPriorityFeePerGas: null | bigint;\n    #maxFeePerGas: null | bigint;\n    #value: bigint;\n",
      "doc": "A **Transaction** describes an operation to be executed on\nEthereum by an Externally Owned Account (EOA). It includes\nwho (the [[to]] address), what (the [[data]]) and how much (the\n[[value]] in ether) the operation should entail.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\ntx = new Transaction()\n//_result:\n\ntx.data = \"0x1234\";\n//_result:"
        }
      ]
    },
    {
      "name": "decodeBase58",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase58(value: string): bigint {\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}",
      "doc": "Decode the Base58-encoded %%value%%.",
      "tags": []
    },
    {
      "name": "encodeBase58",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase58(_value: BytesLike): string {\n    const bytes = getBytes(_value);\n\n    let value = toBigInt(bytes);\n    let result = \"\";\n    while (value) {\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n\n    // Account for leading padding zeros\n",
      "doc": "Encode %%value%% as a Base58-encoded string.",
      "tags": []
    },
    {
      "name": "decodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase64(value: string): Uint8Array {\n    return getBytesCopy(Buffer.from(value, \"base64\"));\n}",
      "doc": "Decodes the base-64 encoded %%value%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// The decoded value is always binary data...\nresult = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n//_result:\n\n// ...use toUtf8String to convert it to a string.\ntoUtf8String(result)\n//_result:\n\n// Decoding binary data\ndecodeBase64(\"EjQ=\")\n//_result:"
        }
      ]
    },
    {
      "name": "decodeBase64.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "encodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase64(data: BytesLike): string {\n    return Buffer.from(getBytes(data)).toString(\"base64\");\n}",
      "doc": "Encodes %%data%% as a base-64 encoded string.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Encoding binary data as a hexstring\nencodeBase64(\"0x1234\")\n//_result:\n\n// Encoding binary data as a Uint8Array\nencodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n//_result:\n\n// The input MUST be data...\nencodeBase64(\"Hello World!!\")\n//_error:\n\n// ...use toUtf8Bytes for this.\nencodeBase64(toUtf8Bytes(\"Hello World!!\"))\n//_result:"
        }
      ]
    },
    {
      "name": "concat",
      "kind": "FunctionDeclaration",
      "signature": "export function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}",
      "doc": "Returns a [[DataHexString]] by concatenating all values\nwithin %%data%%.",
      "tags": []
    },
    {
      "name": "dataLength",
      "kind": "FunctionDeclaration",
      "signature": "export function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}",
      "doc": "Returns the length of %%data%%, in bytes.",
      "tags": []
    },
    {
      "name": "dataSlice",
      "kind": "FunctionDeclaration",
      "signature": "export function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n",
      "doc": "Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\noffset to the %%end%% offset.\n\nBy default %%start%% is 0 and %%end%% is the length of %%data%%.",
      "tags": []
    },
    {
      "name": "getBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}",
      "doc": "Get a typed Uint8Array for %%value%%. If already a Uint8Array\nthe original %%value%% is returned; if a copy is required use\n[[getBytesCopy]].",
      "tags": [
        {
          "tagName": "see",
          "text": ": getBytesCopy"
        }
      ]
    },
    {
      "name": "getBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "getBytesCopy",
      "kind": "FunctionDeclaration",
      "signature": "export function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}",
      "doc": "Get a typed Uint8Array for %%value%%, creating a copy if necessary\nto prevent any modifications of the returned value from being\nreflected elsewhere.",
      "tags": [
        {
          "tagName": "see",
          "text": ": getBytes"
        }
      ]
    },
    {
      "name": "getBytesCopy.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "hexlify",
      "kind": "FunctionDeclaration",
      "signature": "export function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}",
      "doc": "Returns a [[DataHexString]] representation of %%data%%.",
      "tags": []
    },
    {
      "name": "isHexString",
      "kind": "FunctionDeclaration",
      "signature": "export function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (lengt",
      "doc": "Returns true if %%value%% is a valid [[HexString]].\n\nIf %%length%% is ``true`` or a //number//, it also checks that\n%%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\nbytes of data (e.g. ``0x1234`` is 2 bytes).",
      "tags": []
    },
    {
      "name": "isBytesLike",
      "kind": "FunctionDeclaration",
      "signature": "export function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}",
      "doc": "Returns true if %%value%% is a valid representation of arbitrary\ndata (i.e. a valid [[DataHexString]] or a Uint8Array).",
      "tags": []
    },
    {
      "name": "stripZerosLeft",
      "kind": "FunctionDeclaration",
      "signature": "export function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}",
      "doc": "Return the [[DataHexString]] result by stripping all **leading**\n* zero bytes from %%data%%.",
      "tags": []
    },
    {
      "name": "zeroPadBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}",
      "doc": "Return the [[DataHexString]] of %%data%% padded on the **right**\nto %%length%% bytes.\n\nIf %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\nthrown.\n\nThis pads data the same as **bytes** are in Solidity\n(e.g. ``bytes16``).",
      "tags": []
    },
    {
      "name": "zeroPadValue",
      "kind": "FunctionDeclaration",
      "signature": "export function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}",
      "doc": "Return the [[DataHexString]] of %%data%% padded on the **left**\nto %%length%% bytes.\n\nIf %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\nthrown.\n\nThis pads data the same as **values** are in Solidity\n(e.g. ``uint128``).",
      "tags": []
    },
    {
      "name": "defineProperties",
      "kind": "FunctionDeclaration",
      "signature": "export function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n",
      "doc": "Assigns the %%values%% to %%target%% as read-only values.\n\nIt %%types%% is specified, the values are checked.",
      "tags": []
    },
    {
      "name": "resolveProperties",
      "kind": "FunctionDeclaration",
      "signature": "export async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        ac",
      "doc": "Resolves to a new object that is a copy of %%value%%, but with all\nvalues resolved.",
      "tags": []
    },
    {
      "name": "resolveProperties.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "assert",
      "kind": "FunctionDeclaration",
      "signature": "export function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}",
      "doc": "Throws an EthersError with %%message%%, %%code%% and additional error\n%%info%% when %%check%% is falsish..",
      "tags": [
        {
          "tagName": "see",
          "text": "[[api:makeError]]"
        }
      ]
    },
    {
      "name": "assertArgument",
      "kind": "FunctionDeclaration",
      "signature": "export function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}",
      "doc": "A simple helper to simply ensuring provided arguments match expected\nconstraints, throwing if not.\n\nIn TypeScript environments, the %%check%% has been asserted true, so\nany further code does not need additional compile-time checks.",
      "tags": []
    },
    {
      "name": "assertArgumentCount",
      "kind": "FunctionDeclaration",
      "signature": "export function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n",
      "doc": "",
      "tags": []
    },
    {
      "name": "assertNormalize",
      "kind": "FunctionDeclaration",
      "signature": "export function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}",
      "doc": "Throws if the normalization %%form%% is not supported.",
      "tags": []
    },
    {
      "name": "assertPrivate",
      "kind": "FunctionDeclaration",
      "signature": "export function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + ",
      "doc": "Many classes use file-scoped values to guard the constructor,\nmaking it effectively private. This facilitates that pattern\nby ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\nthrowing if not, indicating the %%className%% if provided.",
      "tags": []
    },
    {
      "name": "makeError",
      "kind": "FunctionDeclaration",
      "signature": "export function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    let shortMessage = message;\n\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in inf",
      "doc": "Returns a new Error configured to the format ethers emits errors, with\nthe %%message%%, [[api:ErrorCode]] %%code%% and additional properties\nfor the corresponding EthersError.\n\nEach error in ethers includes the version of ethers, a\nmachine-readable [[ErrorCode]], and depending on %%code%%, additional\nrequired properties. The error message will also include the %%message%%,\nethers version, %%code%% and all additional properties, serialized.",
      "tags": []
    },
    {
      "name": "makeError.code",
      "kind": "PropertySignature",
      "signature": "code: ErrorCode;",
      "doc": "The string error code.",
      "tags": []
    },
    {
      "name": "makeError.shortMessage",
      "kind": "PropertySignature",
      "signature": "shortMessage: string;",
      "doc": "A short message describing the error, with minimal additional\ndetails.",
      "tags": []
    },
    {
      "name": "makeError.info",
      "kind": "PropertySignature",
      "signature": "info?: Record<string, any>;",
      "doc": "Additional info regarding the error that may be useful.\n\nThis is generally helpful mostly for human-based debugging.",
      "tags": []
    },
    {
      "name": "makeError.error",
      "kind": "PropertySignature",
      "signature": "error?: Error;",
      "doc": "Any related error.",
      "tags": []
    },
    {
      "name": "makeError.name",
      "kind": "PropertySignature",
      "signature": "name:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeError.message",
      "kind": "PropertySignature",
      "signature": "message:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeError.stack",
      "kind": "PropertySignature",
      "signature": "stack?:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isCallException",
      "kind": "FunctionDeclaration",
      "signature": "export function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}",
      "doc": "Returns true if %%error%% is a [[CallExceptionError].",
      "tags": []
    },
    {
      "name": "isError",
      "kind": "FunctionDeclaration",
      "signature": "export function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}",
      "doc": "Returns true if the %%error%% matches an error thrown by ethers\nthat matches the error %%code%%.\n\nIn TypeScript environments, this can be used to check that %%error%%\nmatches an EthersError type, which means the expected properties will\nbe set.",
      "tags": [
        {
          "tagName": "See",
          "text": "[ErrorCodes](api:ErrorCode)"
        },
        {
          "tagName": "example",
          "text": "  try {\n    // code....\n  } catch (e) {\n    if (isError(e, \"CALL_EXCEPTION\")) {\n        // The Type Guard has validated this object\n        console.log(e.data);\n    }\n  }"
        }
      ]
    },
    {
      "name": "EventPayload",
      "kind": "ClassDeclaration",
      "signature": "export class EventPayload<T> {\n    /**\n     *  The event filter.\n     */\n    readonly filter!: T;\n\n    /**\n     *  The **EventEmitterable**.\n     */\n    readonly emitter!: EventEmitterable<T>;\n\n    readonly #listener: null | Listener;\n\n    /**\n     *  Create a new **EventPayload** for %%emitter%% wi",
      "doc": "When an [[EventEmitterable]] triggers a [[Listener]], the\ncallback always ahas one additional argument passed, which is\nan **EventPayload**.",
      "tags": []
    },
    {
      "name": "FetchRequest",
      "kind": "ClassDeclaration",
      "signature": "export class FetchRequest implements Iterable<[ key: string, value: string ]> {\n    #allowInsecure: boolean;\n    #gzip: boolean;\n    #headers: Record<string, string>;\n    #method: string;\n    #timeout: number;\n    #url: string;\n\n    #body?: Uint8Array;\n    #bodyType?: string;\n    #creds?: string;\n\n ",
      "doc": "Represents a request for a resource using a URI.\n\nBy default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\nand ``IPFS:``.\n\nAdditional schemes can be added globally using [[registerGateway]].",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nreq = new FetchRequest(\"https://www.ricmoo.com\")\nresp = await req.send()\nresp.body.length\n//_result:"
        }
      ]
    },
    {
      "name": "FetchResponse",
      "kind": "ClassDeclaration",
      "signature": "export class FetchResponse implements Iterable<[ key: string, value: string ]> {\n    #statusCode: number;\n    #statusMessage: string;\n    #headers: Record<string, string>;\n    #body: null | Readonly<Uint8Array>;\n    #request: null | FetchRequest;\n\n    #error: { error?: Error, message: string };\n\n   ",
      "doc": "The response for a FetchRequest.",
      "tags": []
    },
    {
      "name": "FetchCancelSignal",
      "kind": "ClassDeclaration",
      "signature": "export class FetchCancelSignal {\n    #listeners: Array<() => void>;\n    #cancelled: boolean;\n\n    constructor(request: FetchRequest) {\n        this.#listeners = [ ];\n        this.#cancelled = false;\n\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) { return; }\n            t",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "FixedNumber",
      "kind": "ClassDeclaration",
      "signature": "export class FixedNumber {\n\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    readonly format!: string;\n\n    readonly #format: _FixedFormat;\n\n    // The actual value (accounting for decimals)\n    #val: bigint;\n\n    // A base-10 value to multiple values by to maint",
      "doc": "A FixedNumber represents a value over its [[FixedFormat]]\narithmetic field.\n\nA FixedNumber can be used to perform math, losslessly, on\nvalues which have decmial places.\n\nA FixedNumber has a fixed bit-width to store values in, and stores all\nvalues internally by multiplying the value by 10 raised to the power of\n%%decimals%%.\n\nIf operations are performed that cause a value to grow too high (close to\npositive infinity) or too low (close to negative infinity), the value\nis said to //overflow//.\n\nFor example, an 8-bit signed value, with 0 decimals may only be within\nthe range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n\nMany operation have a normal and //unsafe// variant. The normal variant\nwill throw a [[NumericFaultError]] on any overflow, while the //unsafe//\nvariant will silently allow overflow, corrupting its value value.\n\nIf operations are performed that cause a value to become too small\n(close to zero), the value loses precison and is said to //underflow//.\n\nFor example, a value with 1 decimal place may store a number as small\nas ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\ninto 1 decimal place, so underflow occurs which means precision is lost\nand the value becomes ``0``.\n\nSome operations have a normal and //signalling// variant. The normal\nvariant will silently ignore underflow, while the //signalling// variant\nwill thow a [[NumericFaultError]] on underflow.",
      "tags": []
    },
    {
      "name": "getBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && ",
      "doc": "Gets a BigInt from %%value%%. If it is an invalid value for\na BigInt, then an ArgumentError will be thrown for %%name%%.",
      "tags": []
    },
    {
      "name": "getNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            as",
      "doc": "Gets a //number// from %%value%%. If it is an invalid value for\na //number//, then an ArgumentError will be thrown for %%name%%.",
      "tags": []
    },
    {
      "name": "getUint",
      "kind": "FunctionDeclaration",
      "signature": "export function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}",
      "doc": "Returns %%value%% as a bigint, validating it is valid as a bigint\nvalue and that it is positive.",
      "tags": []
    },
    {
      "name": "toBeArray",
      "kind": "FunctionDeclaration",
      "signature": "export function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    f",
      "doc": "Converts %%value%% to a Big Endian Uint8Array.",
      "tags": []
    },
    {
      "name": "toBeArray.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeHex",
      "kind": "FunctionDeclaration",
      "signature": "export function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n",
      "doc": "Converts %%value%% to a Big Endian hexstring, optionally padded to\n%%width%% bytes.",
      "tags": []
    },
    {
      "name": "toNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}",
      "doc": "Converts %%value%% to a number. If %%value%% is a Uint8Array, it\nis treated as Big Endian data. Throws if the value is not safe.",
      "tags": []
    },
    {
      "name": "toQuantity",
      "kind": "FunctionDeclaration",
      "signature": "export function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}",
      "doc": "Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n\nA //Quantity// does not have and leading 0 values unless the value is\nthe literal value `0x0`. This is most commonly used for JSSON-RPC\nnumeric values.",
      "tags": []
    },
    {
      "name": "fromTwos",
      "kind": "FunctionDeclaration",
      "signature": "export function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _",
      "doc": "Convert %%value%% from a twos-compliment representation of %%width%%\nbits to its value.\n\nIf the highest bit is ``1``, the result will be negative.",
      "tags": []
    },
    {
      "name": "toTwos",
      "kind": "FunctionDeclaration",
      "signature": "export function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too ",
      "doc": "Convert %%value%% to a twos-compliment representation of\n%%width%% bits.\n\nThe result will always be positive.",
      "tags": []
    },
    {
      "name": "mask",
      "kind": "FunctionDeclaration",
      "signature": "export function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}",
      "doc": "Mask %%value%% with a bitmask of %%bits%% ones.",
      "tags": []
    },
    {
      "name": "formatEther",
      "kind": "FunctionDeclaration",
      "signature": "export function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}",
      "doc": "Converts %%value%% into a //decimal string// using 18 decimal places.",
      "tags": []
    },
    {
      "name": "parseEther",
      "kind": "FunctionDeclaration",
      "signature": "export function parseEther(ether: string): bigint {\n    return parseUnits(ether, 18);\n}",
      "doc": "Converts the //decimal string// %%ether%% to a BigInt, using 18\ndecimal places.",
      "tags": []
    },
    {
      "name": "formatUnits",
      "kind": "FunctionDeclaration",
      "signature": "export function formatUnits(value: BigNumberish, unit?: string | Numeric): string {\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (un",
      "doc": "Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\nplaces. The %%unit%% may be the number of decimal places or the name of\na unit (e.g. ``\"gwei\"`` for 9 decimal places).",
      "tags": []
    },
    {
      "name": "parseUnits",
      "kind": "FunctionDeclaration",
      "signature": "export function parseUnits(value: string, unit?: string | Numeric): bigint {\n    assertArgument(typeof(value) === \"string\", \"value must be a string\", \"value\", value);\n\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index ",
      "doc": "Converts the //decimal string// %%value%% to a BigInt, assuming\n%%unit%% decimal places. The %%unit%% may the number of decimal places\nor the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).",
      "tags": []
    },
    {
      "name": "toUtf8Bytes",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array {\n    assertArgument(typeof(str) === \"string\", \"invalid string value\", \"str\", str);\n\n    if (form != null) {\n        assertNormalize(form);\n        str = str.normalize(form);\n    }\n\n    let result: Array<number> = ",
      "doc": "Returns the UTF-8 byte representation of %%str%%.\n\nIf %%form%% is specified, the string is normalized.",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8CodePoints(str: string, form?: UnicodeNormalizationForm): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}",
      "doc": "Returns the UTF-8 code-points for %%str%%.\n\nIf %%form%% is specified, the string is normalized.",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toUtf8String",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}",
      "doc": "Returns the string represented by the UTF-8 data %%bytes%%.\n\nWhen %%onError%% function is specified, it is called on UTF-8\nerrors allowing recovery using the [[Utf8ErrorFunc]] API.\n(default: [error](Utf8ErrorFuncs))",
      "tags": []
    },
    {
      "name": "Utf8ErrorFuncs",
      "kind": "VariableDeclaration",
      "signature": "Utf8ErrorFuncs: Readonly<Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>> = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeRlp(_data: BytesLike): RlpStructuredData {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}",
      "doc": "Decodes %%data%% into the structured data it represents.",
      "tags": []
    },
    {
      "name": "encodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeRlp(object: RlpStructuredDataish): string {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}",
      "doc": "Encodes %%object%% as an RLP-encoded [[DataHexString]].",
      "tags": []
    },
    {
      "name": "uuidV4",
      "kind": "FunctionDeclaration",
      "signature": "export function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - cloc",
      "doc": "Returns the version 4 [[link-uuid]] for the %%randomBytes%%.",
      "tags": [
        {
          "tagName": "see",
          "text": ": https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)"
        }
      ]
    },
    {
      "name": "Mnemonic",
      "kind": "ClassDeclaration",
      "signature": "export class Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    readonly phrase!: string;\n\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     * ",
      "doc": "A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\nseeds and convert between phrases and entropy.",
      "tags": []
    },
    {
      "name": "BaseWallet",
      "kind": "ClassDeclaration",
      "signature": "export class BaseWallet extends AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    readonly address!: string;\n\n    readonly #signingKey: SigningKey;\n\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%",
      "doc": "The **BaseWallet** is a stream-lined implementation of a\n[[Signer]] that operates with a private key.\n\nIt is preferred to use the [[Wallet]] class, as it offers\nadditional functionality and simplifies loading a variety\nof JSON formats, Mnemonic Phrases, etc.\n\nThis class may be of use for those attempting to implement\na minimal Signer.",
      "tags": []
    },
    {
      "name": "HDNodeWallet",
      "kind": "ClassDeclaration",
      "signature": "export class HDNodeWallet extends BaseWallet {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with ",
      "doc": "An **HDNodeWallet** is a [[Signer]] backed by the private key derived\nfrom an HD Node using the [[link-bip-32]] stantard.\n\nAn HD Node forms a hierarchal structure with each HD Node having a\nprivate key and the ability to derive child HD Nodes, defined by\na path indicating the index of each child.",
      "tags": []
    },
    {
      "name": "HDNodeVoidWallet",
      "kind": "ClassDeclaration",
      "signature": "export class HDNodeVoidWallet extends VoidSigner {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal w",
      "doc": "A **HDNodeVoidWallet** cannot sign, but provides access to\nthe children nodes of a [[link-bip-32]] HD wallet addresses.\n\nThe can be created by using an extended ``xpub`` key to\n[[HDNodeWallet_fromExtendedKey]] or by \n[nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].",
      "tags": []
    },
    {
      "name": "Wallet",
      "kind": "ClassDeclaration",
      "signature": "export class Wallet extends BaseWallet {\n\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */\n    constructor(key: string | SigningKey, provider?: null | Provider) {\n        if (typeof(key) === \"string\" && !key.startsWith(\"0x\")) {\n      ",
      "doc": "A **Wallet** manages a single private key which is used to sign\ntransactions, messages and other common payloads.\n\nThis class is generally the main entry point for developers\nthat wish to use a private key directly, as it can create\ninstances from a large variety of common sources, including\nraw private key, [[link-bip-39]] mnemonics and encrypte JSON\nwallets.",
      "tags": []
    },
    {
      "name": "defaultPath",
      "kind": "VariableDeclaration",
      "signature": "defaultPath: string = \"m/44'/60'/0'/0/0\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAccountPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${ index }'/0/0`;\n}",
      "doc": "Returns the [[link-bip-32]] path for the account at %%index%%.\n\nThis is the pattern used by wallets like Ledger.\n\nThere is also an [alternate pattern](getIndexedAccountPath) used by\nsome software.",
      "tags": []
    },
    {
      "name": "getIndexedAccountPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getIndexedAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${ index}`;\n}",
      "doc": "Returns the path using an alternative pattern for deriving accounts,\nat %%index%%.\n\nThis derivation path uses the //index// component rather than the\n//account// component to derive sequential accounts.\n\nThis is the pattern used by wallets like MetaMask.",
      "tags": []
    },
    {
      "name": "isCrowdsaleJson",
      "kind": "FunctionDeclaration",
      "signature": "export function isCrowdsaleJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) { return true; }\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%json%% is a valid JSON Crowdsale wallet.",
      "tags": []
    },
    {
      "name": "isKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export function isKeystoreJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version): 0);\n        if (version === 3) { return true; }\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%json%% is a valid JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "decryptCrowdsaleJson",
      "kind": "FunctionDeclaration",
      "signature": "export function decryptCrowdsaleJson(json: string, _password: string | Uint8Array): CrowdsaleAccount {\n    const data = JSON.parse(json);\n    const password = getPassword(_password);\n\n    // Ethereum Address\n    const address = getAddress(spelunk(data, \"ethaddr:string!\"));\n\n    // Encrypted Seed\n   ",
      "doc": "Before Ethereum launched, it was necessary to create a wallet\nformat for backers to use, which would be used to receive ether\nas a reward for contributing to the project.\n\nThe [[link-crowdsale]] format is now obsolete, but it is still\nuseful to support and the additional code is fairly trivial as\nall the primitives required are used through core portions of\nthe library.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJsonSync",
      "kind": "FunctionDeclaration",
      "signature": "export function decryptKeystoreJsonSync(json: string, _password: string | Uint8Array): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dk",
      "doc": "Returns the account details for the JSON Keystore Wallet %%json%%\nusing %%password%%.\n\nIt is preferred to use the [async version](decryptKeystoreJson)\ninstead, which allows a [[ProgressCallback]] to keep the user informed\nas to the decryption status.\n\nThis method will block the event loop (freezing all UI) until decryption\nis complete, which can take quite some time, depending on the wallet\nparamters and platform.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function decryptKeystoreJson(json: string, _password: string | Uint8Array, progress?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pb",
      "doc": "Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n%%password%%.\n\nIf provided, %%progress%% will be called periodically during the\ndecrpytion to provide feedback, and if the function returns\n``false`` will halt decryption.\n\nThe %%progressCallback%% will **always** receive ``0`` before\ndecryption begins and ``1`` when complete.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function encryptKeystoreJson(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): Promise<string> {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = ",
      "doc": "Resolved to the JSON Keystore Wallet for %%account%% encrypted\nwith %%password%%.\n\nThe %%options%% can be used to tune the password-based key\nderivation function parameters, explicitly set the random values\nused and provide a [[ProgressCallback]] to receive periodic updates\non the completion status..",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJsonSync",
      "kind": "FunctionDeclaration",
      "signature": "export function encryptKeystoreJsonSync(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): string {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = scryptSync(",
      "doc": "Return the JSON Keystore Wallet for %%account%% encrypted with\n%%password%%.\n\nThe %%options%% can be used to tune the password-based key\nderivation function parameters, explicitly set the random values\nused. Any provided [[ProgressCallback]] is ignord.",
      "tags": []
    },
    {
      "name": "Wordlist",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Wordlist {\n    locale!: string;\n\n    /**\n     *  Creates a new Wordlist instance.\n     *\n     *  Sub-classes MUST call this if they provide their own constructor,\n     *  passing in the locale string of the language.\n     *\n     *  Generally there is no need to create instances",
      "doc": "A Wordlist represents a collection of language-specific\nwords used to encode and devoce [[link-bip-39]] encoded data\nby mapping words to 11-bit values and vice versa.",
      "tags": []
    },
    {
      "name": "LangEn",
      "kind": "ClassDeclaration",
      "signature": "export class LangEn extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the English language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEn]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"en\", words, ch",
      "doc": "The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "WordlistOwl",
      "kind": "ClassDeclaration",
      "signature": "export class WordlistOwl extends Wordlist {\n    #data: string;\n    #checksum: string;\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, checksum: string) {\n        super(",
      "doc": "An OWL format Wordlist is an encoding method that exploits\nthe general locality of alphabetically sorted words to\nachieve a simple but effective means of compression.\n\nThis class is generally not useful to most developers as\nit is used mainly internally to keep Wordlists for languages\nbased on ASCII-7 small.\n\nIf necessary, there are tools within the ``generation/`` folder\nto create the necessary data.",
      "tags": []
    },
    {
      "name": "WordlistOwlA",
      "kind": "ClassDeclaration",
      "signature": "export class WordlistOwlA extends WordlistOwl {\n    #accent: string;\n\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%\n     *  and %%accent%% data and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, accent: string, checksum: str",
      "doc": "An OWL-A format Wordlist extends the OWL format to add an\noverlay onto an OWL format Wordlist to support diacritic\nmarks.\n\nThis class is generally not useful to most developers as\nit is used mainly internally to keep Wordlists for languages\nbased on latin-1 small.\n\nIf necessary, there are tools within the ``generation/`` folder\nto create the necessary data.",
      "tags": []
    },
    {
      "name": "wordlists",
      "kind": "VariableDeclaration",
      "signature": "wordlists: Record<string, Wordlist> = {\n  cz: LangCz.wordlist(),\n  en: LangEn.wordlist(),\n  es: LangEs.wordlist(),\n  fr: LangFr.wordlist(),\n  it: LangIt.wordlist(),\n  pt: LangPt.wordlist(),\n  ja: LangJa.wordlist(),\n  ko: LangKo.wordlist(),\n  zh_cn: LangZh.wordlist(\"cn\"),\n  zh_tw: LangZh.wordlist(\"tw",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonFragment",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonFragment {\n    /**\n     *  The name of the error, event, function, etc.\n     */\n    readonly name?: string;\n\n    /**\n     *  The type of the fragment (e.g. ``event``, ``\"function\"``, etc.)\n     */\n    readonly type?: string;\n\n    /**\n     *  If the event is anonymous.\n     */\n  ",
      "doc": "A fragment for a method, event or error in a [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "JsonFragmentType",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonFragmentType {\n    /**\n     *  The parameter name.\n     */\n    readonly name?: string;\n\n    /**\n     *  If the parameter is indexed.\n     */\n    readonly indexed?: boolean;\n\n    /**\n     *  The type of the parameter.\n     */\n    readonly type?: string;\n\n    /**\n     *  The inter",
      "doc": "A Type description in a [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "FormatType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FormatType = \"sighash\" | \"minimal\" | \"full\" | \"json\";",
      "doc": "The format to serialize the output as.\n\n**``\"sighash\"``** - the bare formatting, used to compute the selector\nor topic hash; this format cannot be reversed (as it discards ``indexed``)\nso cannot by used to export an [[Interface]].\n\n**``\"minimal\"``** - Human-Readable ABI with minimal spacing and without\nnames, so it is compact, but will result in Result objects that cannot\nbe accessed by name.\n\n**``\"full\"``** - Full Human-Readable ABI, with readable spacing and names\nintact; this is generally the recommended format.\n\n**``\"json\"``** - The [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "FragmentType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FragmentType = \"constructor\" | \"error\" | \"event\" | \"fallback\" | \"function\" | \"struct\";",
      "doc": "The type of a [[Fragment]].",
      "tags": []
    },
    {
      "name": "InterfaceAbi",
      "kind": "TypeAliasDeclaration",
      "signature": "export type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;",
      "doc": "An **InterfaceAbi** may be any supported ABI format.\n\nA string is expected to be a JSON string, which will be parsed\nusing ``JSON.parse``. This means that the value **must** be a valid\nJSON string, with no stray commas, etc.\n\nAn array may contain any combination of:\n- Human-Readable fragments\n- Parsed JSON fragment\n- [[Fragment]] instances\n\nA **Human-Readable Fragment** is a string which resembles a Solidity\nsignature and is introduced in [this blog entry](link-ricmoo-humanreadableabi).\nFor example, ``function balanceOf(address) view returns (uint)``.\n\nA **Parsed JSON Fragment** is a JavaScript Object desribed in the\n[Solidity documentation](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "ParamTypeWalkFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ParamTypeWalkFunc = (type: string, value: any) => any;",
      "doc": "When [walking](ParamType-walk) a [[ParamType]], this is called\non each component.",
      "tags": []
    },
    {
      "name": "ParamTypeWalkAsyncFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ParamTypeWalkAsyncFunc = (type: string, value: any) => any | Promise<any>;",
      "doc": "When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],\nthis is called on each component.",
      "tags": []
    },
    {
      "name": "Addressable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Addressable {\n    /**\n     *  Get the object address.\n     */\n    getAddress(): Promise<string>;\n}",
      "doc": "An interface for objects which have an address, and can\nresolve it asyncronously.\n\nThis allows objects such as [[Signer]] or [[Contract]] to\nbe used most places an address can be, for example getting\nthe [balance](Provider-getBalance).",
      "tags": []
    },
    {
      "name": "AddressLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AddressLike = string | Promise<string> | Addressable;",
      "doc": "Anything that can be used to return or resolve an address.",
      "tags": []
    },
    {
      "name": "NameResolver",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NameResolver {\n    /**\n     *  Resolve to the address for the ENS %%name%%.\n     *\n     *  Resolves to ``null`` if the name is unconfigued. Use\n     *  [[resolveAddress]] (passing this object as %%resolver%%) to\n     *  throw for names that are unconfigured.\n     */\n    resolveName(",
      "doc": "An interface for any object which can resolve an ENS name.",
      "tags": []
    },
    {
      "name": "ConstantContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConstantContractMethod<\n    A extends Array<any>,\n    R = any\n> extends ContractMethod<A, R, R> { }",
      "doc": "A pure of view method on a Contract.",
      "tags": []
    },
    {
      "name": "ContractEvent",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractEvent<A extends Array<any> = Array<any>> {\n    (...args: ContractEventArgs<A>): DeferredTopicFilter;\n\n    /**\n     *  The name of the Contract event.\n     */\n    name: string;\n\n    /**\n     *  The fragment of the Contract event. This will throw on ambiguous\n     *  method na",
      "doc": "",
      "tags": []
    },
    {
      "name": "ContractEventArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractEventArgs<A extends Array<any>> = { [ I in keyof A ]?: A[I] | Typed | null };",
      "doc": "Each argument of an event is nullable (to indicate matching //any//.",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractEventName",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractEventName = string | ContractEvent | TopicFilter | DeferredTopicFilter;",
      "doc": "The name for an event used for subscribing to Contract events.\n\n**``string``** - An event by name. The event must be non-ambiguous.\nThe parameters will be dereferenced when passed into the listener.\n\n[[ContractEvent]] - A filter from the ``contract.filters``, which will\npass only the EventPayload as a single parameter, which includes a\n``.signature`` property that can be used to further filter the event.\n\n[[TopicFilter]] - A filter defined using the standard Ethereum API\nwhich provides the specific topic hash or topic hashes to watch for along\nwith any additional values to filter by. This will only pass a single\nparameter to the listener, the EventPayload which will include additional\ndetails to refine by, such as the event name and signature.\n\n[[DeferredTopicFilter]] - A filter created by calling a [[ContractEvent]]\nwith parameters, which will create a filter for a specific event\nsignature and dereference each parameter when calling the listener.",
      "tags": []
    },
    {
      "name": "ContractInterface",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractInterface {\n    [ name: string ]: BaseContractMethod;\n}",
      "doc": "A Contract with no method constraints.",
      "tags": []
    },
    {
      "name": "ContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractMethod<\n    A extends Array<any> = Array<any>,\n    R = any,\n    D extends R | ContractTransactionResponse = R | ContractTransactionResponse\n> extends BaseContractMethod<A, R, D> { }",
      "doc": "A contract method on a Contract.",
      "tags": []
    },
    {
      "name": "ContractMethodArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractMethodArgs<A extends Array<any>> = PostfixOverrides<{ [ I in keyof A ]-?: A[I] | Typed }>;",
      "doc": "Arguments to a Contract method can always include an additional and\noptional overrides parameter, and each parameter can optionally be\n[[Typed]].",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractTransaction extends PreparedTransactionRequest {\n    /**\n     *  The target address.\n     */\n    to: string;\n\n    /**\n     *  The transaction data.\n     */\n    data: string;\n\n    /**\n     *  The from address, if any.\n     */\n    from?: string;\n}",
      "doc": "When populating a transaction this type is returned.",
      "tags": []
    },
    {
      "name": "DeferredTopicFilter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DeferredTopicFilter {\n    getTopicFilter(): Promise<TopicFilter>;\n    fragment: EventFragment;\n}",
      "doc": "When creating a filter using the ``contract.filters``, this is returned.",
      "tags": []
    },
    {
      "name": "Overrides",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Overrides extends Omit<TransactionRequest, \"to\" | \"data\"> { }",
      "doc": "The overrides for a contract transaction.",
      "tags": []
    },
    {
      "name": "BaseContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BaseContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {\n    (...args: ContractMethodArgs<A>): Promise<D>;\n\n    /**\n     *  The name of the Contract method.\n     */\n    name: string;\n\n    /**\n     *",
      "doc": "A Contract method can be called directly, or used in various ways.",
      "tags": []
    },
    {
      "name": "ContractDeployTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractDeployTransaction extends Omit<ContractTransaction, \"to\"> { }",
      "doc": "A deployment transaction for a contract.",
      "tags": []
    },
    {
      "name": "PostfixOverrides",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PostfixOverrides<A extends Array<any>> = A | [ ...A, Overrides ];",
      "doc": "Arguments to a Contract method can always include an additional and\noptional overrides parameter.",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "WrappedFallback",
      "kind": "InterfaceDeclaration",
      "signature": "export interface WrappedFallback {\n    (overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse>;\n\n    /**\n     *  Returns a populated transaction that can be used to perform the\n     *  fallback method.\n     *\n     *  For non-receive fallback, ``data`` may be overridden.\n  ",
      "doc": "A Fallback or Receive function on a Contract.",
      "tags": []
    },
    {
      "name": "ProgressCallback",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProgressCallback = (percent: number) => void;",
      "doc": "A callback during long-running operations to update any\nUI or provide programatic access to the progress.\n\nThe %%percent%% is a value between ``0`` and ``1``.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        }
      ]
    },
    {
      "name": "SignatureLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type SignatureLike = Signature | string | {\n    r: string;\n    s: string;\n    v: BigNumberish;\n    yParity?: 0 | 1;\n    yParityAndS?: string;\n} | {\n    r: string;\n    yParityAndS: string;\n    yParity?: 0 | 1;\n    s?: string;\n    v?: number;\n} | {\n    r: string;\n    s: string;\n    yParity: 0 |",
      "doc": "A SignatureLike",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Signing"
        }
      ]
    },
    {
      "name": "AuthorizationRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AuthorizationRequest {\n    address: string | Addressable;\n    nonce?: Numeric;\n    chainId?: BigNumberish;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "TypedDataDomain",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedDataDomain {\n    /**\n     *  The human-readable name of the signing domain.\n     */\n    name?: null | string;\n\n    /**\n     *  The major version of the signing domain.\n     */\n    version?: null | string;\n\n    /**\n     *  The chain ID of the signing domain.\n     */\n    chainId?",
      "doc": "The domain for an [[link-eip-712]] payload.",
      "tags": []
    },
    {
      "name": "TypedDataField",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedDataField {\n    /**\n     *  The field name.\n     */\n    name: string;\n\n    /**\n     *  The type of the field.\n     */\n    type: string;\n}",
      "doc": "A specific field of a structured [[link-eip-712]] type.",
      "tags": []
    },
    {
      "name": "Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Provider extends ContractRunner, EventEmitterable<ProviderEvent>, NameResolver {\n\n    /**\n     *  The provider iteself.\n     *\n     *  This is part of the necessary API for executing a contract, as\n     *  it provides a common property on any [[ContractRunner]] that\n     *  can be u",
      "doc": "A **Provider** is the primary method to interact with the read-only\ncontent on Ethereum.\n\nIt allows access to details about accounts, blocks and transactions\nand the ability to query event logs and simulate contract execution.\n\nAccount data includes the [balance](getBalance),\n[transaction count](getTransactionCount), [code](getCode) and\n[state trie storage](getStorage).\n\nSimulating execution can be used to [call](call),\n[estimate gas](estimateGas) and\n[get transaction results](getTransactionResult).\n\nThe [[broadcastTransaction]] is the only method which allows updating\nthe blockchain, but it is usually accessed by a [[Signer]], since a\nprivate key must be used to sign the transaction before it can be\nbroadcast.",
      "tags": []
    },
    {
      "name": "Signer",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Signer extends Addressable, ContractRunner, NameResolver {\n\n    /**\n     *  The [[Provider]] attached to this Signer (if any).\n     */\n    provider: null | Provider;\n\n    /**\n     *  Returns a new instance of this Signer connected to //provider// or detached\n     *  from any Provide",
      "doc": "A Signer represents an account on the Ethereum Blockchain, and is most often\nbacked by a private key represented by a mnemonic or residing on a Hardware Wallet.\n\nThe API remains abstract though, so that it can deal with more advanced exotic\nSigning entities, such as Smart Contract Wallets or Virtual Wallets (where the\nprivate key may not be known).",
      "tags": []
    },
    {
      "name": "CommunityResourcable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CommunityResourcable {\n    /**\n     *  Returns true if the instance is connected using the community\n     *  credentials.\n     */\n    isCommunityResource(): boolean;\n}",
      "doc": "There are many awesome community services that provide Ethereum\nnodes both for developers just starting out and for large-scale\ncommunities.\nProviders which offer community credentials should extend this\nto notify any interested consumers whether community credentials\nare in-use.",
      "tags": [
        {
          "tagName": "_section",
          "text": ": api/providers/thirdparty: Community Providers  [thirdparty]"
        }
      ]
    },
    {
      "name": "AbstractProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AbstractProviderOptions = {\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};",
      "doc": "Options for configuring some internal aspects of an [[AbstractProvider]].\n\n**``cacheTimeout``** - how long to cache a low-level ``_perform``\nfor, based on input parameters. This reduces the number of calls\nto getChainId and getBlockNumber, but may break test chains which\ncan perform operations (internally) synchronously. Use ``-1`` to\ndisable, ``0`` will only buffer within the same event loop and\nany other value is in ms. (default: ``250``)",
      "tags": []
    },
    {
      "name": "BrowserProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BrowserProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n\n    providerInfo?: Eip6963ProviderInfo;\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "FallbackProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FallbackProviderOptions = {\n    // How many providers must agree on a value before reporting\n    // back the response\n    quorum?: number;\n\n    // How many providers must have reported the same event\n    // for it to be emitted (currently unimplmented)\n    eventQuorum?: number;\n\n    // H",
      "doc": "Additional options to configure a [[FallbackProvider]].",
      "tags": []
    },
    {
      "name": "AbstractProviderPlugin",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AbstractProviderPlugin {\n    /**\n     *  The reverse domain notation of the plugin.\n     */\n    readonly name: string;\n\n    /**\n     *  Creates a new instance of the plugin, connected to %%provider%%.\n     */\n    connect(provider: AbstractProvider): AbstractProviderPlugin;\n}",
      "doc": "An **AbstractPlugin** is used to provide additional internal services\nto an [[AbstractProvider]] without adding backwards-incompatible changes\nto method signatures or other internal and complex logic.",
      "tags": []
    },
    {
      "name": "BlockParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BlockParams {\n    /**\n     *  The block hash.\n     */\n    hash?: null | string;\n\n    /**\n     *  The block number.\n     */\n    number: number;\n\n    /**\n     *  The timestamp for this block, which is the number of seconds\n     *  since epoch that this block was included.\n     */\n    ",
      "doc": "a **BlockParams** encodes the minimal required properties for a\nformatted block.",
      "tags": []
    },
    {
      "name": "BlockTag",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BlockTag = BigNumberish | string;",
      "doc": "A **BlockTag** specifies a specific block.\n\n**numeric value** - specifies the block height, where\nthe genesis block is block 0; many operations accept a negative\nvalue which indicates the block number should be deducted from\nthe most recent block. A numeric value may be a ``number``, ``bigint``,\nor a decimal of hex string.\n\n**blockhash** - specifies a specific block by its blockhash; this allows\npotentially orphaned blocks to be specifed, without ambiguity, but many\nbackends do not support this for some operations.",
      "tags": []
    },
    {
      "name": "BrowserDiscoverOptions",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BrowserDiscoverOptions {\n    /**\n     *  Override provider detection with this provider.\n     */\n    provider?: Eip1193Provider;\n\n    /**\n     *  Duration to wait to detect providers. (default: 300ms)\n     */\n    timeout?: number;\n\n    /**\n     *  Return the first detected provider.",
      "doc": "Specifies how [[link-eip-6963]] discovery should proceed.\n\nSee: [[BrowserProvider-discover]]",
      "tags": []
    },
    {
      "name": "ContractRunner",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractRunner {\n    /**\n     *  The provider used for necessary state querying operations.\n     *\n     *  This can also point to the **ContractRunner** itself, in the\n     *  case of an [[AbstractProvider]].\n     */\n    provider: null | Provider;\n\n    /**\n     *  Required to estima",
      "doc": "A **ContractRunner** is a generic interface which defines an object\ncapable of interacting with a Contract on the network.\n\nThe more operations supported, the more utility it is capable of.\n\nThe most common ContractRunners are [Providers](Provider) which enable\nread-only access and [Signers](Signer) which enable write-access.",
      "tags": []
    },
    {
      "name": "DebugEventBrowserProvider",
      "kind": "TypeAliasDeclaration",
      "signature": "export type DebugEventBrowserProvider = {\n    action: \"sendEip1193Payload\",\n    payload: { method: string, params: Array<any> }\n} | {\n    action: \"receiveEip1193Result\",\n    result: any\n} | {\n    action: \"receiveEip1193Error\",\n    error: Error\n};",
      "doc": "The possible additional events dispatched when using the ``\"debug\"``\nevent on a [[BrowserProvider]].",
      "tags": []
    },
    {
      "name": "Eip1193Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Eip1193Provider {\n    /**\n     *  See [[link-eip-1193]] for details on this method.\n     */\n    request(request: { method: string, params?: Array<any> | Record<string, any> }): Promise<any>;\n}",
      "doc": "The interface to an [[link-eip-1193]] provider, which is a standard\nused by most injected providers, which the [[BrowserProvider]] accepts\nand exposes the API of.",
      "tags": []
    },
    {
      "name": "Eip6963ProviderInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Eip6963ProviderInfo {\n    uuid: string;\n    name: string;\n    icon: string;\n    rdns: string;\n}",
      "doc": "Provider info provided by the [[link-eip-6963]] discovery mechanism.",
      "tags": []
    },
    {
      "name": "EventFilter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EventFilter {\n    address?: AddressLike | Array<AddressLike>;\n    topics?: TopicFilter;\n}",
      "doc": "An **EventFilter** allows efficiently filtering logs (also known as\nevents) using bloom filters included within blocks.",
      "tags": []
    },
    {
      "name": "Filter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Filter extends EventFilter {\n\n    /**\n     *  The start block for the filter (inclusive).\n     */\n    fromBlock?: BlockTag;\n\n    /**\n     *  The end block for the filter (inclusive).\n     */\n    toBlock?: BlockTag;\n}",
      "doc": "A **Filter** allows searching a specific range of blocks for mathcing\nlogs.",
      "tags": []
    },
    {
      "name": "FilterByBlockHash",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FilterByBlockHash extends EventFilter {\n    /**\n     *  The blockhash of the specific block for the filter.\n     */\n    blockHash?: string;\n}",
      "doc": "A **FilterByBlockHash** allows searching a specific block for mathcing\nlogs.",
      "tags": []
    },
    {
      "name": "GasCostParameters",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GasCostParameters = {\n    /**\n     *  The transactions base fee.\n     */\n    txBase?: number;\n\n    /**\n     *  The fee for creating a new account.\n     */\n    txCreate?: number;\n\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    txDataZero?: number;\n\n    /**\n     *  The fee ",
      "doc": "The gas cost parameters for a [[GasCostPlugin]].",
      "tags": []
    },
    {
      "name": "JsonRpcApiProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcApiProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n    batchStallTime?: number;\n    batchMaxSize?: number;\n    batchMaxCount?: number;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};",
      "doc": "Options for configuring a [[JsonRpcApiProvider]]. Much of this\nis targetted towards sub-classes, which often will not expose\nany of these options to their consumers.\n\n**``polling``** - use the polling strategy is used immediately\nfor events; otherwise, attempt to use filters and fall back onto\npolling (default: ``false``)\n\n**``staticNetwork``** - do not request chain ID on requests to\nvalidate the underlying chain has not changed (default: ``null``)\n\nThis should **ONLY** be used if it is **certain** that the network\ncannot change, such as when using INFURA (since the URL dictates the\nnetwork). If the network is assumed static and it does change, this\ncan have tragic consequences. For example, this **CANNOT** be used\nwith MetaMask, since the user can select a new network from the\ndrop-down at any time.\n\n**``batchStallTime``** - how long (ms) to aggregate requests into a\nsingle batch. ``0`` indicates batching will only encompass the current\nevent loop. If ``batchMaxCount = 1``, this is ignored. (default: ``10``)\n\n**``batchMaxSize``** - target maximum size (bytes) to allow per batch\nrequest (default: 1Mb)\n\n**``batchMaxCount``** - maximum number of requests to allow in a batch.\nIf ``batchMaxCount = 1``, then batching is disabled. (default: ``100``)\n\n**``cacheTimeout``** - passed as [[AbstractProviderOptions]].",
      "tags": []
    },
    {
      "name": "JsonRpcError",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcError = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response error.\n     */\n    error: {\n        code: number;\n        message?: string;\n        data?: any;\n    }\n};",
      "doc": "A JSON-RPC error, which are returned on failure from a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcPayload",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcPayload = {\n    /**\n     *  The JSON-RPC request ID.\n     */\n    id: number;\n\n    /**\n     *  The JSON-RPC request method.\n     */\n    method: string;\n\n    /**\n     *  The JSON-RPC request parameters.\n     */\n    params: Array<any> | Record<string, any>;\n\n    /**\n     *  A require",
      "doc": "A JSON-RPC payload, which are sent to a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcResult",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcResult = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response result.\n     */\n    result: any;\n};",
      "doc": "A JSON-RPC result, which are returned on success from a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcTransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcTransactionRequest {\n     /**\n      *  The sender address to use when signing.\n      */\n     from?: string;\n\n     /**\n      *  The target address.\n      */\n     to?: string;\n\n     /**\n      *  The transaction data.\n      */\n     data?: string;\n\n     /**\n      *  The chain ID ",
      "doc": "A **JsonRpcTransactionRequest** is formatted as needed by the JSON-RPC\nEthereum API specification.",
      "tags": []
    },
    {
      "name": "LogParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LogParams {\n    /**\n     *  The transaction hash for the transaxction the log occurred in.\n     */\n    transactionHash: string;\n\n    /**\n     *  The block hash of the block that included the transaction for this\n     *  log.\n     */\n    blockHash: string;\n\n    /**\n     *  The block ",
      "doc": "a **LogParams** encodes the minimal required properties for a\nformatted log.",
      "tags": []
    },
    {
      "name": "MinedBlock",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinedBlock extends Block {\n    /**\n     *  The block number also known as the block height.\n     */\n    readonly number: number;\n\n    /**\n     *  The block hash.\n     */\n    readonly hash: string;\n\n    /**\n     *  The block timestamp, in seconds from epoch.\n     */\n    readonly time",
      "doc": "An Interface to indicate a [[Block]] has been included in the\nblockchain. This asserts a Type Guard that necessary properties\nare non-null.\n\nBefore a block is included, it is a //pending// block.",
      "tags": []
    },
    {
      "name": "MinedTransactionResponse",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinedTransactionResponse extends TransactionResponse {\n    /**\n     *  The block number this transaction occurred in.\n     */\n    blockNumber: number;\n\n    /**\n     *  The block hash this transaction occurred in.\n     */\n    blockHash: string;\n\n    /**\n     *  The date this transact",
      "doc": "A **MinedTransactionResponse** is an interface representing a\ntransaction which has been mined and allows for a type guard for its\nproperty values being defined.",
      "tags": []
    },
    {
      "name": "Networkish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Networkish = Network | number | bigint | string | {\n    name?: string,\n    chainId?: number,\n    //layerOneConnection?: Provider,\n    ensAddress?: string,\n    ensNetwork?: number\n};",
      "doc": "A Networkish can be used to allude to a Network, by specifing:\n- a [[Network]] object\n- a well-known (or registered) network name\n- a well-known (or registered) chain ID\n- an object with sufficient details to describe a network",
      "tags": []
    },
    {
      "name": "OrphanFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OrphanFilter = {\n    orphan: \"drop-block\",\n    hash: string,\n    number: number\n} | {\n    orphan: \"drop-transaction\",\n    tx: { hash: string, blockHash: string, blockNumber: number },\n    other?: { hash: string, blockHash: string, blockNumber: number }\n} | {\n    orphan: \"reorder-transact",
      "doc": "An Orphan Filter allows detecting when an orphan block has\nresulted in dropping a block or transaction or has resulted\nin transactions changing order.\n\nNot currently fully supported.",
      "tags": []
    },
    {
      "name": "PerformActionFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PerformActionFilter = {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n} | {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    blockHash?: string;\n};",
      "doc": "A normalized filter used for [[PerformActionRequest]] objects.",
      "tags": []
    },
    {
      "name": "PerformActionRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PerformActionRequest = {\n    method: \"broadcastTransaction\",\n    signedTransaction: string\n} | {\n    method: \"call\",\n    transaction: PerformActionTransaction, blockTag: BlockTag\n} | {\n    method: \"chainId\"\n} | {\n    method: \"estimateGas\",\n    transaction: PerformActionTransaction\n} | {\n",
      "doc": "The [[AbstractProvider]] methods will normalize all values and pass this\ntype to [[AbstractProvider-_perform]].",
      "tags": []
    },
    {
      "name": "PerformActionTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PerformActionTransaction extends PreparedTransactionRequest {\n    /**\n     *  The ``to`` address of the transaction.\n     */\n    to?: string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: string;\n}",
      "doc": "A normalized transactions used for [[PerformActionRequest]] objects.",
      "tags": []
    },
    {
      "name": "PreparedTransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PreparedTransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: number;\n\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: AddressLike;\n\n    /**\n     *  The nonce of ",
      "doc": "A **PreparedTransactionRequest** is identical to a [[TransactionRequest]]\nexcept all the property types are strictly enforced.",
      "tags": []
    },
    {
      "name": "ProviderEvent",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProviderEvent = string | Array<string | Array<string>> | EventFilter | OrphanFilter;",
      "doc": "A **ProviderEvent** provides the types of events that can be subscribed\nto on a [[Provider]].\n\nEach provider may include additional possible events it supports, but\nthe most commonly supported are:\n\n**``\"block\"``** - calls the listener with the current block number on each\nnew block.\n\n**``\"error\"``** - calls the listener on each async error that occurs during\nthe event loop, with the error.\n\n**``\"debug\"``** - calls the listener on debug events, which can be used to\ntroubleshoot network errors, provider problems, etc.\n\n**``transaction hash``** - calls the listener on each block after the\ntransaction has been mined; generally ``.once`` is more appropriate for\nthis event.\n\n**``Array``** - calls the listener on each log that matches the filter.\n\n[[EventFilter]] - calls the listener with each matching log",
      "tags": []
    },
    {
      "name": "Subscriber",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Subscriber {\n    /**\n     *  Called initially when a subscriber is added the first time.\n     */\n    start(): void;\n\n    /**\n     *  Called when there are no more subscribers to the event.\n     */\n    stop(): void;\n\n    /**\n     *  Called when the subscription should pause.\n     *\n ",
      "doc": "A **Subscriber** manages a subscription.\n\nOnly developers sub-classing [[AbstractProvider[[ will care about this,\nif they are modifying a low-level feature of how subscriptions operate.",
      "tags": []
    },
    {
      "name": "Subscription",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Subscription = {\n    type: \"block\" | \"close\" | \"debug\" | \"error\" | \"finalized\" | \"network\" | \"pending\" | \"safe\",\n    tag: string\n} | {\n    type: \"transaction\",\n    tag: string,\n    hash: string\n} | {\n    type: \"event\",\n    tag: string,\n    filter: EventFilter\n} | {\n    type: \"orphan\",\n  ",
      "doc": "The value passed to the [[AbstractProvider-_getSubscriber]] method.\n\nOnly developers sub-classing [[AbstractProvider[[ will care about this,\nif they are modifying a low-level feature of how subscriptions operate.",
      "tags": []
    },
    {
      "name": "TopicFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type TopicFilter = Array<null | string | Array<string>>;",
      "doc": "A **TopicFilter** provides a struture to define bloom-filter\nqueries.\n\nEach field that is ``null`` matches **any** value, a field that is\na ``string`` must match exactly that value and ``array`` is\neffectively an ``OR``-ed set, where any one of those values must\nmatch.",
      "tags": []
    },
    {
      "name": "TransactionReceiptParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionReceiptParams {\n    /**\n     *  The target of the transaction. If null, the transaction was trying\n     *  to deploy a transaction with the ``data`` as the initi=code.\n     */\n    to: null | string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from: string;",
      "doc": "a **TransactionReceiptParams** encodes the minimal required properties\nfor a formatted transaction receipt.",
      "tags": []
    },
    {
      "name": "TransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: null | number;\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: null | AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: null | AddressLike;\n\n    /**\n     *  T",
      "doc": "A **TransactionRequest** is a transactions with potentially various\nproperties not defined, or with less strict types for its values.\n\nThis is used to pass to various operations, which will internally\ncoerce any types and populate any necessary values.",
      "tags": []
    },
    {
      "name": "TransactionResponseParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionResponseParams {\n    /**\n     *  The block number of the block that included this transaction.\n     */\n    blockNumber: null | number;\n\n    /**\n     *  The block hash of the block that included this transaction.\n     */\n    blockHash: null | string;\n\n    /**\n     *  The t",
      "doc": "a **TransactionResponseParams** encodes the minimal required properties\nfor a formatted transaction response.",
      "tags": []
    },
    {
      "name": "WebSocketCreator",
      "kind": "TypeAliasDeclaration",
      "signature": "export type WebSocketCreator = () => WebSocketLike;",
      "doc": "A function which can be used to re-create a WebSocket connection\non disconnect.",
      "tags": []
    },
    {
      "name": "WebSocketLike",
      "kind": "InterfaceDeclaration",
      "signature": "export interface WebSocketLike {\n    onopen: null | ((...args: Array<any>) => any);\n    onmessage: null | ((...args: Array<any>) => any);\n    onerror: null | ((...args: Array<any>) => any);\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}",
      "doc": "A generic interface to a Websocket-like object.",
      "tags": []
    },
    {
      "name": "AccessList",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessList = Array<AccessListEntry>;",
      "doc": "An ordered collection of [[AccessList]] entries.",
      "tags": []
    },
    {
      "name": "AccessListish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;",
      "doc": "Any ethers-supported access list structure.",
      "tags": []
    },
    {
      "name": "AccessListEntry",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessListEntry = { address: string, storageKeys: Array<string> };",
      "doc": "A single [[AccessList]] entry of storage keys (slots) for an address.",
      "tags": []
    },
    {
      "name": "Authorization",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Authorization {\n    address: string;\n    nonce: bigint;\n    chainId: bigint;\n    signature: Signature;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "AuthorizationLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AuthorizationLike = {\n    address: string;\n    nonce: BigNumberish;\n    chainId: BigNumberish;\n    signature: SignatureLike\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "Blob",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Blob {\n    data: string;\n    proof: string;\n    commitment: string;\n}",
      "doc": "A full-valid BLOb object for [[link-eip-4844]] transactions.\n\nThe commitment and proof should have been computed using a\nKZG library.",
      "tags": []
    },
    {
      "name": "BlobLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BlobLike = BytesLike | {\n    data: BytesLike;\n    proof: BytesLike;\n    commitment: BytesLike;\n};",
      "doc": "A BLOb object that can be passed for [[link-eip-4844]]\ntransactions.\n\nIt may have had its commitment and proof already provided\nor rely on an attached [[KzgLibrary]] to compute them.",
      "tags": []
    },
    {
      "name": "KzgLibrary",
      "kind": "InterfaceDeclaration",
      "signature": "export interface KzgLibrary {\n    blobToKzgCommitment: (blob: Uint8Array) => Uint8Array;\n    computeBlobKzgProof: (blob: Uint8Array, commitment: Uint8Array) => Uint8Array;\n}",
      "doc": "A KZG Library with the necessary functions to compute\nBLOb commitments and proofs.",
      "tags": []
    },
    {
      "name": "KzgLibraryLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type KzgLibraryLike  = KzgLibrary | {\n    // kzg-wasm >= 0.5.0\n    blobToKZGCommitment: (blob: string) => string;\n    computeBlobKZGProof: (blob: string, commitment: string) => string;\n} | {\n    // micro-ecc-signer\n    blobToKzgCommitment: (blob: string) => string | Uint8Array;\n    computeBlo",
      "doc": "A KZG Library with any of the various API configurations.\nAs the library is still experimental and the API is not\nstable, depending on the version used the method names and\nsignatures are still in flux.\n\nThis allows any of the versions to be passed into Transaction\nwhile providing a stable external API.",
      "tags": []
    },
    {
      "name": "TransactionLike",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionLike<A = string> {\n    /**\n     *  The type.\n     */\n    type?: null | number;\n\n    /**\n     *  The recipient address or ``null`` for an ``init`` transaction.\n     */\n    to?: null | A;\n\n    /**\n     *  The sender.\n     */\n    from?: null | A;\n\n    /**\n     *  The nonce.\n",
      "doc": "A **TransactionLike** is an object which is appropriate as a loose\ninput for many operations which will populate missing properties of\na transaction.",
      "tags": []
    },
    {
      "name": "BytesLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BytesLike = DataHexString | Uint8Array;",
      "doc": "An object that can be used to represent binary data.",
      "tags": []
    },
    {
      "name": "BigNumberish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BigNumberish = string | Numeric;",
      "doc": "Any type that can be used where a big number is needed.",
      "tags": []
    },
    {
      "name": "Numeric",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Numeric = number | bigint;",
      "doc": "Any type that can be used where a numeric value is needed.",
      "tags": []
    },
    {
      "name": "ErrorCode",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVAL",
      "doc": "All errors emitted by ethers have an **ErrorCode** to help\nidentify and coalesce errors to simplify programmatic analysis.\n\nEach **ErrorCode** is the %%code%% proerty of a coresponding\n[[EthersError]].\n\n**Generic Errors**\n\n**``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n\n**``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n\n**``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n\n**``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n\n**``\"SERVER_ERROR\"``** - see [[ServerError]]\n\n**``\"TIMEOUT\"``** - see [[TimeoutError]]\n\n**``\"BAD_DATA\"``** - see [[BadDataError]]\n\n**``\"CANCELLED\"``** - see [[CancelledError]]\n\n**Operational Errors**\n\n**``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n\n**``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n\n**Argument Errors**\n\n**``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n\n**``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n\n**``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n\n**``\"VALUE_MISMATCH\"``** - //unused//\n\n**Blockchain Errors**\n\n**``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n\n**``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n\n**``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n\n**``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n\n**``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n\n**``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n\n**``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n\n**User Interaction Errors**\n\n**``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]",
      "tags": []
    },
    {
      "name": "FixedFormat",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FixedFormat = number | string | {\n    signed?: boolean,\n    width?: number,\n    decimals?: number\n};",
      "doc": "A description of a fixed-point arithmetic field.\n\nWhen specifying the fixed format, the values override the default of\na ``fixed128x18``, which implies a signed 128-bit value with 18\ndecimals of precision.\n\nThe alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and\n``ufixed128x18`` respectively.\n\nWhen a fixed format string begins with a ``u``, it indicates the field\nis unsigned, so any negative values will overflow. The first number\nindicates the bit-width and the second number indicates the decimal\nprecision.\n\nWhen a ``number`` is used for a fixed format, it indicates the number\nof decimal places, and the default width and signed-ness will be used.\n\nThe bit-width must be byte aligned and the decimals can be at most 80.",
      "tags": []
    },
    {
      "name": "Utf8ErrorFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number) => number;",
      "doc": "A callback that can be used with [[toUtf8String]] to analysis or\nrecovery from invalid UTF-8 data.\n\nParsing UTF-8 data is done through a simple Finite-State Machine (FSM)\nwhich calls the ``Utf8ErrorFunc`` if a fault is detected.\n\nThe %%reason%% indicates where in the FSM execution the fault\noccurred and the %%offset%% indicates where the input failed.\n\nThe %%bytes%% represents the raw UTF-8 data that was provided and\n%%output%% is the current array of UTF-8 code-points, which may\nbe updated by the ``Utf8ErrorFunc``.\n\nThe value of the %%badCodepoint%% depends on the %%reason%%. See\n[[Utf8ErrorReason]] for details.\n\nThe function should return the number of bytes that should be skipped\nwhen control resumes to the FSM.",
      "tags": []
    },
    {
      "name": "UnicodeNormalizationForm",
      "kind": "TypeAliasDeclaration",
      "signature": "export type UnicodeNormalizationForm = \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\";",
      "doc": "The stanard normalization forms.",
      "tags": []
    },
    {
      "name": "Utf8ErrorReason",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Utf8ErrorReason = \"UNEXPECTED_CONTINUE\" | \"BAD_PREFIX\" | \"OVERRUN\" |\n    \"MISSING_CONTINUE\" | \"OUT_OF_RANGE\" | \"UTF16_SURROGATE\" | \"OVERLONG\";",
      "doc": "When using the UTF-8 error API the following errors can be intercepted\nand processed as the %%reason%% passed to the [[Utf8ErrorFunc]].\n\n**``\"UNEXPECTED_CONTINUE\"``** - a continuation byte was present where there\nwas nothing to continue.\n\n**``\"BAD_PREFIX\"``** - an invalid (non-continuation) byte to start a\nUTF-8 codepoint was found.\n\n**``\"OVERRUN\"``** - the string is too short to process the expected\ncodepoint length.\n\n**``\"MISSING_CONTINUE\"``** - a missing continuation byte was expected but\nnot found. The %%offset%% indicates the index the continuation byte\nwas expected at.\n\n**``\"OUT_OF_RANGE\"``** - the computed code point is outside the range\nfor UTF-8. The %%badCodepoint%% indicates the computed codepoint, which was\noutside the valid UTF-8 range.\n\n**``\"UTF16_SURROGATE\"``** - the UTF-8 strings contained a UTF-16 surrogate\npair. The %%badCodepoint%% is the computed codepoint, which was inside the\nUTF-16 surrogate range.\n\n**``\"OVERLONG\"``** - the string is an overlong representation. The\n%%badCodepoint%% indicates the computed codepoint, which has already\nbeen bounds checked.",
      "tags": [
        {
          "tagName": "returns",
          "text": "string"
        }
      ]
    },
    {
      "name": "RlpStructuredData",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RlpStructuredData = string | Array<RlpStructuredData>;",
      "doc": "An RLP-encoded structure.",
      "tags": []
    },
    {
      "name": "RlpStructuredDataish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RlpStructuredDataish = string | Uint8Array | Array<RlpStructuredDataish>;",
      "doc": "An RLP-encoded structure, which allows Uint8Array.",
      "tags": []
    },
    {
      "name": "GetUrlResponse",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GetUrlResponse = {\n    statusCode: number,\n    statusMessage: string,\n    headers: Record<string, string>,\n    body: null | Uint8Array\n};",
      "doc": "An environment's implementation of ``getUrl`` must return this type.",
      "tags": []
    },
    {
      "name": "FetchPreflightFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchPreflightFunc = (req: FetchRequest) => Promise<FetchRequest>;",
      "doc": "Called before any network request, allowing updated headers (e.g. Bearer tokens), etc.",
      "tags": []
    },
    {
      "name": "FetchProcessFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchProcessFunc = (req: FetchRequest, resp: FetchResponse) => Promise<FetchResponse>;",
      "doc": "Called on the response, allowing client-based throttling logic or post-processing.",
      "tags": []
    },
    {
      "name": "FetchRetryFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchRetryFunc = (req: FetchRequest, resp: FetchResponse, attempt: number) => Promise<boolean>;",
      "doc": "Called prior to each retry; return true to retry, false to abort.",
      "tags": []
    },
    {
      "name": "FetchGatewayFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchGatewayFunc = (url: string, signal?: FetchCancelSignal) => Promise<FetchRequest | FetchResponse>;",
      "doc": "Called on Gateway URLs.",
      "tags": []
    },
    {
      "name": "FetchGetUrlFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchGetUrlFunc = (req: FetchRequest, signal?: FetchCancelSignal) => Promise<GetUrlResponse>;",
      "doc": "Used to perform a fetch; use this to override the underlying network\nfetch layer. In NodeJS, the default uses the \"http\" and \"https\" libraries\nand in the browser ``fetch`` is used. If you wish to use Axios, this is\nhow you would register it.",
      "tags": []
    },
    {
      "name": "EthersError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  A short message describing the error, with minimal additional\n     *  details.\n     */\n    shortMessage: string;\n\n    /**\n     *  Additio",
      "doc": "All errors in Ethers include properties to assist in\nmachine-readable errors.",
      "tags": []
    },
    {
      "name": "UnknownError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}",
      "doc": "This Error is a catch-all for when there is no way for Ethers to\nknow what the underlying problem is.",
      "tags": []
    },
    {
      "name": "NotImplementedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}",
      "doc": "This Error is mostly used as a stub for functionality that is\nintended for the future, but is currently not implemented.",
      "tags": []
    },
    {
      "name": "UnsupportedOperationError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}",
      "doc": "This Error indicates that the attempted operation is not supported.\n\nThis could range from a specific JSON-RPC end-point not supporting\na feature to a specific configuration of an object prohibiting the\noperation.\n\nFor example, a [[Wallet]] with no connected [[Provider]] is unable\nto send a transaction.",
      "tags": []
    },
    {
      "name": "NetworkError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    /**\n     *  The network event.\n     */\n    event: string;\n}",
      "doc": "This Error indicates a problem connecting to a network.",
      "tags": []
    },
    {
      "name": "ServerError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}",
      "doc": "This Error indicates there was a problem fetching a resource from\na server.",
      "tags": []
    },
    {
      "name": "TimeoutError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}",
      "doc": "This Error indicates that the timeout duration has expired and\nthat the operation has been implicitly cancelled.\n\nThe side-effect of the operation may still occur, as this\ngenerally means a request has been sent and there has simply\nbeen no response to indicate whether it was processed or not.",
      "tags": []
    },
    {
      "name": "BadDataError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}",
      "doc": "This Error indicates that a provided set of data cannot\nbe correctly interpreted.",
      "tags": []
    },
    {
      "name": "CancelledError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CancelledError extends EthersError<\"CANCELLED\"> {\n}",
      "doc": "This Error indicates that the operation was cancelled by a\nprogrammatic call, for example to ``cancel()``.",
      "tags": []
    },
    {
      "name": "BufferOverrunError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n",
      "doc": "This Error indicates an attempt was made to read outside the bounds\nof protected data.\n\nMost operations in Ethers are protected by bounds checks, to mitigate\nexploits when parsing data.",
      "tags": []
    },
    {
      "name": "NumericFaultError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}",
      "doc": "This Error indicates an operation which would result in incorrect\narithmetic output has occurred.\n\nFor example, trying to divide by zero or using a ``uint8`` to store\na negative value.",
      "tags": []
    },
    {
      "name": "InvalidArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}",
      "doc": "This Error indicates an incorrect type or value was passed to\na function or method.",
      "tags": []
    },
    {
      "name": "MissingArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}",
      "doc": "This Error indicates there were too few arguments were provided.",
      "tags": []
    },
    {
      "name": "UnexpectedArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}",
      "doc": "This Error indicates too many arguments were provided.",
      "tags": []
    },
    {
      "name": "CallExceptionError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-reada",
      "doc": "This **Error** indicates a transaction reverted.",
      "tags": []
    },
    {
      "name": "InsufficientFundsError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "The sending account has insufficient funds to cover the\nentire transaction cost.",
      "tags": []
    },
    {
      "name": "NonceExpiredError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "The sending account has already used this nonce in a\ntransaction that has been included.",
      "tags": []
    },
    {
      "name": "OffchainFaultError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}",
      "doc": "A CCIP-read exception, which cannot be recovered from or\nbe further processed.",
      "tags": []
    },
    {
      "name": "ReplacementUnderpricedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "An attempt was made to replace a transaction, but with an\ninsufficient additional fee to afford evicting the old\ntransaction from the memory pool.",
      "tags": []
    },
    {
      "name": "TransactionReplacedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was repla",
      "doc": "A pending transaction was replaced by another.",
      "tags": []
    },
    {
      "name": "UnconfiguredNameError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}",
      "doc": "This Error indicates an ENS name was used, but the name has not\nbeen configured.\n\nThis could indicate an ENS name is unowned or that the current\naddress being pointed to is the [[ZeroAddress]].",
      "tags": []
    },
    {
      "name": "ActionRejectedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n ",
      "doc": "This Error indicates a request was rejected by the user.\n\nIn most clients (such as MetaMask), when an operation requires user\nauthorization (such as ``signer.sendTransaction``), the client\npresents a dialog box to the user. If the user denies the request\nthis error is thrown.",
      "tags": []
    },
    {
      "name": "CodedEthersError",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T ex",
      "doc": "A conditional type that transforms the [[ErrorCode]] T into\nits EthersError type.",
      "tags": [
        {
          "tagName": "flatworm-skip-docs",
          "text": ""
        }
      ]
    },
    {
      "name": "CallExceptionAction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"sendTransaction\" | \"unknown\";",
      "doc": "The action that resulted in the call exception.",
      "tags": []
    },
    {
      "name": "CallExceptionTransaction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};",
      "doc": "The related transaction that caused the error.",
      "tags": []
    },
    {
      "name": "EventEmitterable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EventEmitterable<T> {\n    /**\n     *  Registers a %%listener%% that is called whenever the\n     *  %%event%% occurs until unregistered.\n     */\n    on(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Registers a %%listener%% that is called the next time\n     *  %%event",
      "doc": "An **EventEmitterable** behaves similar to an EventEmitter\nexcept provides async access to its methods.\n\nAn EventEmitter implements the observer pattern.",
      "tags": []
    },
    {
      "name": "Listener",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Listener = (...args: Array<any>) => void;",
      "doc": "A callback function called when a an event is triggered.",
      "tags": []
    },
    {
      "name": "CrowdsaleAccount",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CrowdsaleAccount = {\n    privateKey: string;\n    address: string;\n}",
      "doc": "The data stored within a JSON Crowdsale wallet is fairly\nminimal.",
      "tags": []
    },
    {
      "name": "KeystoreAccount",
      "kind": "TypeAliasDeclaration",
      "signature": "export type KeystoreAccount = {\n    address: string;\n    privateKey: string;\n    mnemonic?: {\n        path?: string;\n        locale?: string;\n        entropy: string;\n    }\n};",
      "doc": "The contents of a JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "EncryptOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type EncryptOptions = {\n   progressCallback?: ProgressCallback;\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}",
      "doc": "The parameters to use when encrypting a JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "version",
      "kind": "VariableDeclaration",
      "signature": "version: string = \"6.15.0\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBytes32String",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBytes32String(_bytes: BytesLike): string {\n    const data = getBytes(_bytes, \"bytes\");\n\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) { throw new Error(\"invalid bytes32 - not 32 bytes long\"); }\n    if (data[31] !== 0) { throw new Error(\"invalid byt",
      "doc": "Encodes the Bytes32-encoded %%bytes%% into a string.",
      "tags": []
    },
    {
      "name": "encodeBytes32String",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBytes32String(text: string): string {\n\n    // Get the bytes\n    const bytes = toUtf8Bytes(text);\n\n    // Check we have room for null-termination\n    if (bytes.length > 31) { throw new Error(\"bytes32 string must be less than 32 bytes\"); }\n\n    // Zero-pad (implicitly null-termin",
      "doc": "Encodes %%text%% as a Bytes32 string.",
      "tags": []
    },
    {
      "name": "AbiCoder",
      "kind": "ClassDeclaration",
      "signature": "export class AbiCoder {\n\n    #getCoder(param: ParamType): Coder {\n        if (param.isArray()) {\n            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n\n        if (param.isTuple()) {\n            return new TupleCoder(param.components.map((c)",
      "doc": "The **AbiCoder** is a low-level class responsible for encoding JavaScript\nvalues into binary data and decoding binary data into JavaScript values.",
      "tags": []
    },
    {
      "name": "ConstructorFragment",
      "kind": "ClassDeclaration",
      "signature": "export class ConstructorFragment extends Fragment {\n\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n  ",
      "doc": "A Fragment which represents a constructor.",
      "tags": []
    },
    {
      "name": "ErrorFragment",
      "kind": "ClassDeclaration",
      "signature": "export class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n\n    /",
      "doc": "A Fragment which represents a //Custom Error//.",
      "tags": []
    },
    {
      "name": "EventFragment",
      "kind": "ClassDeclaration",
      "signature": "export class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    readonly anonymous!: boolean;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>, anonymous: boolean) {\n        super(guard, \"even",
      "doc": "A Fragment which represents an Event.",
      "tags": []
    },
    {
      "name": "Fragment",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    readonly type!: FragmentType;\n\n    /**\n     *  The inputs for the fragment.\n     */\n    readonly inputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType,",
      "doc": "An abstract class to represent An individual fragment from a parse ABI.",
      "tags": []
    },
    {
      "name": "FallbackFragment",
      "kind": "ClassDeclaration",
      "signature": "export class FallbackFragment extends Fragment {\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean) {\n        super(guard, \"fallback\", inputs);\n        Object.d",
      "doc": "A Fragment which represents a method.",
      "tags": []
    },
    {
      "name": "FunctionFragment",
      "kind": "ClassDeclaration",
      "signature": "export class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    readonly constant!: boolean;\n\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    readonly outputs!: ReadonlyArray<",
      "doc": "A Fragment which represents a method.",
      "tags": []
    },
    {
      "name": "NamedFragment",
      "kind": "ClassDeclaration",
      "signature": "export abstract class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    readonly name!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, type, inputs);",
      "doc": "An abstract class to represent An individual fragment\nwhich has a name from a parse ABI.",
      "tags": []
    },
    {
      "name": "ParamType",
      "kind": "ClassDeclaration",
      "signature": "export class ParamType {\n\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    readonly name!: string;\n\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    readonly type!: string;\n\n    /**\n     *  T",
      "doc": "Each input and output of a [[Fragment]] is an Array of **ParamType**.",
      "tags": []
    },
    {
      "name": "StructFragment",
      "kind": "ClassDeclaration",
      "signature": "export class StructFragment extends NamedFragment {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n\n ",
      "doc": "A Fragment which represents a structure.",
      "tags": []
    },
    {
      "name": "checkResultErrors",
      "kind": "FunctionDeclaration",
      "signature": "export function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any):",
      "doc": "Returns all errors found in a [[Result]].\n\nSince certain errors encountered when creating a [[Result]] do\nnot impact the ability to continue parsing data, they are\ndeferred until they are actually accessed. Hence a faulty string\nin an Event that is never used does not impact the program flow.\n\nHowever, sometimes it may be useful to access, identify or\nvalidate correctness of a [[Result]].",
      "tags": [
        {
          "tagName": "_docloc",
          "text": "api/abi"
        }
      ]
    },
    {
      "name": "checkResultErrors.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "ErrorDescription",
      "kind": "ClassDeclaration",
      "signature": "export class ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    readonly fragment!: ErrorFragment;\n\n    /**\n     *  The name of the Error.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    readonly args!: Result;\n\n ",
      "doc": "When using the [[Interface-parseError]] to automatically match an\nerror for a call result for parsing, an **ErrorDescription** is returned.",
      "tags": []
    },
    {
      "name": "Indexed",
      "kind": "ClassDeclaration",
      "signature": "export class Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _isIndexed!: boolean;\n\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard f",
      "doc": "An **Indexed** is used as a value when a value that does not\nfit within a topic (i.e. not a fixed-length, 32-byte type). It\nis the ``keccak256`` of the value, and used for types such as\narrays, tuples, bytes and strings.",
      "tags": []
    },
    {
      "name": "Interface",
      "kind": "ClassDeclaration",
      "signature": "export class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if",
      "doc": "An Interface abstracts many of the low-level details for\nencoding and decoding the data on the blockchain.\n\nAn ABI provides information on how to encode data to send to\na Contract, how to decode the results and events and how to\ninterpret revert errors.\n\nThe ABI can be specified by [any supported format](InterfaceAbi).",
      "tags": []
    },
    {
      "name": "LogDescription",
      "kind": "ClassDeclaration",
      "signature": "export class LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The name of the Event.\n     */\n    readonly name!: string;\n\n    /**\n     *  The full Event signature.\n     */\n    readonly signature!: string;\n\n    ",
      "doc": "When using the [[Interface-parseLog]] to automatically match a Log to its event\nfor parsing, a **LogDescription** is returned.",
      "tags": []
    },
    {
      "name": "Result",
      "kind": "ClassDeclaration",
      "signature": "export class Result extends Array<any> {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @privat",
      "doc": "A [[Result]] is a sub-class of Array, which allows accessing any\nof its values either positionally by its index or, if keys are\nprovided by its name.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/abi"
        }
      ]
    },
    {
      "name": "TransactionDescription",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    readonly fragment!: FunctionFragment;\n\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments pas",
      "doc": "When using the [[Interface-parseTransaction]] to automatically match\na transaction data to its function for parsing,\na **TransactionDescription** is returned.",
      "tags": []
    },
    {
      "name": "Typed",
      "kind": "ClassDeclaration",
      "signature": "export class Typed {\n\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    readonly type!: string;\n\n    /**\n     *  The actual value.\n     */\n    readonly value!: any;\n\n    readonly #options: any;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _typedSymbol!: Symbol;\n\n    /**\n     * ",
      "doc": "The **Typed** class to wrap values providing explicit type information.",
      "tags": []
    },
    {
      "name": "getAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getAddress(address: string): string {\n\n    assertArgument(typeof(address) === \"string\", \"invalid address\", \"address\", address);\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) { address = \"0x\" + address; }\n\n",
      "doc": "Returns a normalized and checksumed address for %%address%%.\nThis accepts non-checksum addresses, checksum addresses and\n[[getIcapAddress]] formats.\n\nThe checksum in Ethereum uses the capitalization (upper-case\nvs lower-case) of the characters within an address to encode\nits checksum, which offers, on average, a checksum of 15-bits.\n\nIf %%address%% contains both upper-case and lower-case, it is\nassumed to already be a checksum address and its checksum is\nvalidated, and if the address fails its expected checksum an\nerror is thrown.\n\nIf you wish the checksum of %%address%% to be ignore, it should\nbe converted to lower-case (i.e. ``.toLowercase()``) before\nbeing passed in. This should be a very rare situation though,\nthat you wish to bypass the safegaurds in place to protect\nagainst an address that has been incorrectly copied from another\nsource.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Adds the checksum (via upper-casing specific letters)\ngetAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n//_result:\n\n// Converts ICAP address and adds checksum\ngetAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n//_result:\n\n// Throws an error if an address contains mixed case,\n// but the checksum fails\ngetAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_error:"
        }
      ]
    },
    {
      "name": "getIcapAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getIcapAddress(address: string): string {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(",
      "doc": "The [ICAP Address format](link-icap) format is an early checksum\nformat which attempts to be compatible with the banking\nindustry [IBAN format](link-wiki-iban) for bank accounts.\n\nIt is no longer common or a recommended format.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\ngetIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n//_result:\n\ngetIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n//_result:\n\n// Throws an error if the ICAP checksum is wrong\ngetIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n//_error:"
        }
      ]
    },
    {
      "name": "getCreateAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getCreateAddress(tx: { from: string, nonce: BigNumberish }): string {\n    const from = getAddress(tx.from);\n    const nonce = getBigInt(tx.nonce, \"tx.nonce\");\n\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length %",
      "doc": "Returns the address that would result from a ``CREATE`` for %%tx%%.\n\nThis can be used to compute the address a contract will be\ndeployed to by an EOA when sending a deployment transaction (i.e.\nwhen the ``to`` address is ``null``).\n\nThis can also be used to compute the address a contract will be\ndeployed to by a contract, by using the contract's address as the\n``to`` and the contract's nonce.",
      "tags": [
        {
          "tagName": "example",
          "text": "  from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n  nonce = 5;\n\n  getCreateAddress({ from, nonce });\n  //_result:"
        }
      ]
    },
    {
      "name": "getCreate2Address",
      "kind": "FunctionDeclaration",
      "signature": "export function getCreate2Address(_from: string, _salt: BytesLike, _initCodeHash: BytesLike): string {\n    const from = getAddress(_from);\n    const salt = getBytes(_salt, \"salt\");\n    const initCodeHash = getBytes(_initCodeHash, \"initCodeHash\");\n\n    assertArgument(salt.length === 32, \"salt must be",
      "doc": "Returns the address that would result from a ``CREATE2`` operation\nwith the given %%from%%, %%salt%% and %%initCodeHash%%.\n\nTo compute the %%initCodeHash%% from a contract's init code, use\nthe [[keccak256]] function.\n\nFor a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].",
      "tags": [
        {
          "tagName": "example",
          "text": "  // The address of the contract\n  from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n\n  // The salt\n  salt = id(\"HelloWorld\")\n\n  // The hash of the initCode\n  initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n  initCodeHash = keccak256(initCode)\n\n  getCreate2Address(from, salt, initCodeHash)\n  //_result:"
        }
      ]
    },
    {
      "name": "isAddressable",
      "kind": "FunctionDeclaration",
      "signature": "export function isAddressable(value: any): value is Addressable {\n    return (value && typeof(value.getAddress) === \"function\");\n}",
      "doc": "Returns true if %%value%% is an object which implements the\n[[Addressable]] interface.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Wallets and AbstractSigner sub-classes\nisAddressable(Wallet.createRandom())\n//_result:\n\n// Contracts\ncontract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\nisAddressable(contract)\n//_result:"
        }
      ]
    },
    {
      "name": "isAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function isAddress(value: any): value is string {\n    try {\n        getAddress(value);\n        return true;\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%value%% is a valid address.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Valid address\nisAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_result:\n\n// Valid ICAP address\nisAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n//_result:\n\n// Invalid checksum\nisAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n//_result:\n\n// Invalid ICAP checksum\nisAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_result:\n\n// Not an address (an ENS name requires a provided and an\n// asynchronous API to access)\nisAddress(\"ricmoo.eth\")\n//_result:"
        }
      ]
    },
    {
      "name": "resolveAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function resolveAddress(target: AddressLike, resolver?: null | NameResolver): string | Promise<string> {\n\n    if (typeof(target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) { return getAddress(target); }\n\n        assert(resolver != null, \"ENS resolution requires a provider\"",
      "doc": "Resolves to an address for the %%target%%, which may be any\nsupported address type, an [[Addressable]] or a Promise which\nresolves to an address.\n\nIf an ENS name is provided, but that name has not been correctly\nconfigured a [[UnconfiguredNameError]] is thrown.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n\n// Addresses are return synchronously\nresolveAddress(addr, provider)\n//_result:\n\n// Address promises are resolved asynchronously\nresolveAddress(Promise.resolve(addr))\n//_result:\n\n// ENS names are resolved asynchronously\nresolveAddress(\"dai.tokens.ethers.eth\", provider)\n//_result:\n\n// Addressable objects are resolved asynchronously\ncontract = new Contract(addr, [ ])\nresolveAddress(contract, provider)\n//_result:\n\n// Unconfigured ENS names reject\nresolveAddress(\"nothing-here.ricmoo.eth\", provider)\n//_error:\n\n// ENS names require a NameResolver object passed in\n// (notice the provider was omitted)\nresolveAddress(\"nothing-here.ricmoo.eth\")\n//_error:"
        }
      ]
    },
    {
      "name": "ZeroAddress",
      "kind": "VariableDeclaration",
      "signature": "ZeroAddress: string = \"0x0000000000000000000000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "WeiPerEther",
      "kind": "VariableDeclaration",
      "signature": "WeiPerEther: bigint = BigInt(\"1000000000000000000\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "MaxUint256",
      "kind": "VariableDeclaration",
      "signature": "MaxUint256: bigint = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinInt256",
      "kind": "VariableDeclaration",
      "signature": "MinInt256: bigint = BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\") * BigInt(-1)",
      "doc": "",
      "tags": []
    },
    {
      "name": "MaxInt256",
      "kind": "VariableDeclaration",
      "signature": "MaxInt256: bigint = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "N",
      "kind": "VariableDeclaration",
      "signature": "N: bigint = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "ZeroHash",
      "kind": "VariableDeclaration",
      "signature": "ZeroHash: string = \"0x0000000000000000000000000000000000000000000000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "EtherSymbol",
      "kind": "VariableDeclaration",
      "signature": "EtherSymbol: string = \"\\u039e\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "MessagePrefix",
      "kind": "VariableDeclaration",
      "signature": "MessagePrefix: string = \"\\x19Ethereum Signed Message:\\n\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "BaseContract",
      "kind": "ClassDeclaration",
      "signature": "export class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  meth",
      "doc": "",
      "tags": []
    },
    {
      "name": "Contract",
      "kind": "ClassDeclaration",
      "signature": "export class Contract extends _ContractBase() { }",
      "doc": "A [[BaseContract]] with no type guards on its methods or events.",
      "tags": []
    },
    {
      "name": "ContractFactory",
      "kind": "ClassDeclaration",
      "signature": "export class ContractFactory<A extends Array<any> = Array<any>, I = BaseContract> {\n\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    readonly bytecode!: string;\n\n    /**\n    ",
      "doc": "A **ContractFactory** is used to deploy a Contract to the blockchain.",
      "tags": []
    },
    {
      "name": "ContractEventPayload",
      "kind": "ClassDeclaration",
      "signature": "export class ContractEventPayload extends ContractUnknownEventPayload {\n\n    /**\n     *  The matching event.\n     */\n    declare readonly fragment: EventFragment;\n\n    /**\n     *  The log, with parsed properties.\n     */\n    declare readonly log: EventLog;\n\n    /**\n     *  The parsed arguments passe",
      "doc": "A **ContractEventPayload** is included as the last parameter to\nContract Events when the event is known.",
      "tags": []
    },
    {
      "name": "ContractTransactionReceipt",
      "kind": "ClassDeclaration",
      "signature": "export class ContractTransactionReceipt extends TransactionReceipt {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionReceipt) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  The",
      "doc": "A **ContractTransactionReceipt** includes the parsed logs from a\n[[TransactionReceipt]].",
      "tags": []
    },
    {
      "name": "ContractTransactionResponse",
      "kind": "ClassDeclaration",
      "signature": "export class ContractTransactionResponse extends TransactionResponse {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionResponse) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  ",
      "doc": "A **ContractTransactionResponse** will return a\n[[ContractTransactionReceipt]] when waited on.",
      "tags": []
    },
    {
      "name": "ContractUnknownEventPayload",
      "kind": "ClassDeclaration",
      "signature": "export  class ContractUnknownEventPayload extends EventPayload<ContractEventName> {\n    /**\n     *  The log with no matching events.\n     */\n    readonly log!: Log;\n\n    /**\n     *  @_event:\n     */\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, log: Lo",
      "doc": "A **ContractUnknownEventPayload** is included as the last parameter to\nContract Events when the event does not match any events in the ABI.",
      "tags": []
    },
    {
      "name": "EventLog",
      "kind": "ClassDeclaration",
      "signature": "export class EventLog extends Log {\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The matching event.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    readonly args",
      "doc": "An **EventLog** contains additional properties parsed from the [[Log]].",
      "tags": []
    },
    {
      "name": "UndecodedEventLog",
      "kind": "ClassDeclaration",
      "signature": "export class UndecodedEventLog extends Log {\n\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    readonly error!: Error;\n\n    /**\n     * @_ignore:\n     */\n    constructor(log: Log, error: Error) {\n        super(log, log.provider);\n        defineProperties<UndecodedEventLo",
      "doc": "An **EventLog** contains additional properties parsed from the [[Log]].",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "FunctionDeclaration",
      "signature": "export function computeHmac(algorithm: \"sha256\" | \"sha512\", _key: BytesLike, _data: BytesLike): string {\n    const key = getBytes(_key, \"key\");\n    const data = getBytes(_data, \"data\");\n    return hexlify(__computeHmac(algorithm, key, data));\n}",
      "doc": "Return the HMAC for %%data%% using the %%key%% key with the underlying\n%%algo%% used for compression.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nkey = id(\"some-secret\")\n\n// Compute the HMAC\ncomputeHmac(\"sha256\", key, \"0x1337\")\n//_result:\n\n// To compute the HMAC of UTF-8 data, the data must be\n// converted to UTF-8 bytes\ncomputeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\n//_result:"
        }
      ]
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function randomBytes(length: number): Uint8Array {\n    return __randomBytes(length);\n}",
      "doc": "Return %%length%% bytes of cryptographically secure random data.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nrandomBytes(8)\n//_result:"
        }
      ]
    },
    {
      "name": "randomBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function keccak256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}",
      "doc": "Compute the cryptographic KECCAK256 hash of %%data%%.\n\nThe %%data%% **must** be a data representation, to compute the\nhash of UTF-8 data use the [[id]] function.",
      "tags": [
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nkeccak256(\"0x\")\n//_result:\n\nkeccak256(\"0x1337\")\n//_result:\n\nkeccak256(new Uint8Array([ 0x13, 0x37 ]))\n//_result:\n\n// Strings are assumed to be DataHexString, otherwise it will\n// throw. To hash UTF-8 data, see the note above.\nkeccak256(\"Hello World\")\n//_error:"
        }
      ]
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "FunctionDeclaration",
      "signature": "export function ripemd160(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__ripemd160(data));\n}",
      "doc": "Compute the cryptographic RIPEMD-160 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nripemd160(\"0x\")\n//_result:\n\nripemd160(\"0x1337\")\n//_result:\n\nripemd160(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "FunctionDeclaration",
      "signature": "export function sha256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha256(data));\n}",
      "doc": "Compute the cryptographic SHA2-256 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nsha256(\"0x\")\n//_result:\n\nsha256(\"0x1337\")\n//_result:\n\nsha256(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "FunctionDeclaration",
      "signature": "export function sha512(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha512(data));\n}",
      "doc": "Compute the cryptographic SHA2-512 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nsha512(\"0x\")\n//_result:\n\nsha512(\"0x1337\")\n//_result:\n\nsha512(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "FunctionDeclaration",
      "signature": "export function pbkdf2(_password: BytesLike, _salt: BytesLike, iterations: number, keylen: number, algo: \"sha256\" | \"sha512\"): string {\n    const password = getBytes(_password, \"password\");\n    const salt = getBytes(_salt, \"salt\");\n    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo",
      "doc": "Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\nthe %%salt%% and using %%iterations%% of %%algo%%.\n\nThis PBKDF is outdated and should not be used in new projects, but is\nrequired to decrypt older files.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the PBKDF2\npbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n//_result:"
        }
      ]
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "FunctionDeclaration",
      "signature": "export async function scrypt(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number, progress?: ProgressCallback): Promise<string> {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(await __scryptAsync(passwd, salt, ",
      "doc": "The [[link-wiki-scrypt]] uses a memory and cpu hard method of\nderivation to increase the resource cost to brute-force a password\nfor a given key.\n\nThis means this algorithm is intentionally slow, and can be tuned to\nbecome slower. As computation and memory speed improve over time,\nincreasing the difficulty maintains the cost of an attacker.\n\nFor example, if a target time of 5 seconds is used, a legitimate user\nwhich knows their password requires only 5 seconds to unlock their\naccount. A 6 character password has 68 billion possibilities, which\nwould require an attacker to invest over 10,000 years of CPU time. This\nis of course a crude example (as password generally aren't random),\nbut demonstrates to value of imposing large costs to decryption.\n\nFor this reason, if building a UI which involved decrypting or\nencrypting datsa using scrypt, it is recommended to use a\n[[ProgressCallback]] (as event short periods can seem lik an eternity\nif the UI freezes). Including the phrase //\"decrypting\"// in the UI\ncan also help, assuring the user their waiting is for a good reason.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        },
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the scrypt\nscrypt(passwordBytes, salt, 1024, 8, 1, 16)\n//_result:"
        }
      ]
    },
    {
      "name": "scrypt.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "FunctionDeclaration",
      "signature": "export function scryptSync(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number): string {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(__scryptSync(passwd, salt, N, r, p, dkLen));\n}",
      "doc": "Provides a synchronous variant of [[scrypt]].\n\nThis will completely lock up and freeze the UI in a browser and will\nprevent any event loop from progressing. For this reason, it is\npreferred to use the [async variant](scrypt).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        },
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the scrypt\nscryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n//_result:"
        }
      ]
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "lock",
      "kind": "FunctionDeclaration",
      "signature": "function lock(): void {\n    computeHmac.lock();\n    keccak256.lock();\n    pbkdf2.lock();\n    randomBytes.lock();\n    ripemd160.lock();\n    scrypt.lock();\n    scryptSync.lock();\n    sha256.lock();\n    sha512.lock();\n    randomBytes.lock();\n}",
      "doc": "Once called, prevents any future change to the underlying cryptographic\nprimitives using the ``.register`` feature for hooks.",
      "tags": []
    },
    {
      "name": "Signature",
      "kind": "ClassDeclaration",
      "signature": "export class Signature {\n    #r: string;\n    #s: string;\n    #v: 27 | 28;\n    #networkV: null | bigint;\n\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n   ",
      "doc": "A Signature",
      "tags": [
        {
          "tagName": "TODO",
          "text": ""
        },
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Signing"
        }
      ]
    },
    {
      "name": "SigningKey",
      "kind": "ClassDeclaration",
      "signature": "export class SigningKey {\n    #privateKey: string;\n\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey: BytesLike) {\n        assertArgument(dataLength(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = h",
      "doc": "A **SigningKey** provides high-level access to the elliptic curve\ncryptography (ECC) operations and key management.",
      "tags": []
    },
    {
      "name": "id",
      "kind": "FunctionDeclaration",
      "signature": "export function id(value: string): string {\n    return keccak256(toUtf8Bytes(value));\n}",
      "doc": "A simple hashing function which operates on UTF-8 strings to\ncompute an 32-byte identifier.\n\nThis simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\nthe [[keccak256]].",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nid(\"hello world\")\n//_result:"
        }
      ]
    },
    {
      "name": "ensNormalize",
      "kind": "FunctionDeclaration",
      "signature": "export function ensNormalize(name: string): string {\n    try {\n        if (name.length === 0) { throw new Error(\"empty label\"); }\n        return ens_normalize(name);\n    } catch (error: any) {\n        assertArgument(false, `invalid ENS name (${ error.message })`, \"name\", name);\n    }\n}",
      "doc": "Returns the ENS %%name%% normalized.",
      "tags": []
    },
    {
      "name": "isValidName",
      "kind": "FunctionDeclaration",
      "signature": "export function isValidName(name: string): name is string {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns ``true`` if %%name%% is a valid ENS name.",
      "tags": []
    },
    {
      "name": "namehash",
      "kind": "FunctionDeclaration",
      "signature": "export function namehash(name: string): string {\n    assertArgument(typeof(name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n\n    assertArgument(name.length, `invalid ENS name (empty label)`, \"name\", name);\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSp",
      "doc": "Returns the [[link-namehash]] for %%name%%.",
      "tags": []
    },
    {
      "name": "dnsEncode",
      "kind": "FunctionDeclaration",
      "signature": "export function dnsEncode(name: string, _maxLength?: number): string {\n    const length = (_maxLength != null) ? _maxLength: 63;\n\n    assertArgument(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        assertAr",
      "doc": "Returns the DNS encoded %%name%%.\n\nThis is used for various parts of ENS name resolution, such\nas the wildcard resolution.",
      "tags": []
    },
    {
      "name": "hashAuthorization",
      "kind": "FunctionDeclaration",
      "signature": "export function hashAuthorization(auth: AuthorizationRequest): string {\n    assertArgument(typeof(auth.address) === \"string\", \"invalid address for hashAuthorization\", \"auth.address\", auth);\n    return keccak256(concat([\n        \"0x05\", encodeRlp([\n            (auth.chainId != null) ? toBeArray(auth.",
      "doc": "Computes the [[link-eip-7702]] authorization digest to sign.",
      "tags": []
    },
    {
      "name": "verifyAuthorization",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyAuthorization(auth: AuthorizationRequest, sig: SignatureLike): string {\n    return recoverAddress(hashAuthorization(auth), sig);\n}",
      "doc": "Return the address of the private key that produced\nthe signature %%sig%% during signing for %%message%%.",
      "tags": []
    },
    {
      "name": "hashMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function hashMessage(message: Uint8Array | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(MessagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}",
      "doc": "Computes the [[link-eip-191]] personal-sign message digest to sign.\n\nThis prefixes the message with [[MessagePrefix]] and the decimal length\nof %%message%% and computes the [[keccak256]] digest.\n\nIf %%message%% is a string, it is converted to its UTF-8 bytes\nfirst. To compute the digest of a [[DataHexString]], it must be converted\nto [bytes](getBytes).",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nhashMessage(\"Hello World\")\n//_result:\n\n// Hashes the SIX (6) string characters, i.e.\n// [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\nhashMessage(\"0x4243\")\n//_result:\n\n// Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\nhashMessage(getBytes(\"0x4243\"))\n//_result:\n\n// ...which is equal to using data\nhashMessage(new Uint8Array([ 0x42, 0x43 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "verifyMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyMessage(message: Uint8Array | string, sig: SignatureLike): string {\n    const digest = hashMessage(message);\n    return recoverAddress(digest, sig);\n}",
      "doc": "Return the address of the private key that produced\nthe signature %%sig%% during signing for %%message%%.",
      "tags": []
    },
    {
      "name": "solidityPacked",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPacked(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, in",
      "doc": "Computes the [[link-solc-packed]] representation of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "solidityPackedKeccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPackedKeccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _keccak256(solidityPacked(types, values));\n}",
      "doc": "Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "solidityPackedSha256",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPackedSha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _sha256(solidityPacked(types, values));\n}",
      "doc": "Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "TypedDataEncoder",
      "kind": "ClassDeclaration",
      "signature": "export class TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only rema",
      "doc": "A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\nfor signed typed data.\n\nThis is useful for those that wish to compute various components of a\ntyped data hash, primary types, or sub-components, but generally the\nhigher level [[Signer-signTypedData]] is more useful.",
      "tags": []
    },
    {
      "name": "verifyTypedData",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}",
      "doc": "Compute the address used to sign the typed data for the %%signature%%.",
      "tags": []
    },
    {
      "name": "getDefaultProvider",
      "kind": "FunctionDeclaration",
      "signature": "export function getDefaultProvider(network?: string | Networkish | WebSocketLike, options?: any): AbstractProvider {\n    if (options == null) { options = { }; }\n\n    const allowService = (name: string) => {\n        if (options[name] === \"-\") { return false; }\n        if (typeof(options.exclusive) ==",
      "doc": "Returns a default provider for %%network%%.\n\nIf %%network%% is a [[WebSocketLike]] or string that begins with\n``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\nby that WebSocket or URL.\n\nIf %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\na [[JsonRpcProvider]] is returned connected to that URL.\n\nOtherwise, a default provider is created backed by well-known public\nWeb3 backends (such as [[link-infura]]) using community-provided API\nkeys.\n\nThe %%options%% allows specifying custom API keys per backend (setting\nan API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\ncan be set to either a backend name or and array of backend names, which\nwill whitelist **only** those backends.\n\nCurrent backend strings supported are:\n- ``\"alchemy\"``\n- ``\"ankr\"``\n- ``\"cloudflare\"``\n- ``\"chainstack\"``\n- ``\"etherscan\"``\n- ``\"infura\"``\n- ``\"publicPolygon\"``\n- ``\"quicknode\"``",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Connect to a local Geth node\nprovider = getDefaultProvider(\"http://localhost:8545/\");\n\n// Connect to Ethereum mainnet with any current and future\n// third-party services available\nprovider = getDefaultProvider(\"mainnet\");\n\n// Connect to Polygon, but only allow Etherscan and\n// INFURA and use \"MY_API_KEY\" in calls to Etherscan.\nprovider = getDefaultProvider(\"matic\", {\netherscan: \"MY_API_KEY\",\nexclusive: [ \"etherscan\", \"infura\" ]\n});"
        }
      ]
    },
    {
      "name": "getDefaultProvider.#subs",
      "kind": "PropertyDeclaration",
      "signature": "#subs: Map<string, Sub>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#plugins",
      "kind": "PropertyDeclaration",
      "signature": "#plugins: Map<string, AbstractProviderPlugin>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#pausedState",
      "kind": "PropertyDeclaration",
      "signature": "#pausedState: null | boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#destroyed",
      "kind": "PropertyDeclaration",
      "signature": "#destroyed: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#networkPromise",
      "kind": "PropertyDeclaration",
      "signature": "#networkPromise: null | Promise<Network>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#anyNetwork",
      "kind": "PropertyDeclaration",
      "signature": "readonly #anyNetwork: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#performCache",
      "kind": "PropertyDeclaration",
      "signature": "#performCache: Map<string, Promise<any>>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#lastBlockNumber",
      "kind": "PropertyDeclaration",
      "signature": "#lastBlockNumber: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#nextTimer",
      "kind": "PropertyDeclaration",
      "signature": "#nextTimer: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#timers",
      "kind": "PropertyDeclaration",
      "signature": "#timers: Map<number, { timer: null | Timer, func: () => void, time: number }>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#disableCcipRead",
      "kind": "PropertyDeclaration",
      "signature": "#disableCcipRead: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#options",
      "kind": "PropertyDeclaration",
      "signature": "#options: Required<AbstractProviderOptions>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.pollingInterval",
      "kind": "GetAccessor",
      "signature": "get pollingInterval(): number { return this.#options.pollingInterval; }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.provider",
      "kind": "GetAccessor",
      "signature": "get provider(): this { return this; }",
      "doc": "Returns ``this``, to allow an **AbstractProvider** to implement\nthe [[ContractRunner]] interface.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.plugins",
      "kind": "GetAccessor",
      "signature": "get plugins(): Array<AbstractProviderPlugin> {\n        return Array.from(this.#plugins.values());\n    }",
      "doc": "Returns all the registered plug-ins.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.attachPlugin",
      "kind": "MethodDeclaration",
      "signature": "attachPlugin(plugin: AbstractProviderPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name,  plugin.connect(this));\n        return this;\n    }",
      "doc": "Attach a new plug-in.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getPlugin",
      "kind": "MethodDeclaration",
      "signature": "getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }",
      "doc": "Get a plugin by name.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.disableCcipRead",
      "kind": "GetAccessor",
      "signature": "get disableCcipRead(): boolean { return this.#disableCcipRead; }",
      "doc": "Prevent any CCIP-read operation, regardless of whether requested\nin a [[call]] using ``enableCcipRead``.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#perform",
      "kind": "MethodDeclaration",
      "signature": "async #perform<T = any>(req: PerformActionRequest): Promise<T> {\n        const timeout = this.#options.cacheTimeout;\n\n        // Caching disabled\n        if (timeout < 0) { return await this._perform(req); }\n\n        // Create a tag\n        const tag = getTag(req.method, req);\n\n        let perform =",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.ccipReadFetch",
      "kind": "MethodDeclaration",
      "signature": "async ccipReadFetch(tx: PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n     ",
      "doc": "Resolves to the data for executing the CCIP-read operations.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapBlock",
      "kind": "MethodDeclaration",
      "signature": "_wrapBlock(value: BlockParams, network: Network): Block {\n        return new Block(formatBlock(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a block before\nreturning it, to add additional properties or an alternate\nsub-class of [[Block]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapLog",
      "kind": "MethodDeclaration",
      "signature": "_wrapLog(value: LogParams, network: Network): Log {\n        return new Log(formatLog(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a log before\nreturning it, to add additional properties or an alternate\nsub-class of [[Log]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapTransactionReceipt",
      "kind": "MethodDeclaration",
      "signature": "_wrapTransactionReceipt(value: TransactionReceiptParams, network: Network): TransactionReceipt {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a transaction\nreceipt before returning it, to add additional properties or an\nalternate sub-class of [[TransactionReceipt]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapTransactionResponse",
      "kind": "MethodDeclaration",
      "signature": "_wrapTransactionResponse(tx: TransactionResponseParams, network: Network): TransactionResponse {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a transaction\nresponse before returning it, to add additional properties or an\nalternate sub-class of [[TransactionResponse]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._detectNetwork",
      "kind": "MethodDeclaration",
      "signature": "_detectNetwork(): Promise<Network> {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }",
      "doc": "Resolves to the Network, forcing a network detection using whatever\ntechnique the sub-class requires.\n\nSub-classes **must** override this.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._perform",
      "kind": "MethodDeclaration",
      "signature": "async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        assert(false, `unsupported method: ${ req.method }`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }",
      "doc": "Sub-classes should use this to perform all built-in operations. All\nmethods sanitizes and normalizes the values passed into this.\n\nSub-classes **must** override this.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBlockNumber",
      "kind": "MethodDeclaration",
      "signature": "async getBlockNumber(): Promise<number> {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) { this.#lastBlockNumber = blockNumber; }\n        return blockNumber;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getAddress",
      "kind": "MethodDeclaration",
      "signature": "_getAddress(address: AddressLike): string | Promise<string> {\n        return resolveAddress(address, this);\n    }",
      "doc": "Returns or resolves to the address for %%address%%, resolving ENS\nnames and [[Addressable]] objects and returning if already an\naddress.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getBlockTag",
      "kind": "MethodDeclaration",
      "signature": "_getBlockTag(blockTag?: BlockTag): string | Promise<string> {\n        if (blockTag == null) { return \"latest\"; }\n\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            ca",
      "doc": "Returns or resolves to a valid block tag for %%blockTag%%, resolving\nnegative values and returning if already a valid block tag.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getFilter",
      "kind": "MethodDeclaration",
      "signature": "_getFilter(filter: Filter | FilterByBlockHash): PerformActionFilter | Promise<PerformActionFilter> {\n\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || [ ]).map((t) => {\n            if (t == null) { return null; }\n            if (Array.isArray(t)) {\n",
      "doc": "Returns or resolves to a filter for %%filter%%, resolving any ENS\nnames or [[Addressable]] object and returning if already a valid\nfilter.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getTransactionRequest",
      "kind": "MethodDeclaration",
      "signature": "_getTransactionRequest(_request: TransactionRequest): PerformActionTransaction | Promise<PerformActionTransaction> {\n        const request = <PerformActionTransaction>copyRequest(_request);\n\n        const promises: Array<Promise<void>> = [ ];\n        [ \"to\", \"from\" ].forEach((key) => {\n            i",
      "doc": "Returns or resolves to a transaction for %%request%%, resolving\nany ENS names or [[Addressable]] and returning if already a valid\ntransaction.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getNetwork",
      "kind": "MethodDeclaration",
      "signature": "async getNetwork(): Promise<Network> {\n\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n            ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getFeeData",
      "kind": "MethodDeclaration",
      "signature": "async getFeeData(): Promise<FeeData> {\n        const network = await this.getNetwork();\n\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await resolveProperties({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((a",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.estimateGas",
      "kind": "MethodDeclaration",
      "signature": "async estimateGas(_tx: TransactionRequest): Promise<bigint> {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) { tx = await tx; }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#call",
      "kind": "MethodDeclaration",
      "signature": "async #call(tx: PerformActionTransaction, blockTag: string, attempt: number): Promise<string> {\n        assert (attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n             reason: \"TOO_MANY_REDIRECTS\",\n             transaction: Object.assign({ }, tx, { b",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#checkNetwork",
      "kind": "MethodDeclaration",
      "signature": "async #checkNetwork<T>(promise: Promise<T>): Promise<T> {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.call",
      "kind": "MethodDeclaration",
      "signature": "async call(_tx: TransactionRequest): Promise<string> {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getAccountValue",
      "kind": "MethodDeclaration",
      "signature": "async #getAccountValue(request: _PerformAccountRequest, _address: AddressLike, _blockTag?: BlockTag): Promise<any> {\n        let address: string | Promise<string> = this._getAddress(_address);\n        let blockTag: string | Promise<string> = this._getBlockTag(_blockTag);\n\n        if (typeof(address)",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBalance",
      "kind": "MethodDeclaration",
      "signature": "async getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint> {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionCount",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number> {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getCode",
      "kind": "MethodDeclaration",
      "signature": "async getCode(address: AddressLike, blockTag?: BlockTag): Promise<string> {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getStorage",
      "kind": "MethodDeclaration",
      "signature": "async getStorage(address: AddressLike, _position: BigNumberish, blockTag?: BlockTag): Promise<string> {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.broadcastTransaction",
      "kind": "MethodDeclaration",
      "signature": "async broadcastTransaction(signedTx: string): Promise<TransactionResponse> {\n        const { blockNumber, hash, network } = await resolveProperties({\n             blockNumber: this.getBlockNumber(),\n             hash: this._perform({\n                 method: \"broadcastTransaction\",\n                 ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getBlock",
      "kind": "MethodDeclaration",
      "signature": "async #getBlock(block: BlockTag | string, includeTransactions: boolean): Promise<any> {\n        // @TODO: Add CustomBlockPlugin check\n\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBlock",
      "kind": "MethodDeclaration",
      "signature": "async getBlock(block: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) { return nul",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransaction",
      "kind": "MethodDeclaration",
      "signature": "async getTransaction(hash: string): Promise<null | TransactionResponse> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) { return null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionReceipt",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionReceipt(hash: string): Promise<null | TransactionReceipt> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) {",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionResult",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionResult(hash: string): Promise<null | string> {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) { return null; }\n       ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getLogs",
      "kind": "MethodDeclaration",
      "signature": "async getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>> {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) { filter = await filter; }\n\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getProvider",
      "kind": "MethodDeclaration",
      "signature": "_getProvider(chainId: number): AbstractProvider {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getResolver",
      "kind": "MethodDeclaration",
      "signature": "async getResolver(name: string): Promise<null | EnsResolver> {\n        return await EnsResolver.fromName(this, name);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getAvatar",
      "kind": "MethodDeclaration",
      "signature": "async getAvatar(name: string): Promise<null | string> {\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAvatar(); }\n        return null;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.resolveName",
      "kind": "MethodDeclaration",
      "signature": "async resolveName(name: string): Promise<null | string>{\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAddress(); }\n        return null;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.lookupAddress",
      "kind": "MethodDeclaration",
      "signature": "async lookupAddress(address: string): Promise<null | string> {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n\n        try {\n\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.waitForTransaction",
      "kind": "MethodDeclaration",
      "signature": "async waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms != null) ? _confirms: 1;\n        if (confirms === 0) { return this.getTransactionReceipt(hash); }\n\n        return new Promise(async (re",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.waitForBlock",
      "kind": "MethodDeclaration",
      "signature": "async waitForBlock(blockTag?: BlockTag): Promise<Block> {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._clearTimeout",
      "kind": "MethodDeclaration",
      "signature": "_clearTimeout(timerId: number): void {\n        const timer = this.#timers.get(timerId);\n        if (!timer) { return; }\n        if (timer.timer) { clearTimeout(timer.timer); }\n        this.#timers.delete(timerId);\n    }",
      "doc": "Clear a timer created using the [[_setTimeout]] method.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._setTimeout",
      "kind": "MethodDeclaration",
      "signature": "_setTimeout(_func: () => void, timeout?: number): number {\n        if (timeout == null) { timeout = 0; }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n\n        if (this.paused) {\n            this.#tim",
      "doc": "Create a timer that will execute %%func%% after at least %%timeout%%\n(in ms). If %%timeout%% is unspecified, then %%func%% will execute\nin the next event loop.\n\n[Pausing](AbstractProvider-paused) the provider will pause any\nassociated timers.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._forEachSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_forEachSubscriber(func: (s: Subscriber) => void): void {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }",
      "doc": "Perform %%func%% on each subscriber.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new PollingBlockSubscri",
      "doc": "Sub-classes may override this to customize subscription\nimplementations.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._recoverSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) { sub.subscriber.stop(); }\n                sub.subscriber = newSub;\n                if (sub.started) { new",
      "doc": "If a [[Subscriber]] fails and needs to replace itself, this\nmethod may be used.\n\nFor example, this is used for providers when using the\n``eth_getFilterChanges`` method, which can return null if state\nfilters are not supported by the backend, allowing the Subscriber\nto swap in a [[PollingEventSubscriber]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#hasSub",
      "kind": "MethodDeclaration",
      "signature": "async #hasSub(event: ProviderEvent, emitArgs?: Array<any>): Promise<null | Sub> {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getSub",
      "kind": "MethodDeclaration",
      "signature": "async #getSub(event: ProviderEvent): Promise<Sub> {\n        const subscription = await getSubscription(event, this);\n\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n          ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.on",
      "kind": "MethodDeclaration",
      "signature": "async on(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.once",
      "kind": "MethodDeclaration",
      "signature": "async once(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.emit",
      "kind": "MethodDeclaration",
      "signature": "async emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean> {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.len",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.listenerCount",
      "kind": "MethodDeclaration",
      "signature": "async listenerCount(event?: ProviderEvent): Promise<number> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        let total = 0;\n        for (const { listeners } of this.#subs.values()",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.listeners",
      "kind": "MethodDeclaration",
      "signature": "async listeners(event?: ProviderEvent): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return  [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result: Array<Listener> = [ ];\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.off",
      "kind": "MethodDeclaration",
      "signature": "async off(event: ProviderEvent, listener?: Listener): Promise<this> {\n        const sub = await this.#hasSub(event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { su",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.removeAllListeners",
      "kind": "MethodDeclaration",
      "signature": "async removeAllListeners(event?: ProviderEvent): Promise<this> {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) { subscriber.stop(); }\n            this.#subs.delete(tag);\n        } else {\n            for (const [ tag, { start",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.addListener",
      "kind": "MethodDeclaration",
      "signature": "async addListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return await this.on(event, listener);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.removeListener",
      "kind": "MethodDeclaration",
      "signature": "async removeListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return this.off(event, listener);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.destroyed",
      "kind": "GetAccessor",
      "signature": "get destroyed(): boolean {\n        return this.#destroyed;\n    }",
      "doc": "If this provider has been destroyed using the [[destroy]] method.\n\nOnce destroyed, all resources are reclaimed, internal event loops\nand timers are cleaned up and no further requests may be sent to\nthe provider.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.destroy",
      "kind": "MethodDeclaration",
      "signature": "destroy(): void {\n        // Stop all listeners\n        this.removeAllListeners();\n\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n\n        this.#destroyed = true;\n    }",
      "doc": "Sub-classes may use this to shutdown any sockets or release their\nresources and reject any pending requests.\n\nSub-classes **must** call ``super.destroy()``.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.paused",
      "kind": "GetAccessor",
      "signature": "get paused(): boolean { return (this.#pausedState != null); }",
      "doc": "Whether the provider is currently paused.\n\nA paused provider will not emit any events, and generally should\nnot make any requests to the network, but that is up to sub-classes\nto manage.\n\nSetting ``paused = true`` is identical to calling ``.pause(false)``,\nwhich will buffer any events that occur while paused until the\nprovider is unpaused.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.pause",
      "kind": "MethodDeclaration",
      "signature": "pause(dropWhilePaused?: boolean): void {\n        this.#lastBlockNumber = -1;\n\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) { return; }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                op",
      "doc": "Pause the provider. If %%dropWhilePaused%%, any events that occur\nwhile paused are dropped, otherwise all events will be emitted once\nthe provider is unpaused.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.resume",
      "kind": "MethodDeclaration",
      "signature": "resume(): void {\n        if (this.#pausedState == null) { return; }\n\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n    ",
      "doc": "Resume the provider.",
      "tags": []
    },
    {
      "name": "Block",
      "kind": "ClassDeclaration",
      "signature": "export class Block implements BlockParams, Iterable<string> {\n\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  ",
      "doc": "A **Block** represents the data associated with a full block on\nEthereum.",
      "tags": []
    },
    {
      "name": "FeeData",
      "kind": "ClassDeclaration",
      "signature": "export class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    readonly gasPrice!: null | bigint;\n\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of",
      "doc": "A **FeeData** wraps all the fee-related values associated with\nthe network.",
      "tags": []
    },
    {
      "name": "Log",
      "kind": "ClassDeclaration",
      "signature": "export class Log implements LogParams {\n\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransacti",
      "doc": "A **Log** in Ethereum represents an event that has been included in a\ntransaction using the ``LOG*`` opcodes, which are most commonly used by\nSolidity's emit for announcing events.",
      "tags": []
    },
    {
      "name": "TransactionReceipt",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionReceipt implements TransactionReceiptParams, Iterable<Log> {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The address the transaction was sent to.\n     */\n  ",
      "doc": "A **TransactionReceipt** includes additional information about a\ntransaction that is only available after it has been mined.",
      "tags": []
    },
    {
      "name": "TransactionResponse",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionResponse implements TransactionLike<string>, TransactionResponseParams {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The bl",
      "doc": "A **TransactionResponse** includes all properties about a transaction\nthat was sent to the network, which may or may not be included in a\nblock.\n\nThe [[TransactionResponse-isMined]] can be used to check if the\ntransaction has been mined as well as type guard that the otherwise\npossibly ``null`` properties are defined.",
      "tags": []
    },
    {
      "name": "AbstractSigner",
      "kind": "ClassDeclaration",
      "signature": "export abstract class AbstractSigner<P extends null | Provider = null | Provider> implements Signer {\n    /**\n     *  The provider this signer is connected to.\n     */\n    readonly provider!: P;\n\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider?: P) {\n",
      "doc": "An **AbstractSigner** includes most of teh functionality required\nto get a [[Signer]] working as expected, but requires a few\nSigner-specific methods be overridden.",
      "tags": []
    },
    {
      "name": "NonceManager",
      "kind": "ClassDeclaration",
      "signature": "export class NonceManager extends AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer!: Signer;\n\n    #noncePromise: null | Promise<number>;\n    #delta: number;\n\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer: Signer) {\n  ",
      "doc": "A **NonceManager** wraps another [[Signer]] and automatically manages\nthe nonce, ensuring serialized and sequential nonces are used during\ntransaction.",
      "tags": []
    },
    {
      "name": "VoidSigner",
      "kind": "ClassDeclaration",
      "signature": "export class VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    readonly address!: string;\n\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address: string, provider?: null | Provider) {\n        ",
      "doc": "A **VoidSigner** is a class deisgned to allow an address to be used\nin any API which accepts a Signer, but for which there are no\ncredentials available to perform any actual signing.\n\nThis for example allow impersonating an account for the purpose of\nstatic calls or estimating gas, but does not allow sending transactions.",
      "tags": []
    },
    {
      "name": "AbstractProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AbstractProvider implements Provider {\n\n    #subs: Map<string, Sub>;\n    #plugins: Map<string, AbstractProviderPlugin>;\n\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState: null | boolean;\n\n    #destroyed: boolean;\n\n    #networkPromise: null | Promise<Netwo",
      "doc": "An **AbstractProvider** provides a base class for other sub-classes to\nimplement the [[Provider]] API by normalizing input arguments and\nformatting output results as well as tracking events for consistent\nbehaviour on an eventually-consistent network.",
      "tags": []
    },
    {
      "name": "FallbackProvider",
      "kind": "ClassDeclaration",
      "signature": "export class FallbackProvider extends AbstractProvider {\n\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    readonly quorum: number;\n\n    /**\n     *  @_ignore:\n     */\n    readonly eventQuorum: number;\n\n    /**\n     *  @_ignore:\n     */\n    ",
      "doc": "A **FallbackProvider** manages several [[Providers]] providing\nresilience by switching between slow or misbehaving nodes, security\nby requiring multiple backends to aggree and performance by allowing\nfaster backends to respond earlier.",
      "tags": []
    },
    {
      "name": "JsonRpcApiProvider",
      "kind": "ClassDeclaration",
      "signature": "export abstract class JsonRpcApiProvider extends AbstractProvider {\n\n    #options: Required<JsonRpcApiProviderOptions>;\n\n    // The next ID to use for the JSON-RPC ID field\n    #nextId: number;\n\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads: Array<Payload>;\n ",
      "doc": "The JsonRpcApiProvider is an abstract class and **MUST** be\nsub-classed.\n\nIt provides the base for all JSON-RPC-based Provider interaction.\n\nSub-classing Notes:\n- a sub-class MUST override _send\n- a sub-class MUST call the `_start()` method once connected",
      "tags": []
    },
    {
      "name": "JsonRpcProvider",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect: FetchRequest;\n\n    constructor(url?: string | FetchRequest, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        if (url == null) { url = \"http:/\\/localhost:8545\"; }\n        super(network, options);\n\n     ",
      "doc": "The JsonRpcProvider is one of the most common Providers,\nwhich performs all operations over HTTP (or HTTPS) requests.\n\nEvents are processed by polling the backend for the current block\nnumber; when it advances, all block-base events are then checked\nfor updates.",
      "tags": []
    },
    {
      "name": "JsonRpcSigner",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcSigner extends AbstractSigner<JsonRpcApiProvider> {\n    address!: string;\n\n    constructor(provider: JsonRpcApiProvider, address: string) {\n        super(provider);\n        address = getAddress(address);\n        defineProperties<JsonRpcSigner>(this, { address });\n    }\n\n    conne",
      "doc": "",
      "tags": []
    },
    {
      "name": "BrowserProvider",
      "kind": "ClassDeclaration",
      "signature": "export class BrowserProvider extends JsonRpcApiPollingProvider {\n    #request: (method: string, params: Array<any> | Record<string, any>) => Promise<any>;\n\n    #providerInfo: null | Eip6963ProviderInfo;\n\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%",
      "doc": "A **BrowserProvider** is intended to wrap an injected provider which\nadheres to the [[link-eip-1193]] standard, which most (if not all)\ncurrently do.",
      "tags": []
    },
    {
      "name": "AlchemyProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AlchemyProvider extends JsonRpcProvider implements CommunityResourcable {\n    readonly apiKey!: string;\n\n    constructor(_network?: Networkish, apiKey?: null | string) {\n        if (_network == null) { _network = \"mainnet\"; }\n        const network = Network.from(_network);\n        if (a",
      "doc": "The **AlchemyProvider** connects to the [[link-alchemy]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-alchemy-signup).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty"
        }
      ]
    },
    {
      "name": "AnkrProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AnkrProvider extends JsonRpcProvider implements CommunityResourcable {\n\n    /**\n     *  The API key for the Ankr connection.\n     */\n    readonly apiKey!: string;\n\n    /**\n     *  Create a new **AnkrProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n",
      "doc": "The **AnkrProvider** connects to the [[link-ankr]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-ankr-signup).",
      "tags": []
    },
    {
      "name": "BlockscoutProvider",
      "kind": "ClassDeclaration",
      "signature": "export class BlockscoutProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API key.\n     */\n    readonly apiKey!: null | string;\n\n    /**\n     *  Creates a new **BlockscoutProvider**.\n     */\n    constructor(_network?: Networkish, apiKey?: null | string) {\n        ",
      "doc": "The **BlockscoutProvider** connects to the [[link-blockscout]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-blockscout).",
      "tags": []
    },
    {
      "name": "ChainstackProvider",
      "kind": "ClassDeclaration",
      "signature": "export class ChainstackProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API key for the Chainstack connection.\n     */\n    readonly apiKey!: string;\n\n    /**\n     *  Creates a new **ChainstackProvider**.\n     */\n    constructor(_network?: Networkish, apiKey?: nu",
      "doc": "The **ChainstackProvider** connects to the [[link-chainstack]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-chainstack).",
      "tags": []
    },
    {
      "name": "CloudflareProvider",
      "kind": "ClassDeclaration",
      "signature": "export class CloudflareProvider extends JsonRpcProvider {\n    constructor(_network?: Networkish) {\n        if (_network == null) { _network = \"mainnet\"; }\n        const network = Network.from(_network);\n        assertArgument(network.name === \"mainnet\", \"unsupported network\", \"network\", _network);\n ",
      "doc": "About Cloudflare...",
      "tags": []
    },
    {
      "name": "EtherscanProvider",
      "kind": "ClassDeclaration",
      "signature": "export class EtherscanProvider extends AbstractProvider {\n\n    /**\n     *  The connected network.\n     */\n    readonly network!: Network;\n\n    /**\n     *  The API key or null if using the community provided bandwidth.\n     */\n    readonly apiKey!: null | string;\n\n    readonly #plugin: null | Ethersc",
      "doc": "The **EtherscanBaseProvider** is the super-class of\n[[EtherscanProvider]], which should generally be used instead.\n\nSince the **EtherscanProvider** includes additional code for\n[[Contract]] access, in //rare cases// that contracts are not\nused, this class can reduce code size.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "InfuraProvider",
      "kind": "ClassDeclaration",
      "signature": "export class InfuraProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    readonly projectId!: string;\n\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This should not\n  ",
      "doc": "The **InfuraProvider** connects to the [[link-infura]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-infura-signup).",
      "tags": []
    },
    {
      "name": "InfuraWebSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    readonly projectId!: string;\n\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This s",
      "doc": "The **InfuraWebSocketProvider** connects to the [[link-infura]]\nWebSocket end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-infura-signup).",
      "tags": []
    },
    {
      "name": "PocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class PocketProvider extends JsonRpcProvider implements CommunityResourcable {\n\n    /**\n     *  The Application ID for the Pocket connection.\n     */\n    readonly applicationId!: string;\n\n    /**\n     *  The Application Secret for making authenticated requests\n     *  to the Pocket connection",
      "doc": "The **PocketProvider** connects to the [[link-pocket]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-pocket-signup).",
      "tags": []
    },
    {
      "name": "QuickNodeProvider",
      "kind": "ClassDeclaration",
      "signature": "export class QuickNodeProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API token.\n     */\n    readonly token!: string;\n\n    /**\n     *  Creates a new **QuickNodeProvider**.\n     */\n    constructor(_network?: Networkish, token?: null | string) {\n        if (_netw",
      "doc": "The **QuickNodeProvider** connects to the [[link-quicknode]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API token is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-quicknode).",
      "tags": []
    },
    {
      "name": "IpcSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class IpcSocketProvider extends SocketProvider {\n    #socket: Socket;\n\n    /**\n     *  The connected socket.\n     */\n    get socket(): Socket { return this.#socket; }\n\n    constructor(path: string, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n ",
      "doc": "An **IpcSocketProvider** connects over an IPC socket on the host\nwhich provides fast access to the node, but requires the node and\nthe script run on the same machine.",
      "tags": []
    },
    {
      "name": "SocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class SocketProvider extends JsonRpcApiProvider {\n    #callbacks: Map<number, { payload: JsonRpcPayload, resolve: (r: any) => void, reject: (e: Error) => void }>;\n\n    // Maps each filterId to its subscriber\n    #subs: Map<number | string, SocketSubscriber>;\n\n    // If any events come in befo",
      "doc": "A **SocketProvider** is backed by a long-lived connection over a\nsocket, which can subscribe and receive real-time messages over\nits communication channel.",
      "tags": []
    },
    {
      "name": "WebSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class WebSocketProvider extends SocketProvider {\n    #connect: null | WebSocketCreator;\n\n    #websocket: null | WebSocketLike;\n    get websocket(): WebSocketLike {\n        if (this.#websocket == null) { throw new Error(\"websocket closed\"); }\n        return this.#websocket;\n    }\n\n    construc",
      "doc": "A JSON-RPC provider which is backed by a WebSocket.\n\nWebSockets are often preferred because they retain a live connection\nto a server, which permits more instant access to events.\n\nHowever, this incurs higher server infrasturture costs, so additional\nresources may be required to host your own WebSocket nodes and many\nthird-party services charge additional fees for WebSocket endpoints.",
      "tags": []
    },
    {
      "name": "EnsResolver",
      "kind": "ClassDeclaration",
      "signature": "export class EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider!: AbstractProvider;\n\n    /**\n     *  The address of the resolver.\n     */\n    address!: string;\n\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name!: string;\n\n    // For EIP-2544 names,",
      "doc": "A connected object to a resolved ENS name resolver, which can be\nused to query additional details.",
      "tags": []
    },
    {
      "name": "Network",
      "kind": "ClassDeclaration",
      "signature": "export class Network {\n    #name: string;\n    #chainId: bigint;\n\n    #plugins: Map<string, NetworkPlugin>;\n\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */\n    constructor(name: string, chainId: BigNumberish) {\n        this.#name = name;\n        this.#chainId = getBig",
      "doc": "A **Network** provides access to a chain's properties and allows\nfor plug-ins to extend functionality.",
      "tags": []
    },
    {
      "name": "EnsPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class EnsPlugin extends NetworkPlugin {\n\n    /**\n     *  The ENS Registrty Contract address.\n     */\n    readonly address!: string;\n\n    /**\n     *  The chain ID that the ENS contract lives on.\n     */\n    readonly targetNetwork!: number;\n\n    /**\n     *  Creates a new **EnsPlugin** connected",
      "doc": "An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\nContract address and the target network to use when using that\ncontract.\n\nVarious testnets have their own instance of the contract to use, but\nin general, the mainnet instance supports multi-chain addresses and\nshould be used.",
      "tags": []
    },
    {
      "name": "EtherscanPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class EtherscanPlugin extends NetworkPlugin {\n    /**\n     *  The Etherscan API base URL.\n     */\n    readonly baseUrl!: string;\n\n    /**\n     *  Creates a new **EtherscanProvider** which will use\n     *  %%baseUrl%%.\n     */\n    constructor(baseUrl: string) {\n        super(EtherscanPluginId)",
      "doc": "A Network can include an **EtherscanPlugin** to provide\na custom base URL.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "FeeDataNetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class FeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #feeDataFunc: (provider: Provider) => Promise<FeeData>;\n\n    /**\n     *  The fee data function provided to the constructor.\n     */\n    get feeDataFunc(): (provider: Provider) => Promise<FeeData> {\n        return this.#feeDataFun",
      "doc": "A **FeeDataNetworkPlugin** allows a network to provide and alternate\nmeans to specify its fee data.\n\nFor example, a network which does not support [[link-eip-1559]] may\nchoose to use a Gas Station site to approximate the gas price.",
      "tags": []
    },
    {
      "name": "FetchUrlFeeDataNetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #url: string;\n    readonly #processFunc: (f: () => Promise<FeeData>, p: Provider, r: FetchRequest) => Promise<{ gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint }>;\n\n    /**\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "GasCostPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class GasCostPlugin extends NetworkPlugin implements GasCostParameters {\n    /**\n     *  The block number to treat these values as valid from.\n     *\n     *  This allows a hardfork to have updated values included as well as\n     *  mulutiple hardforks to be supported.\n     */\n    readonly eff",
      "doc": "A **GasCostPlugin** allows a network to provide alternative values when\ncomputing the intrinsic gas required for a transaction.",
      "tags": []
    },
    {
      "name": "NetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class NetworkPlugin {\n    /**\n     *  The name of the plugin.\n     *\n     *  It is recommended to use reverse-domain-notation, which permits\n     *  unique names with a known authority as well as hierarchal entries.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **NetworkP",
      "doc": "A **NetworkPlugin** provides additional functionality on a [[Network]].",
      "tags": []
    },
    {
      "name": "MulticoinProviderPlugin",
      "kind": "ClassDeclaration",
      "signature": "export abstract class MulticoinProviderPlugin implements AbstractProviderPlugin {\n    /**\n     *  The name.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name: string) {\n        defineProperties<MulticoinProviderP",
      "doc": "A provider plugin super-class for processing multicoin address types.",
      "tags": []
    },
    {
      "name": "SocketBlockSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newHeads\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"block\", parseInt",
      "doc": "A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n``\"block\"`` events.",
      "tags": []
    },
    {
      "name": "SocketEventSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketEventSubscriber extends SocketSubscriber {\n    #logFilter: string;\n\n    /**\n     *  The filter.\n     */\n    get logFilter(): EventFilter { return JSON.parse(this.#logFilter); }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider, filter: EventFilter) {\n    ",
      "doc": "A **SocketEventSubscriber** listens for event logs.",
      "tags": []
    },
    {
      "name": "SocketPendingSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketPendingSubscriber extends SocketSubscriber {\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newPendingTransactions\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(",
      "doc": "A **SocketPendingSubscriber** listens for pending transacitons and emits\n``\"pending\"`` events.",
      "tags": []
    },
    {
      "name": "SocketSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketSubscriber implements Subscriber {\n    #provider: SocketProvider;\n\n    #filter: string;\n\n    /**\n     *  The filter.\n     */\n    get filter(): Array<any> { return JSON.parse(this.#filter); }\n\n    #filterId: null | Promise<string |number>;\n    #paused: null | boolean;\n\n    #emitPro",
      "doc": "A **SocketSubscriber** uses a socket transport to handle events and\nshould use [[_emit]] to manage the events.",
      "tags": []
    },
    {
      "name": "UnmanagedSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class UnmanagedSubscriber implements Subscriber {\n    /**\n     *  The name fof the event.\n     */\n    name!: string;\n\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name: string) { defineProperties<UnmanagedSubscriber>(this, { name }); }\n\n    start(): ",
      "doc": "An **UnmanagedSubscriber** is useful for events which do not require\nany additional management, such as ``\"debug\"`` which only requires\nemit in synchronous event loop triggered calls.",
      "tags": []
    },
    {
      "name": "copyRequest",
      "kind": "FunctionDeclaration",
      "signature": "export function copyRequest(req: TransactionRequest): PreparedTransactionRequest {\n    const result: any = { };\n\n    // These could be addresses, ENS names or Addressables\n    if (req.to) { result.to = req.to; }\n    if (req.from) { result.from = req.from; }\n\n    if (req.data) { result.data = hexlify",
      "doc": "Returns a copy of %%req%% with all properties coerced to their strict\ntypes.",
      "tags": []
    },
    {
      "name": "copyRequest.type",
      "kind": "PropertySignature",
      "signature": "type?: number;",
      "doc": "The transaction type.",
      "tags": []
    },
    {
      "name": "copyRequest.to",
      "kind": "PropertySignature",
      "signature": "to?: AddressLike;",
      "doc": "The target of the transaction.",
      "tags": []
    },
    {
      "name": "copyRequest.from",
      "kind": "PropertySignature",
      "signature": "from?: AddressLike;",
      "doc": "The sender of the transaction.",
      "tags": []
    },
    {
      "name": "copyRequest.nonce",
      "kind": "PropertySignature",
      "signature": "nonce?: number;",
      "doc": "The nonce of the transaction, used to prevent replay attacks.",
      "tags": []
    },
    {
      "name": "copyRequest.gasLimit",
      "kind": "PropertySignature",
      "signature": "gasLimit?: bigint;",
      "doc": "The maximum amount of gas to allow this transaction to consume.",
      "tags": []
    },
    {
      "name": "copyRequest.gasPrice",
      "kind": "PropertySignature",
      "signature": "gasPrice?: bigint;",
      "doc": "The gas price to use for legacy transactions or transactions on\nlegacy networks.\n\nMost of the time the ``max*FeePerGas`` is preferred.",
      "tags": []
    },
    {
      "name": "copyRequest.maxPriorityFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxPriorityFeePerGas?: bigint;",
      "doc": "The [[link-eip-1559]] maximum priority fee to pay per gas.",
      "tags": []
    },
    {
      "name": "copyRequest.maxFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxFeePerGas?: bigint;",
      "doc": "The [[link-eip-1559]] maximum total fee to pay per gas. The actual\nvalue used is protocol enforced to be the block's base fee.",
      "tags": []
    },
    {
      "name": "copyRequest.data",
      "kind": "PropertySignature",
      "signature": "data?: string;",
      "doc": "The transaction data.",
      "tags": []
    },
    {
      "name": "copyRequest.value",
      "kind": "PropertySignature",
      "signature": "value?: bigint;",
      "doc": "The transaction value (in wei).",
      "tags": []
    },
    {
      "name": "copyRequest.chainId",
      "kind": "PropertySignature",
      "signature": "chainId?: bigint;",
      "doc": "The chain ID for the network this transaction is valid on.",
      "tags": []
    },
    {
      "name": "copyRequest.accessList",
      "kind": "PropertySignature",
      "signature": "accessList?: AccessList;",
      "doc": "The [[link-eip-2930]] access list. Storage slots included in the access\nlist are //warmed// by pre-loading them, so their initial cost to\nfetch is guaranteed, but then each additional access is cheaper.",
      "tags": []
    },
    {
      "name": "copyRequest.authorizationList",
      "kind": "PropertySignature",
      "signature": "authorizationList?: Array<Authorization>;",
      "doc": "The [[link-eip-7702]] authorizations (if any).",
      "tags": []
    },
    {
      "name": "copyRequest.customData",
      "kind": "PropertySignature",
      "signature": "customData?: any;",
      "doc": "A custom object, which can be passed along for network-specific\nvalues.",
      "tags": []
    },
    {
      "name": "copyRequest.blockTag",
      "kind": "PropertySignature",
      "signature": "blockTag?: BlockTag;",
      "doc": "When using ``call`` or ``estimateGas``, this allows a specific\nblock to be queried. Many backends do not support this and when\nunsupported errors are silently squelched and ``\"latest\"`` is used.",
      "tags": []
    },
    {
      "name": "copyRequest.enableCcipRead",
      "kind": "PropertySignature",
      "signature": "enableCcipRead?: boolean;",
      "doc": "When using ``call``, this enables CCIP-read, which permits the\nprovider to be redirected to web-based content during execution,\nwhich is then further validated by the contract.\n\nThere are potential security implications allowing CCIP-read, as\nit could be used to expose the IP address or user activity during\nthe fetch to unexpected parties.",
      "tags": []
    },
    {
      "name": "showThrottleMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function showThrottleMessage(service: string): void {\n    if (shown.has(service)) { return; }\n    shown.add(service);\n\n    console.log(\"========= NOTICE =========\")\n    console.log(`Request-Rate Exceeded for ${ service } (this message will not be repeated)`);\n    console.log(\"\");\n    console.",
      "doc": "Displays a warning in the console when the community resource is\nbeing used too heavily by the app, recommending the developer\nacquire their own credentials instead of using the community\ncredentials.\n\nThe notification will only occur once per service.",
      "tags": []
    },
    {
      "name": "accessListify",
      "kind": "FunctionDeclaration",
      "signature": "export function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.le",
      "doc": "Returns a [[AccessList]] from any ethers-supported access-list structure.",
      "tags": []
    },
    {
      "name": "accessListify.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "authorizationify",
      "kind": "FunctionDeclaration",
      "signature": "export function authorizationify(auth: AuthorizationLike): Authorization {\n    return {\n        address: getAddress(auth.address),\n        nonce: getBigInt((auth.nonce != null) ? auth.nonce: 0),\n        chainId: getBigInt((auth.chainId != null)? auth.chainId: 0),\n        signature: Signature.from(au",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.address",
      "kind": "PropertySignature",
      "signature": "address: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.nonce",
      "kind": "PropertySignature",
      "signature": "nonce: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.chainId",
      "kind": "PropertySignature",
      "signature": "chainId: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.signature",
      "kind": "PropertySignature",
      "signature": "signature: Signature;",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function computeAddress(key: string | SigningKey): string {\n    let pubkey: string;\n    if (typeof(key) === \"string\") {\n        pubkey = SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).subs",
      "doc": "Returns the address for the %%key%%.\n\nThe key may be any standard form of public key or a private key.",
      "tags": []
    },
    {
      "name": "recoverAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\n}",
      "doc": "Returns the recovered address for the private key that was\nused to sign %%digest%% that resulted in %%signature%%.",
      "tags": []
    },
    {
      "name": "Transaction",
      "kind": "ClassDeclaration",
      "signature": "export class Transaction implements TransactionLike<string> {\n    #type: null | number;\n    #to: null | string;\n    #data: string;\n    #nonce: number;\n    #gasLimit: bigint;\n    #gasPrice: null | bigint;\n    #maxPriorityFeePerGas: null | bigint;\n    #maxFeePerGas: null | bigint;\n    #value: bigint;\n",
      "doc": "A **Transaction** describes an operation to be executed on\nEthereum by an Externally Owned Account (EOA). It includes\nwho (the [[to]] address), what (the [[data]]) and how much (the\n[[value]] in ether) the operation should entail.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\ntx = new Transaction()\n//_result:\n\ntx.data = \"0x1234\";\n//_result:"
        }
      ]
    },
    {
      "name": "decodeBase58",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase58(value: string): bigint {\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}",
      "doc": "Decode the Base58-encoded %%value%%.",
      "tags": []
    },
    {
      "name": "encodeBase58",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase58(_value: BytesLike): string {\n    const bytes = getBytes(_value);\n\n    let value = toBigInt(bytes);\n    let result = \"\";\n    while (value) {\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n\n    // Account for leading padding zeros\n",
      "doc": "Encode %%value%% as a Base58-encoded string.",
      "tags": []
    },
    {
      "name": "decodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase64(value: string): Uint8Array {\n    return getBytesCopy(Buffer.from(value, \"base64\"));\n}",
      "doc": "Decodes the base-64 encoded %%value%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// The decoded value is always binary data...\nresult = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n//_result:\n\n// ...use toUtf8String to convert it to a string.\ntoUtf8String(result)\n//_result:\n\n// Decoding binary data\ndecodeBase64(\"EjQ=\")\n//_result:"
        }
      ]
    },
    {
      "name": "decodeBase64.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "encodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase64(data: BytesLike): string {\n    return Buffer.from(getBytes(data)).toString(\"base64\");\n}",
      "doc": "Encodes %%data%% as a base-64 encoded string.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Encoding binary data as a hexstring\nencodeBase64(\"0x1234\")\n//_result:\n\n// Encoding binary data as a Uint8Array\nencodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n//_result:\n\n// The input MUST be data...\nencodeBase64(\"Hello World!!\")\n//_error:\n\n// ...use toUtf8Bytes for this.\nencodeBase64(toUtf8Bytes(\"Hello World!!\"))\n//_result:"
        }
      ]
    },
    {
      "name": "concat",
      "kind": "FunctionDeclaration",
      "signature": "export function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}",
      "doc": "Returns a [[DataHexString]] by concatenating all values\nwithin %%data%%.",
      "tags": []
    },
    {
      "name": "dataLength",
      "kind": "FunctionDeclaration",
      "signature": "export function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}",
      "doc": "Returns the length of %%data%%, in bytes.",
      "tags": []
    },
    {
      "name": "dataSlice",
      "kind": "FunctionDeclaration",
      "signature": "export function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n",
      "doc": "Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\noffset to the %%end%% offset.\n\nBy default %%start%% is 0 and %%end%% is the length of %%data%%.",
      "tags": []
    },
    {
      "name": "getBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}",
      "doc": "Get a typed Uint8Array for %%value%%. If already a Uint8Array\nthe original %%value%% is returned; if a copy is required use\n[[getBytesCopy]].",
      "tags": [
        {
          "tagName": "see",
          "text": ": getBytesCopy"
        }
      ]
    },
    {
      "name": "getBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "getBytesCopy",
      "kind": "FunctionDeclaration",
      "signature": "export function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}",
      "doc": "Get a typed Uint8Array for %%value%%, creating a copy if necessary\nto prevent any modifications of the returned value from being\nreflected elsewhere.",
      "tags": [
        {
          "tagName": "see",
          "text": ": getBytes"
        }
      ]
    },
    {
      "name": "getBytesCopy.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "hexlify",
      "kind": "FunctionDeclaration",
      "signature": "export function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}",
      "doc": "Returns a [[DataHexString]] representation of %%data%%.",
      "tags": []
    },
    {
      "name": "isHexString",
      "kind": "FunctionDeclaration",
      "signature": "export function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (lengt",
      "doc": "Returns true if %%value%% is a valid [[HexString]].\n\nIf %%length%% is ``true`` or a //number//, it also checks that\n%%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\nbytes of data (e.g. ``0x1234`` is 2 bytes).",
      "tags": []
    },
    {
      "name": "isBytesLike",
      "kind": "FunctionDeclaration",
      "signature": "export function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}",
      "doc": "Returns true if %%value%% is a valid representation of arbitrary\ndata (i.e. a valid [[DataHexString]] or a Uint8Array).",
      "tags": []
    },
    {
      "name": "stripZerosLeft",
      "kind": "FunctionDeclaration",
      "signature": "export function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}",
      "doc": "Return the [[DataHexString]] result by stripping all **leading**\n* zero bytes from %%data%%.",
      "tags": []
    },
    {
      "name": "zeroPadBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}",
      "doc": "Return the [[DataHexString]] of %%data%% padded on the **right**\nto %%length%% bytes.\n\nIf %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\nthrown.\n\nThis pads data the same as **bytes** are in Solidity\n(e.g. ``bytes16``).",
      "tags": []
    },
    {
      "name": "zeroPadValue",
      "kind": "FunctionDeclaration",
      "signature": "export function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}",
      "doc": "Return the [[DataHexString]] of %%data%% padded on the **left**\nto %%length%% bytes.\n\nIf %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\nthrown.\n\nThis pads data the same as **values** are in Solidity\n(e.g. ``uint128``).",
      "tags": []
    },
    {
      "name": "defineProperties",
      "kind": "FunctionDeclaration",
      "signature": "export function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n",
      "doc": "Assigns the %%values%% to %%target%% as read-only values.\n\nIt %%types%% is specified, the values are checked.",
      "tags": []
    },
    {
      "name": "resolveProperties",
      "kind": "FunctionDeclaration",
      "signature": "export async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        ac",
      "doc": "Resolves to a new object that is a copy of %%value%%, but with all\nvalues resolved.",
      "tags": []
    },
    {
      "name": "resolveProperties.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "assert",
      "kind": "FunctionDeclaration",
      "signature": "export function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}",
      "doc": "Throws an EthersError with %%message%%, %%code%% and additional error\n%%info%% when %%check%% is falsish..",
      "tags": [
        {
          "tagName": "see",
          "text": "[[api:makeError]]"
        }
      ]
    },
    {
      "name": "assertArgument",
      "kind": "FunctionDeclaration",
      "signature": "export function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}",
      "doc": "A simple helper to simply ensuring provided arguments match expected\nconstraints, throwing if not.\n\nIn TypeScript environments, the %%check%% has been asserted true, so\nany further code does not need additional compile-time checks.",
      "tags": []
    },
    {
      "name": "assertArgumentCount",
      "kind": "FunctionDeclaration",
      "signature": "export function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n",
      "doc": "",
      "tags": []
    },
    {
      "name": "assertNormalize",
      "kind": "FunctionDeclaration",
      "signature": "export function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}",
      "doc": "Throws if the normalization %%form%% is not supported.",
      "tags": []
    },
    {
      "name": "assertPrivate",
      "kind": "FunctionDeclaration",
      "signature": "export function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + ",
      "doc": "Many classes use file-scoped values to guard the constructor,\nmaking it effectively private. This facilitates that pattern\nby ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\nthrowing if not, indicating the %%className%% if provided.",
      "tags": []
    },
    {
      "name": "makeError",
      "kind": "FunctionDeclaration",
      "signature": "export function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    let shortMessage = message;\n\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in inf",
      "doc": "Returns a new Error configured to the format ethers emits errors, with\nthe %%message%%, [[api:ErrorCode]] %%code%% and additional properties\nfor the corresponding EthersError.\n\nEach error in ethers includes the version of ethers, a\nmachine-readable [[ErrorCode]], and depending on %%code%%, additional\nrequired properties. The error message will also include the %%message%%,\nethers version, %%code%% and all additional properties, serialized.",
      "tags": []
    },
    {
      "name": "makeError.code",
      "kind": "PropertySignature",
      "signature": "code: ErrorCode;",
      "doc": "The string error code.",
      "tags": []
    },
    {
      "name": "makeError.shortMessage",
      "kind": "PropertySignature",
      "signature": "shortMessage: string;",
      "doc": "A short message describing the error, with minimal additional\ndetails.",
      "tags": []
    },
    {
      "name": "makeError.info",
      "kind": "PropertySignature",
      "signature": "info?: Record<string, any>;",
      "doc": "Additional info regarding the error that may be useful.\n\nThis is generally helpful mostly for human-based debugging.",
      "tags": []
    },
    {
      "name": "makeError.error",
      "kind": "PropertySignature",
      "signature": "error?: Error;",
      "doc": "Any related error.",
      "tags": []
    },
    {
      "name": "makeError.name",
      "kind": "PropertySignature",
      "signature": "name:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeError.message",
      "kind": "PropertySignature",
      "signature": "message:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeError.stack",
      "kind": "PropertySignature",
      "signature": "stack?:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isCallException",
      "kind": "FunctionDeclaration",
      "signature": "export function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}",
      "doc": "Returns true if %%error%% is a [[CallExceptionError].",
      "tags": []
    },
    {
      "name": "isError",
      "kind": "FunctionDeclaration",
      "signature": "export function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}",
      "doc": "Returns true if the %%error%% matches an error thrown by ethers\nthat matches the error %%code%%.\n\nIn TypeScript environments, this can be used to check that %%error%%\nmatches an EthersError type, which means the expected properties will\nbe set.",
      "tags": [
        {
          "tagName": "See",
          "text": "[ErrorCodes](api:ErrorCode)"
        },
        {
          "tagName": "example",
          "text": "  try {\n    // code....\n  } catch (e) {\n    if (isError(e, \"CALL_EXCEPTION\")) {\n        // The Type Guard has validated this object\n        console.log(e.data);\n    }\n  }"
        }
      ]
    },
    {
      "name": "EventPayload",
      "kind": "ClassDeclaration",
      "signature": "export class EventPayload<T> {\n    /**\n     *  The event filter.\n     */\n    readonly filter!: T;\n\n    /**\n     *  The **EventEmitterable**.\n     */\n    readonly emitter!: EventEmitterable<T>;\n\n    readonly #listener: null | Listener;\n\n    /**\n     *  Create a new **EventPayload** for %%emitter%% wi",
      "doc": "When an [[EventEmitterable]] triggers a [[Listener]], the\ncallback always ahas one additional argument passed, which is\nan **EventPayload**.",
      "tags": []
    },
    {
      "name": "FetchRequest",
      "kind": "ClassDeclaration",
      "signature": "export class FetchRequest implements Iterable<[ key: string, value: string ]> {\n    #allowInsecure: boolean;\n    #gzip: boolean;\n    #headers: Record<string, string>;\n    #method: string;\n    #timeout: number;\n    #url: string;\n\n    #body?: Uint8Array;\n    #bodyType?: string;\n    #creds?: string;\n\n ",
      "doc": "Represents a request for a resource using a URI.\n\nBy default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\nand ``IPFS:``.\n\nAdditional schemes can be added globally using [[registerGateway]].",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nreq = new FetchRequest(\"https://www.ricmoo.com\")\nresp = await req.send()\nresp.body.length\n//_result:"
        }
      ]
    },
    {
      "name": "FetchResponse",
      "kind": "ClassDeclaration",
      "signature": "export class FetchResponse implements Iterable<[ key: string, value: string ]> {\n    #statusCode: number;\n    #statusMessage: string;\n    #headers: Record<string, string>;\n    #body: null | Readonly<Uint8Array>;\n    #request: null | FetchRequest;\n\n    #error: { error?: Error, message: string };\n\n   ",
      "doc": "The response for a FetchRequest.",
      "tags": []
    },
    {
      "name": "FetchCancelSignal",
      "kind": "ClassDeclaration",
      "signature": "export class FetchCancelSignal {\n    #listeners: Array<() => void>;\n    #cancelled: boolean;\n\n    constructor(request: FetchRequest) {\n        this.#listeners = [ ];\n        this.#cancelled = false;\n\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) { return; }\n            t",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "FixedNumber",
      "kind": "ClassDeclaration",
      "signature": "export class FixedNumber {\n\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    readonly format!: string;\n\n    readonly #format: _FixedFormat;\n\n    // The actual value (accounting for decimals)\n    #val: bigint;\n\n    // A base-10 value to multiple values by to maint",
      "doc": "A FixedNumber represents a value over its [[FixedFormat]]\narithmetic field.\n\nA FixedNumber can be used to perform math, losslessly, on\nvalues which have decmial places.\n\nA FixedNumber has a fixed bit-width to store values in, and stores all\nvalues internally by multiplying the value by 10 raised to the power of\n%%decimals%%.\n\nIf operations are performed that cause a value to grow too high (close to\npositive infinity) or too low (close to negative infinity), the value\nis said to //overflow//.\n\nFor example, an 8-bit signed value, with 0 decimals may only be within\nthe range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n\nMany operation have a normal and //unsafe// variant. The normal variant\nwill throw a [[NumericFaultError]] on any overflow, while the //unsafe//\nvariant will silently allow overflow, corrupting its value value.\n\nIf operations are performed that cause a value to become too small\n(close to zero), the value loses precison and is said to //underflow//.\n\nFor example, a value with 1 decimal place may store a number as small\nas ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\ninto 1 decimal place, so underflow occurs which means precision is lost\nand the value becomes ``0``.\n\nSome operations have a normal and //signalling// variant. The normal\nvariant will silently ignore underflow, while the //signalling// variant\nwill thow a [[NumericFaultError]] on underflow.",
      "tags": []
    },
    {
      "name": "getBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && ",
      "doc": "Gets a BigInt from %%value%%. If it is an invalid value for\na BigInt, then an ArgumentError will be thrown for %%name%%.",
      "tags": []
    },
    {
      "name": "getNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            as",
      "doc": "Gets a //number// from %%value%%. If it is an invalid value for\na //number//, then an ArgumentError will be thrown for %%name%%.",
      "tags": []
    },
    {
      "name": "getUint",
      "kind": "FunctionDeclaration",
      "signature": "export function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}",
      "doc": "Returns %%value%% as a bigint, validating it is valid as a bigint\nvalue and that it is positive.",
      "tags": []
    },
    {
      "name": "toBeArray",
      "kind": "FunctionDeclaration",
      "signature": "export function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    f",
      "doc": "Converts %%value%% to a Big Endian Uint8Array.",
      "tags": []
    },
    {
      "name": "toBeArray.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeHex",
      "kind": "FunctionDeclaration",
      "signature": "export function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n",
      "doc": "Converts %%value%% to a Big Endian hexstring, optionally padded to\n%%width%% bytes.",
      "tags": []
    },
    {
      "name": "toNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}",
      "doc": "Converts %%value%% to a number. If %%value%% is a Uint8Array, it\nis treated as Big Endian data. Throws if the value is not safe.",
      "tags": []
    },
    {
      "name": "toQuantity",
      "kind": "FunctionDeclaration",
      "signature": "export function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}",
      "doc": "Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n\nA //Quantity// does not have and leading 0 values unless the value is\nthe literal value `0x0`. This is most commonly used for JSSON-RPC\nnumeric values.",
      "tags": []
    },
    {
      "name": "fromTwos",
      "kind": "FunctionDeclaration",
      "signature": "export function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _",
      "doc": "Convert %%value%% from a twos-compliment representation of %%width%%\nbits to its value.\n\nIf the highest bit is ``1``, the result will be negative.",
      "tags": []
    },
    {
      "name": "toTwos",
      "kind": "FunctionDeclaration",
      "signature": "export function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too ",
      "doc": "Convert %%value%% to a twos-compliment representation of\n%%width%% bits.\n\nThe result will always be positive.",
      "tags": []
    },
    {
      "name": "mask",
      "kind": "FunctionDeclaration",
      "signature": "export function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}",
      "doc": "Mask %%value%% with a bitmask of %%bits%% ones.",
      "tags": []
    },
    {
      "name": "formatEther",
      "kind": "FunctionDeclaration",
      "signature": "export function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}",
      "doc": "Converts %%value%% into a //decimal string// using 18 decimal places.",
      "tags": []
    },
    {
      "name": "parseEther",
      "kind": "FunctionDeclaration",
      "signature": "export function parseEther(ether: string): bigint {\n    return parseUnits(ether, 18);\n}",
      "doc": "Converts the //decimal string// %%ether%% to a BigInt, using 18\ndecimal places.",
      "tags": []
    },
    {
      "name": "formatUnits",
      "kind": "FunctionDeclaration",
      "signature": "export function formatUnits(value: BigNumberish, unit?: string | Numeric): string {\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (un",
      "doc": "Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\nplaces. The %%unit%% may be the number of decimal places or the name of\na unit (e.g. ``\"gwei\"`` for 9 decimal places).",
      "tags": []
    },
    {
      "name": "parseUnits",
      "kind": "FunctionDeclaration",
      "signature": "export function parseUnits(value: string, unit?: string | Numeric): bigint {\n    assertArgument(typeof(value) === \"string\", \"value must be a string\", \"value\", value);\n\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index ",
      "doc": "Converts the //decimal string// %%value%% to a BigInt, assuming\n%%unit%% decimal places. The %%unit%% may the number of decimal places\nor the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).",
      "tags": []
    },
    {
      "name": "toUtf8Bytes",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array {\n    assertArgument(typeof(str) === \"string\", \"invalid string value\", \"str\", str);\n\n    if (form != null) {\n        assertNormalize(form);\n        str = str.normalize(form);\n    }\n\n    let result: Array<number> = ",
      "doc": "Returns the UTF-8 byte representation of %%str%%.\n\nIf %%form%% is specified, the string is normalized.",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8CodePoints(str: string, form?: UnicodeNormalizationForm): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}",
      "doc": "Returns the UTF-8 code-points for %%str%%.\n\nIf %%form%% is specified, the string is normalized.",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toUtf8String",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}",
      "doc": "Returns the string represented by the UTF-8 data %%bytes%%.\n\nWhen %%onError%% function is specified, it is called on UTF-8\nerrors allowing recovery using the [[Utf8ErrorFunc]] API.\n(default: [error](Utf8ErrorFuncs))",
      "tags": []
    },
    {
      "name": "Utf8ErrorFuncs",
      "kind": "VariableDeclaration",
      "signature": "Utf8ErrorFuncs: Readonly<Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>> = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeRlp(_data: BytesLike): RlpStructuredData {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}",
      "doc": "Decodes %%data%% into the structured data it represents.",
      "tags": []
    },
    {
      "name": "encodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeRlp(object: RlpStructuredDataish): string {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}",
      "doc": "Encodes %%object%% as an RLP-encoded [[DataHexString]].",
      "tags": []
    },
    {
      "name": "uuidV4",
      "kind": "FunctionDeclaration",
      "signature": "export function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - cloc",
      "doc": "Returns the version 4 [[link-uuid]] for the %%randomBytes%%.",
      "tags": [
        {
          "tagName": "see",
          "text": ": https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)"
        }
      ]
    },
    {
      "name": "Mnemonic",
      "kind": "ClassDeclaration",
      "signature": "export class Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    readonly phrase!: string;\n\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     * ",
      "doc": "A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\nseeds and convert between phrases and entropy.",
      "tags": []
    },
    {
      "name": "BaseWallet",
      "kind": "ClassDeclaration",
      "signature": "export class BaseWallet extends AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    readonly address!: string;\n\n    readonly #signingKey: SigningKey;\n\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%",
      "doc": "The **BaseWallet** is a stream-lined implementation of a\n[[Signer]] that operates with a private key.\n\nIt is preferred to use the [[Wallet]] class, as it offers\nadditional functionality and simplifies loading a variety\nof JSON formats, Mnemonic Phrases, etc.\n\nThis class may be of use for those attempting to implement\na minimal Signer.",
      "tags": []
    },
    {
      "name": "HDNodeWallet",
      "kind": "ClassDeclaration",
      "signature": "export class HDNodeWallet extends BaseWallet {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with ",
      "doc": "An **HDNodeWallet** is a [[Signer]] backed by the private key derived\nfrom an HD Node using the [[link-bip-32]] stantard.\n\nAn HD Node forms a hierarchal structure with each HD Node having a\nprivate key and the ability to derive child HD Nodes, defined by\na path indicating the index of each child.",
      "tags": []
    },
    {
      "name": "HDNodeVoidWallet",
      "kind": "ClassDeclaration",
      "signature": "export class HDNodeVoidWallet extends VoidSigner {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal w",
      "doc": "A **HDNodeVoidWallet** cannot sign, but provides access to\nthe children nodes of a [[link-bip-32]] HD wallet addresses.\n\nThe can be created by using an extended ``xpub`` key to\n[[HDNodeWallet_fromExtendedKey]] or by \n[nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].",
      "tags": []
    },
    {
      "name": "Wallet",
      "kind": "ClassDeclaration",
      "signature": "export class Wallet extends BaseWallet {\n\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */\n    constructor(key: string | SigningKey, provider?: null | Provider) {\n        if (typeof(key) === \"string\" && !key.startsWith(\"0x\")) {\n      ",
      "doc": "A **Wallet** manages a single private key which is used to sign\ntransactions, messages and other common payloads.\n\nThis class is generally the main entry point for developers\nthat wish to use a private key directly, as it can create\ninstances from a large variety of common sources, including\nraw private key, [[link-bip-39]] mnemonics and encrypte JSON\nwallets.",
      "tags": []
    },
    {
      "name": "defaultPath",
      "kind": "VariableDeclaration",
      "signature": "defaultPath: string = \"m/44'/60'/0'/0/0\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAccountPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${ index }'/0/0`;\n}",
      "doc": "Returns the [[link-bip-32]] path for the account at %%index%%.\n\nThis is the pattern used by wallets like Ledger.\n\nThere is also an [alternate pattern](getIndexedAccountPath) used by\nsome software.",
      "tags": []
    },
    {
      "name": "getIndexedAccountPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getIndexedAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${ index}`;\n}",
      "doc": "Returns the path using an alternative pattern for deriving accounts,\nat %%index%%.\n\nThis derivation path uses the //index// component rather than the\n//account// component to derive sequential accounts.\n\nThis is the pattern used by wallets like MetaMask.",
      "tags": []
    },
    {
      "name": "isCrowdsaleJson",
      "kind": "FunctionDeclaration",
      "signature": "export function isCrowdsaleJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) { return true; }\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%json%% is a valid JSON Crowdsale wallet.",
      "tags": []
    },
    {
      "name": "isKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export function isKeystoreJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version): 0);\n        if (version === 3) { return true; }\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%json%% is a valid JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "decryptCrowdsaleJson",
      "kind": "FunctionDeclaration",
      "signature": "export function decryptCrowdsaleJson(json: string, _password: string | Uint8Array): CrowdsaleAccount {\n    const data = JSON.parse(json);\n    const password = getPassword(_password);\n\n    // Ethereum Address\n    const address = getAddress(spelunk(data, \"ethaddr:string!\"));\n\n    // Encrypted Seed\n   ",
      "doc": "Before Ethereum launched, it was necessary to create a wallet\nformat for backers to use, which would be used to receive ether\nas a reward for contributing to the project.\n\nThe [[link-crowdsale]] format is now obsolete, but it is still\nuseful to support and the additional code is fairly trivial as\nall the primitives required are used through core portions of\nthe library.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJsonSync",
      "kind": "FunctionDeclaration",
      "signature": "export function decryptKeystoreJsonSync(json: string, _password: string | Uint8Array): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dk",
      "doc": "Returns the account details for the JSON Keystore Wallet %%json%%\nusing %%password%%.\n\nIt is preferred to use the [async version](decryptKeystoreJson)\ninstead, which allows a [[ProgressCallback]] to keep the user informed\nas to the decryption status.\n\nThis method will block the event loop (freezing all UI) until decryption\nis complete, which can take quite some time, depending on the wallet\nparamters and platform.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function decryptKeystoreJson(json: string, _password: string | Uint8Array, progress?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pb",
      "doc": "Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n%%password%%.\n\nIf provided, %%progress%% will be called periodically during the\ndecrpytion to provide feedback, and if the function returns\n``false`` will halt decryption.\n\nThe %%progressCallback%% will **always** receive ``0`` before\ndecryption begins and ``1`` when complete.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function encryptKeystoreJson(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): Promise<string> {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = ",
      "doc": "Resolved to the JSON Keystore Wallet for %%account%% encrypted\nwith %%password%%.\n\nThe %%options%% can be used to tune the password-based key\nderivation function parameters, explicitly set the random values\nused and provide a [[ProgressCallback]] to receive periodic updates\non the completion status..",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJsonSync",
      "kind": "FunctionDeclaration",
      "signature": "export function encryptKeystoreJsonSync(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): string {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = scryptSync(",
      "doc": "Return the JSON Keystore Wallet for %%account%% encrypted with\n%%password%%.\n\nThe %%options%% can be used to tune the password-based key\nderivation function parameters, explicitly set the random values\nused. Any provided [[ProgressCallback]] is ignord.",
      "tags": []
    },
    {
      "name": "Wordlist",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Wordlist {\n    locale!: string;\n\n    /**\n     *  Creates a new Wordlist instance.\n     *\n     *  Sub-classes MUST call this if they provide their own constructor,\n     *  passing in the locale string of the language.\n     *\n     *  Generally there is no need to create instances",
      "doc": "A Wordlist represents a collection of language-specific\nwords used to encode and devoce [[link-bip-39]] encoded data\nby mapping words to 11-bit values and vice versa.",
      "tags": []
    },
    {
      "name": "LangEn",
      "kind": "ClassDeclaration",
      "signature": "export class LangEn extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the English language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEn]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"en\", words, ch",
      "doc": "The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "WordlistOwl",
      "kind": "ClassDeclaration",
      "signature": "export class WordlistOwl extends Wordlist {\n    #data: string;\n    #checksum: string;\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, checksum: string) {\n        super(",
      "doc": "An OWL format Wordlist is an encoding method that exploits\nthe general locality of alphabetically sorted words to\nachieve a simple but effective means of compression.\n\nThis class is generally not useful to most developers as\nit is used mainly internally to keep Wordlists for languages\nbased on ASCII-7 small.\n\nIf necessary, there are tools within the ``generation/`` folder\nto create the necessary data.",
      "tags": []
    },
    {
      "name": "WordlistOwlA",
      "kind": "ClassDeclaration",
      "signature": "export class WordlistOwlA extends WordlistOwl {\n    #accent: string;\n\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%\n     *  and %%accent%% data and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, accent: string, checksum: str",
      "doc": "An OWL-A format Wordlist extends the OWL format to add an\noverlay onto an OWL format Wordlist to support diacritic\nmarks.\n\nThis class is generally not useful to most developers as\nit is used mainly internally to keep Wordlists for languages\nbased on latin-1 small.\n\nIf necessary, there are tools within the ``generation/`` folder\nto create the necessary data.",
      "tags": []
    },
    {
      "name": "wordlists",
      "kind": "VariableDeclaration",
      "signature": "wordlists: Record<string, Wordlist> = {\n  cz: LangCz.wordlist(),\n  en: LangEn.wordlist(),\n  es: LangEs.wordlist(),\n  fr: LangFr.wordlist(),\n  it: LangIt.wordlist(),\n  pt: LangPt.wordlist(),\n  ja: LangJa.wordlist(),\n  ko: LangKo.wordlist(),\n  zh_cn: LangZh.wordlist(\"cn\"),\n  zh_tw: LangZh.wordlist(\"tw",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonFragment",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonFragment {\n    /**\n     *  The name of the error, event, function, etc.\n     */\n    readonly name?: string;\n\n    /**\n     *  The type of the fragment (e.g. ``event``, ``\"function\"``, etc.)\n     */\n    readonly type?: string;\n\n    /**\n     *  If the event is anonymous.\n     */\n  ",
      "doc": "A fragment for a method, event or error in a [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "JsonFragmentType",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonFragmentType {\n    /**\n     *  The parameter name.\n     */\n    readonly name?: string;\n\n    /**\n     *  If the parameter is indexed.\n     */\n    readonly indexed?: boolean;\n\n    /**\n     *  The type of the parameter.\n     */\n    readonly type?: string;\n\n    /**\n     *  The inter",
      "doc": "A Type description in a [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "FormatType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FormatType = \"sighash\" | \"minimal\" | \"full\" | \"json\";",
      "doc": "The format to serialize the output as.\n\n**``\"sighash\"``** - the bare formatting, used to compute the selector\nor topic hash; this format cannot be reversed (as it discards ``indexed``)\nso cannot by used to export an [[Interface]].\n\n**``\"minimal\"``** - Human-Readable ABI with minimal spacing and without\nnames, so it is compact, but will result in Result objects that cannot\nbe accessed by name.\n\n**``\"full\"``** - Full Human-Readable ABI, with readable spacing and names\nintact; this is generally the recommended format.\n\n**``\"json\"``** - The [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "FragmentType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FragmentType = \"constructor\" | \"error\" | \"event\" | \"fallback\" | \"function\" | \"struct\";",
      "doc": "The type of a [[Fragment]].",
      "tags": []
    },
    {
      "name": "InterfaceAbi",
      "kind": "TypeAliasDeclaration",
      "signature": "export type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;",
      "doc": "An **InterfaceAbi** may be any supported ABI format.\n\nA string is expected to be a JSON string, which will be parsed\nusing ``JSON.parse``. This means that the value **must** be a valid\nJSON string, with no stray commas, etc.\n\nAn array may contain any combination of:\n- Human-Readable fragments\n- Parsed JSON fragment\n- [[Fragment]] instances\n\nA **Human-Readable Fragment** is a string which resembles a Solidity\nsignature and is introduced in [this blog entry](link-ricmoo-humanreadableabi).\nFor example, ``function balanceOf(address) view returns (uint)``.\n\nA **Parsed JSON Fragment** is a JavaScript Object desribed in the\n[Solidity documentation](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "ParamTypeWalkFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ParamTypeWalkFunc = (type: string, value: any) => any;",
      "doc": "When [walking](ParamType-walk) a [[ParamType]], this is called\non each component.",
      "tags": []
    },
    {
      "name": "ParamTypeWalkAsyncFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ParamTypeWalkAsyncFunc = (type: string, value: any) => any | Promise<any>;",
      "doc": "When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],\nthis is called on each component.",
      "tags": []
    },
    {
      "name": "Addressable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Addressable {\n    /**\n     *  Get the object address.\n     */\n    getAddress(): Promise<string>;\n}",
      "doc": "An interface for objects which have an address, and can\nresolve it asyncronously.\n\nThis allows objects such as [[Signer]] or [[Contract]] to\nbe used most places an address can be, for example getting\nthe [balance](Provider-getBalance).",
      "tags": []
    },
    {
      "name": "AddressLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AddressLike = string | Promise<string> | Addressable;",
      "doc": "Anything that can be used to return or resolve an address.",
      "tags": []
    },
    {
      "name": "NameResolver",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NameResolver {\n    /**\n     *  Resolve to the address for the ENS %%name%%.\n     *\n     *  Resolves to ``null`` if the name is unconfigued. Use\n     *  [[resolveAddress]] (passing this object as %%resolver%%) to\n     *  throw for names that are unconfigured.\n     */\n    resolveName(",
      "doc": "An interface for any object which can resolve an ENS name.",
      "tags": []
    },
    {
      "name": "ConstantContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConstantContractMethod<\n    A extends Array<any>,\n    R = any\n> extends ContractMethod<A, R, R> { }",
      "doc": "A pure of view method on a Contract.",
      "tags": []
    },
    {
      "name": "ContractEvent",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractEvent<A extends Array<any> = Array<any>> {\n    (...args: ContractEventArgs<A>): DeferredTopicFilter;\n\n    /**\n     *  The name of the Contract event.\n     */\n    name: string;\n\n    /**\n     *  The fragment of the Contract event. This will throw on ambiguous\n     *  method na",
      "doc": "",
      "tags": []
    },
    {
      "name": "ContractEventArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractEventArgs<A extends Array<any>> = { [ I in keyof A ]?: A[I] | Typed | null };",
      "doc": "Each argument of an event is nullable (to indicate matching //any//.",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractEventName",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractEventName = string | ContractEvent | TopicFilter | DeferredTopicFilter;",
      "doc": "The name for an event used for subscribing to Contract events.\n\n**``string``** - An event by name. The event must be non-ambiguous.\nThe parameters will be dereferenced when passed into the listener.\n\n[[ContractEvent]] - A filter from the ``contract.filters``, which will\npass only the EventPayload as a single parameter, which includes a\n``.signature`` property that can be used to further filter the event.\n\n[[TopicFilter]] - A filter defined using the standard Ethereum API\nwhich provides the specific topic hash or topic hashes to watch for along\nwith any additional values to filter by. This will only pass a single\nparameter to the listener, the EventPayload which will include additional\ndetails to refine by, such as the event name and signature.\n\n[[DeferredTopicFilter]] - A filter created by calling a [[ContractEvent]]\nwith parameters, which will create a filter for a specific event\nsignature and dereference each parameter when calling the listener.",
      "tags": []
    },
    {
      "name": "ContractInterface",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractInterface {\n    [ name: string ]: BaseContractMethod;\n}",
      "doc": "A Contract with no method constraints.",
      "tags": []
    },
    {
      "name": "ContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractMethod<\n    A extends Array<any> = Array<any>,\n    R = any,\n    D extends R | ContractTransactionResponse = R | ContractTransactionResponse\n> extends BaseContractMethod<A, R, D> { }",
      "doc": "A contract method on a Contract.",
      "tags": []
    },
    {
      "name": "ContractMethodArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractMethodArgs<A extends Array<any>> = PostfixOverrides<{ [ I in keyof A ]-?: A[I] | Typed }>;",
      "doc": "Arguments to a Contract method can always include an additional and\noptional overrides parameter, and each parameter can optionally be\n[[Typed]].",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractTransaction extends PreparedTransactionRequest {\n    /**\n     *  The target address.\n     */\n    to: string;\n\n    /**\n     *  The transaction data.\n     */\n    data: string;\n\n    /**\n     *  The from address, if any.\n     */\n    from?: string;\n}",
      "doc": "When populating a transaction this type is returned.",
      "tags": []
    },
    {
      "name": "DeferredTopicFilter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DeferredTopicFilter {\n    getTopicFilter(): Promise<TopicFilter>;\n    fragment: EventFragment;\n}",
      "doc": "When creating a filter using the ``contract.filters``, this is returned.",
      "tags": []
    },
    {
      "name": "Overrides",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Overrides extends Omit<TransactionRequest, \"to\" | \"data\"> { }",
      "doc": "The overrides for a contract transaction.",
      "tags": []
    },
    {
      "name": "BaseContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BaseContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {\n    (...args: ContractMethodArgs<A>): Promise<D>;\n\n    /**\n     *  The name of the Contract method.\n     */\n    name: string;\n\n    /**\n     *",
      "doc": "A Contract method can be called directly, or used in various ways.",
      "tags": []
    },
    {
      "name": "ContractDeployTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractDeployTransaction extends Omit<ContractTransaction, \"to\"> { }",
      "doc": "A deployment transaction for a contract.",
      "tags": []
    },
    {
      "name": "PostfixOverrides",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PostfixOverrides<A extends Array<any>> = A | [ ...A, Overrides ];",
      "doc": "Arguments to a Contract method can always include an additional and\noptional overrides parameter.",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "WrappedFallback",
      "kind": "InterfaceDeclaration",
      "signature": "export interface WrappedFallback {\n    (overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse>;\n\n    /**\n     *  Returns a populated transaction that can be used to perform the\n     *  fallback method.\n     *\n     *  For non-receive fallback, ``data`` may be overridden.\n  ",
      "doc": "A Fallback or Receive function on a Contract.",
      "tags": []
    },
    {
      "name": "ProgressCallback",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProgressCallback = (percent: number) => void;",
      "doc": "A callback during long-running operations to update any\nUI or provide programatic access to the progress.\n\nThe %%percent%% is a value between ``0`` and ``1``.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        }
      ]
    },
    {
      "name": "SignatureLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type SignatureLike = Signature | string | {\n    r: string;\n    s: string;\n    v: BigNumberish;\n    yParity?: 0 | 1;\n    yParityAndS?: string;\n} | {\n    r: string;\n    yParityAndS: string;\n    yParity?: 0 | 1;\n    s?: string;\n    v?: number;\n} | {\n    r: string;\n    s: string;\n    yParity: 0 |",
      "doc": "A SignatureLike",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Signing"
        }
      ]
    },
    {
      "name": "AuthorizationRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AuthorizationRequest {\n    address: string | Addressable;\n    nonce?: Numeric;\n    chainId?: BigNumberish;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "TypedDataDomain",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedDataDomain {\n    /**\n     *  The human-readable name of the signing domain.\n     */\n    name?: null | string;\n\n    /**\n     *  The major version of the signing domain.\n     */\n    version?: null | string;\n\n    /**\n     *  The chain ID of the signing domain.\n     */\n    chainId?",
      "doc": "The domain for an [[link-eip-712]] payload.",
      "tags": []
    },
    {
      "name": "TypedDataField",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedDataField {\n    /**\n     *  The field name.\n     */\n    name: string;\n\n    /**\n     *  The type of the field.\n     */\n    type: string;\n}",
      "doc": "A specific field of a structured [[link-eip-712]] type.",
      "tags": []
    },
    {
      "name": "Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Provider extends ContractRunner, EventEmitterable<ProviderEvent>, NameResolver {\n\n    /**\n     *  The provider iteself.\n     *\n     *  This is part of the necessary API for executing a contract, as\n     *  it provides a common property on any [[ContractRunner]] that\n     *  can be u",
      "doc": "A **Provider** is the primary method to interact with the read-only\ncontent on Ethereum.\n\nIt allows access to details about accounts, blocks and transactions\nand the ability to query event logs and simulate contract execution.\n\nAccount data includes the [balance](getBalance),\n[transaction count](getTransactionCount), [code](getCode) and\n[state trie storage](getStorage).\n\nSimulating execution can be used to [call](call),\n[estimate gas](estimateGas) and\n[get transaction results](getTransactionResult).\n\nThe [[broadcastTransaction]] is the only method which allows updating\nthe blockchain, but it is usually accessed by a [[Signer]], since a\nprivate key must be used to sign the transaction before it can be\nbroadcast.",
      "tags": []
    },
    {
      "name": "Signer",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Signer extends Addressable, ContractRunner, NameResolver {\n\n    /**\n     *  The [[Provider]] attached to this Signer (if any).\n     */\n    provider: null | Provider;\n\n    /**\n     *  Returns a new instance of this Signer connected to //provider// or detached\n     *  from any Provide",
      "doc": "A Signer represents an account on the Ethereum Blockchain, and is most often\nbacked by a private key represented by a mnemonic or residing on a Hardware Wallet.\n\nThe API remains abstract though, so that it can deal with more advanced exotic\nSigning entities, such as Smart Contract Wallets or Virtual Wallets (where the\nprivate key may not be known).",
      "tags": []
    },
    {
      "name": "CommunityResourcable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CommunityResourcable {\n    /**\n     *  Returns true if the instance is connected using the community\n     *  credentials.\n     */\n    isCommunityResource(): boolean;\n}",
      "doc": "There are many awesome community services that provide Ethereum\nnodes both for developers just starting out and for large-scale\ncommunities.\nProviders which offer community credentials should extend this\nto notify any interested consumers whether community credentials\nare in-use.",
      "tags": [
        {
          "tagName": "_section",
          "text": ": api/providers/thirdparty: Community Providers  [thirdparty]"
        }
      ]
    },
    {
      "name": "AbstractProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AbstractProviderOptions = {\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};",
      "doc": "Options for configuring some internal aspects of an [[AbstractProvider]].\n\n**``cacheTimeout``** - how long to cache a low-level ``_perform``\nfor, based on input parameters. This reduces the number of calls\nto getChainId and getBlockNumber, but may break test chains which\ncan perform operations (internally) synchronously. Use ``-1`` to\ndisable, ``0`` will only buffer within the same event loop and\nany other value is in ms. (default: ``250``)",
      "tags": []
    },
    {
      "name": "BrowserProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BrowserProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n\n    providerInfo?: Eip6963ProviderInfo;\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "FallbackProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FallbackProviderOptions = {\n    // How many providers must agree on a value before reporting\n    // back the response\n    quorum?: number;\n\n    // How many providers must have reported the same event\n    // for it to be emitted (currently unimplmented)\n    eventQuorum?: number;\n\n    // H",
      "doc": "Additional options to configure a [[FallbackProvider]].",
      "tags": []
    },
    {
      "name": "AbstractProviderPlugin",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AbstractProviderPlugin {\n    /**\n     *  The reverse domain notation of the plugin.\n     */\n    readonly name: string;\n\n    /**\n     *  Creates a new instance of the plugin, connected to %%provider%%.\n     */\n    connect(provider: AbstractProvider): AbstractProviderPlugin;\n}",
      "doc": "An **AbstractPlugin** is used to provide additional internal services\nto an [[AbstractProvider]] without adding backwards-incompatible changes\nto method signatures or other internal and complex logic.",
      "tags": []
    },
    {
      "name": "BlockParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BlockParams {\n    /**\n     *  The block hash.\n     */\n    hash?: null | string;\n\n    /**\n     *  The block number.\n     */\n    number: number;\n\n    /**\n     *  The timestamp for this block, which is the number of seconds\n     *  since epoch that this block was included.\n     */\n    ",
      "doc": "a **BlockParams** encodes the minimal required properties for a\nformatted block.",
      "tags": []
    },
    {
      "name": "BlockTag",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BlockTag = BigNumberish | string;",
      "doc": "A **BlockTag** specifies a specific block.\n\n**numeric value** - specifies the block height, where\nthe genesis block is block 0; many operations accept a negative\nvalue which indicates the block number should be deducted from\nthe most recent block. A numeric value may be a ``number``, ``bigint``,\nor a decimal of hex string.\n\n**blockhash** - specifies a specific block by its blockhash; this allows\npotentially orphaned blocks to be specifed, without ambiguity, but many\nbackends do not support this for some operations.",
      "tags": []
    },
    {
      "name": "BrowserDiscoverOptions",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BrowserDiscoverOptions {\n    /**\n     *  Override provider detection with this provider.\n     */\n    provider?: Eip1193Provider;\n\n    /**\n     *  Duration to wait to detect providers. (default: 300ms)\n     */\n    timeout?: number;\n\n    /**\n     *  Return the first detected provider.",
      "doc": "Specifies how [[link-eip-6963]] discovery should proceed.\n\nSee: [[BrowserProvider-discover]]",
      "tags": []
    },
    {
      "name": "ContractRunner",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractRunner {\n    /**\n     *  The provider used for necessary state querying operations.\n     *\n     *  This can also point to the **ContractRunner** itself, in the\n     *  case of an [[AbstractProvider]].\n     */\n    provider: null | Provider;\n\n    /**\n     *  Required to estima",
      "doc": "A **ContractRunner** is a generic interface which defines an object\ncapable of interacting with a Contract on the network.\n\nThe more operations supported, the more utility it is capable of.\n\nThe most common ContractRunners are [Providers](Provider) which enable\nread-only access and [Signers](Signer) which enable write-access.",
      "tags": []
    },
    {
      "name": "DebugEventBrowserProvider",
      "kind": "TypeAliasDeclaration",
      "signature": "export type DebugEventBrowserProvider = {\n    action: \"sendEip1193Payload\",\n    payload: { method: string, params: Array<any> }\n} | {\n    action: \"receiveEip1193Result\",\n    result: any\n} | {\n    action: \"receiveEip1193Error\",\n    error: Error\n};",
      "doc": "The possible additional events dispatched when using the ``\"debug\"``\nevent on a [[BrowserProvider]].",
      "tags": []
    },
    {
      "name": "Eip1193Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Eip1193Provider {\n    /**\n     *  See [[link-eip-1193]] for details on this method.\n     */\n    request(request: { method: string, params?: Array<any> | Record<string, any> }): Promise<any>;\n}",
      "doc": "The interface to an [[link-eip-1193]] provider, which is a standard\nused by most injected providers, which the [[BrowserProvider]] accepts\nand exposes the API of.",
      "tags": []
    },
    {
      "name": "Eip6963ProviderInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Eip6963ProviderInfo {\n    uuid: string;\n    name: string;\n    icon: string;\n    rdns: string;\n}",
      "doc": "Provider info provided by the [[link-eip-6963]] discovery mechanism.",
      "tags": []
    },
    {
      "name": "EventFilter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EventFilter {\n    address?: AddressLike | Array<AddressLike>;\n    topics?: TopicFilter;\n}",
      "doc": "An **EventFilter** allows efficiently filtering logs (also known as\nevents) using bloom filters included within blocks.",
      "tags": []
    },
    {
      "name": "Filter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Filter extends EventFilter {\n\n    /**\n     *  The start block for the filter (inclusive).\n     */\n    fromBlock?: BlockTag;\n\n    /**\n     *  The end block for the filter (inclusive).\n     */\n    toBlock?: BlockTag;\n}",
      "doc": "A **Filter** allows searching a specific range of blocks for mathcing\nlogs.",
      "tags": []
    },
    {
      "name": "FilterByBlockHash",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FilterByBlockHash extends EventFilter {\n    /**\n     *  The blockhash of the specific block for the filter.\n     */\n    blockHash?: string;\n}",
      "doc": "A **FilterByBlockHash** allows searching a specific block for mathcing\nlogs.",
      "tags": []
    },
    {
      "name": "GasCostParameters",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GasCostParameters = {\n    /**\n     *  The transactions base fee.\n     */\n    txBase?: number;\n\n    /**\n     *  The fee for creating a new account.\n     */\n    txCreate?: number;\n\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    txDataZero?: number;\n\n    /**\n     *  The fee ",
      "doc": "The gas cost parameters for a [[GasCostPlugin]].",
      "tags": []
    },
    {
      "name": "JsonRpcApiProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcApiProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n    batchStallTime?: number;\n    batchMaxSize?: number;\n    batchMaxCount?: number;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};",
      "doc": "Options for configuring a [[JsonRpcApiProvider]]. Much of this\nis targetted towards sub-classes, which often will not expose\nany of these options to their consumers.\n\n**``polling``** - use the polling strategy is used immediately\nfor events; otherwise, attempt to use filters and fall back onto\npolling (default: ``false``)\n\n**``staticNetwork``** - do not request chain ID on requests to\nvalidate the underlying chain has not changed (default: ``null``)\n\nThis should **ONLY** be used if it is **certain** that the network\ncannot change, such as when using INFURA (since the URL dictates the\nnetwork). If the network is assumed static and it does change, this\ncan have tragic consequences. For example, this **CANNOT** be used\nwith MetaMask, since the user can select a new network from the\ndrop-down at any time.\n\n**``batchStallTime``** - how long (ms) to aggregate requests into a\nsingle batch. ``0`` indicates batching will only encompass the current\nevent loop. If ``batchMaxCount = 1``, this is ignored. (default: ``10``)\n\n**``batchMaxSize``** - target maximum size (bytes) to allow per batch\nrequest (default: 1Mb)\n\n**``batchMaxCount``** - maximum number of requests to allow in a batch.\nIf ``batchMaxCount = 1``, then batching is disabled. (default: ``100``)\n\n**``cacheTimeout``** - passed as [[AbstractProviderOptions]].",
      "tags": []
    },
    {
      "name": "JsonRpcError",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcError = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response error.\n     */\n    error: {\n        code: number;\n        message?: string;\n        data?: any;\n    }\n};",
      "doc": "A JSON-RPC error, which are returned on failure from a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcPayload",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcPayload = {\n    /**\n     *  The JSON-RPC request ID.\n     */\n    id: number;\n\n    /**\n     *  The JSON-RPC request method.\n     */\n    method: string;\n\n    /**\n     *  The JSON-RPC request parameters.\n     */\n    params: Array<any> | Record<string, any>;\n\n    /**\n     *  A require",
      "doc": "A JSON-RPC payload, which are sent to a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcResult",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcResult = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response result.\n     */\n    result: any;\n};",
      "doc": "A JSON-RPC result, which are returned on success from a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcTransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcTransactionRequest {\n     /**\n      *  The sender address to use when signing.\n      */\n     from?: string;\n\n     /**\n      *  The target address.\n      */\n     to?: string;\n\n     /**\n      *  The transaction data.\n      */\n     data?: string;\n\n     /**\n      *  The chain ID ",
      "doc": "A **JsonRpcTransactionRequest** is formatted as needed by the JSON-RPC\nEthereum API specification.",
      "tags": []
    },
    {
      "name": "LogParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LogParams {\n    /**\n     *  The transaction hash for the transaxction the log occurred in.\n     */\n    transactionHash: string;\n\n    /**\n     *  The block hash of the block that included the transaction for this\n     *  log.\n     */\n    blockHash: string;\n\n    /**\n     *  The block ",
      "doc": "a **LogParams** encodes the minimal required properties for a\nformatted log.",
      "tags": []
    },
    {
      "name": "MinedBlock",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinedBlock extends Block {\n    /**\n     *  The block number also known as the block height.\n     */\n    readonly number: number;\n\n    /**\n     *  The block hash.\n     */\n    readonly hash: string;\n\n    /**\n     *  The block timestamp, in seconds from epoch.\n     */\n    readonly time",
      "doc": "An Interface to indicate a [[Block]] has been included in the\nblockchain. This asserts a Type Guard that necessary properties\nare non-null.\n\nBefore a block is included, it is a //pending// block.",
      "tags": []
    },
    {
      "name": "MinedTransactionResponse",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinedTransactionResponse extends TransactionResponse {\n    /**\n     *  The block number this transaction occurred in.\n     */\n    blockNumber: number;\n\n    /**\n     *  The block hash this transaction occurred in.\n     */\n    blockHash: string;\n\n    /**\n     *  The date this transact",
      "doc": "A **MinedTransactionResponse** is an interface representing a\ntransaction which has been mined and allows for a type guard for its\nproperty values being defined.",
      "tags": []
    },
    {
      "name": "Networkish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Networkish = Network | number | bigint | string | {\n    name?: string,\n    chainId?: number,\n    //layerOneConnection?: Provider,\n    ensAddress?: string,\n    ensNetwork?: number\n};",
      "doc": "A Networkish can be used to allude to a Network, by specifing:\n- a [[Network]] object\n- a well-known (or registered) network name\n- a well-known (or registered) chain ID\n- an object with sufficient details to describe a network",
      "tags": []
    },
    {
      "name": "OrphanFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OrphanFilter = {\n    orphan: \"drop-block\",\n    hash: string,\n    number: number\n} | {\n    orphan: \"drop-transaction\",\n    tx: { hash: string, blockHash: string, blockNumber: number },\n    other?: { hash: string, blockHash: string, blockNumber: number }\n} | {\n    orphan: \"reorder-transact",
      "doc": "An Orphan Filter allows detecting when an orphan block has\nresulted in dropping a block or transaction or has resulted\nin transactions changing order.\n\nNot currently fully supported.",
      "tags": []
    },
    {
      "name": "PerformActionFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PerformActionFilter = {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n} | {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    blockHash?: string;\n};",
      "doc": "A normalized filter used for [[PerformActionRequest]] objects.",
      "tags": []
    },
    {
      "name": "PerformActionRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PerformActionRequest = {\n    method: \"broadcastTransaction\",\n    signedTransaction: string\n} | {\n    method: \"call\",\n    transaction: PerformActionTransaction, blockTag: BlockTag\n} | {\n    method: \"chainId\"\n} | {\n    method: \"estimateGas\",\n    transaction: PerformActionTransaction\n} | {\n",
      "doc": "The [[AbstractProvider]] methods will normalize all values and pass this\ntype to [[AbstractProvider-_perform]].",
      "tags": []
    },
    {
      "name": "PerformActionTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PerformActionTransaction extends PreparedTransactionRequest {\n    /**\n     *  The ``to`` address of the transaction.\n     */\n    to?: string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: string;\n}",
      "doc": "A normalized transactions used for [[PerformActionRequest]] objects.",
      "tags": []
    },
    {
      "name": "PreparedTransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PreparedTransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: number;\n\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: AddressLike;\n\n    /**\n     *  The nonce of ",
      "doc": "A **PreparedTransactionRequest** is identical to a [[TransactionRequest]]\nexcept all the property types are strictly enforced.",
      "tags": []
    },
    {
      "name": "ProviderEvent",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProviderEvent = string | Array<string | Array<string>> | EventFilter | OrphanFilter;",
      "doc": "A **ProviderEvent** provides the types of events that can be subscribed\nto on a [[Provider]].\n\nEach provider may include additional possible events it supports, but\nthe most commonly supported are:\n\n**``\"block\"``** - calls the listener with the current block number on each\nnew block.\n\n**``\"error\"``** - calls the listener on each async error that occurs during\nthe event loop, with the error.\n\n**``\"debug\"``** - calls the listener on debug events, which can be used to\ntroubleshoot network errors, provider problems, etc.\n\n**``transaction hash``** - calls the listener on each block after the\ntransaction has been mined; generally ``.once`` is more appropriate for\nthis event.\n\n**``Array``** - calls the listener on each log that matches the filter.\n\n[[EventFilter]] - calls the listener with each matching log",
      "tags": []
    },
    {
      "name": "Subscriber",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Subscriber {\n    /**\n     *  Called initially when a subscriber is added the first time.\n     */\n    start(): void;\n\n    /**\n     *  Called when there are no more subscribers to the event.\n     */\n    stop(): void;\n\n    /**\n     *  Called when the subscription should pause.\n     *\n ",
      "doc": "A **Subscriber** manages a subscription.\n\nOnly developers sub-classing [[AbstractProvider[[ will care about this,\nif they are modifying a low-level feature of how subscriptions operate.",
      "tags": []
    },
    {
      "name": "Subscription",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Subscription = {\n    type: \"block\" | \"close\" | \"debug\" | \"error\" | \"finalized\" | \"network\" | \"pending\" | \"safe\",\n    tag: string\n} | {\n    type: \"transaction\",\n    tag: string,\n    hash: string\n} | {\n    type: \"event\",\n    tag: string,\n    filter: EventFilter\n} | {\n    type: \"orphan\",\n  ",
      "doc": "The value passed to the [[AbstractProvider-_getSubscriber]] method.\n\nOnly developers sub-classing [[AbstractProvider[[ will care about this,\nif they are modifying a low-level feature of how subscriptions operate.",
      "tags": []
    },
    {
      "name": "TopicFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type TopicFilter = Array<null | string | Array<string>>;",
      "doc": "A **TopicFilter** provides a struture to define bloom-filter\nqueries.\n\nEach field that is ``null`` matches **any** value, a field that is\na ``string`` must match exactly that value and ``array`` is\neffectively an ``OR``-ed set, where any one of those values must\nmatch.",
      "tags": []
    },
    {
      "name": "TransactionReceiptParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionReceiptParams {\n    /**\n     *  The target of the transaction. If null, the transaction was trying\n     *  to deploy a transaction with the ``data`` as the initi=code.\n     */\n    to: null | string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from: string;",
      "doc": "a **TransactionReceiptParams** encodes the minimal required properties\nfor a formatted transaction receipt.",
      "tags": []
    },
    {
      "name": "TransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: null | number;\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: null | AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: null | AddressLike;\n\n    /**\n     *  T",
      "doc": "A **TransactionRequest** is a transactions with potentially various\nproperties not defined, or with less strict types for its values.\n\nThis is used to pass to various operations, which will internally\ncoerce any types and populate any necessary values.",
      "tags": []
    },
    {
      "name": "TransactionResponseParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionResponseParams {\n    /**\n     *  The block number of the block that included this transaction.\n     */\n    blockNumber: null | number;\n\n    /**\n     *  The block hash of the block that included this transaction.\n     */\n    blockHash: null | string;\n\n    /**\n     *  The t",
      "doc": "a **TransactionResponseParams** encodes the minimal required properties\nfor a formatted transaction response.",
      "tags": []
    },
    {
      "name": "WebSocketCreator",
      "kind": "TypeAliasDeclaration",
      "signature": "export type WebSocketCreator = () => WebSocketLike;",
      "doc": "A function which can be used to re-create a WebSocket connection\non disconnect.",
      "tags": []
    },
    {
      "name": "WebSocketLike",
      "kind": "InterfaceDeclaration",
      "signature": "export interface WebSocketLike {\n    onopen: null | ((...args: Array<any>) => any);\n    onmessage: null | ((...args: Array<any>) => any);\n    onerror: null | ((...args: Array<any>) => any);\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}",
      "doc": "A generic interface to a Websocket-like object.",
      "tags": []
    },
    {
      "name": "AccessList",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessList = Array<AccessListEntry>;",
      "doc": "An ordered collection of [[AccessList]] entries.",
      "tags": []
    },
    {
      "name": "AccessListish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;",
      "doc": "Any ethers-supported access list structure.",
      "tags": []
    },
    {
      "name": "AccessListEntry",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessListEntry = { address: string, storageKeys: Array<string> };",
      "doc": "A single [[AccessList]] entry of storage keys (slots) for an address.",
      "tags": []
    },
    {
      "name": "Authorization",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Authorization {\n    address: string;\n    nonce: bigint;\n    chainId: bigint;\n    signature: Signature;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "AuthorizationLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AuthorizationLike = {\n    address: string;\n    nonce: BigNumberish;\n    chainId: BigNumberish;\n    signature: SignatureLike\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "Blob",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Blob {\n    data: string;\n    proof: string;\n    commitment: string;\n}",
      "doc": "A full-valid BLOb object for [[link-eip-4844]] transactions.\n\nThe commitment and proof should have been computed using a\nKZG library.",
      "tags": []
    },
    {
      "name": "BlobLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BlobLike = BytesLike | {\n    data: BytesLike;\n    proof: BytesLike;\n    commitment: BytesLike;\n};",
      "doc": "A BLOb object that can be passed for [[link-eip-4844]]\ntransactions.\n\nIt may have had its commitment and proof already provided\nor rely on an attached [[KzgLibrary]] to compute them.",
      "tags": []
    },
    {
      "name": "KzgLibrary",
      "kind": "InterfaceDeclaration",
      "signature": "export interface KzgLibrary {\n    blobToKzgCommitment: (blob: Uint8Array) => Uint8Array;\n    computeBlobKzgProof: (blob: Uint8Array, commitment: Uint8Array) => Uint8Array;\n}",
      "doc": "A KZG Library with the necessary functions to compute\nBLOb commitments and proofs.",
      "tags": []
    },
    {
      "name": "KzgLibraryLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type KzgLibraryLike  = KzgLibrary | {\n    // kzg-wasm >= 0.5.0\n    blobToKZGCommitment: (blob: string) => string;\n    computeBlobKZGProof: (blob: string, commitment: string) => string;\n} | {\n    // micro-ecc-signer\n    blobToKzgCommitment: (blob: string) => string | Uint8Array;\n    computeBlo",
      "doc": "A KZG Library with any of the various API configurations.\nAs the library is still experimental and the API is not\nstable, depending on the version used the method names and\nsignatures are still in flux.\n\nThis allows any of the versions to be passed into Transaction\nwhile providing a stable external API.",
      "tags": []
    },
    {
      "name": "TransactionLike",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionLike<A = string> {\n    /**\n     *  The type.\n     */\n    type?: null | number;\n\n    /**\n     *  The recipient address or ``null`` for an ``init`` transaction.\n     */\n    to?: null | A;\n\n    /**\n     *  The sender.\n     */\n    from?: null | A;\n\n    /**\n     *  The nonce.\n",
      "doc": "A **TransactionLike** is an object which is appropriate as a loose\ninput for many operations which will populate missing properties of\na transaction.",
      "tags": []
    },
    {
      "name": "BytesLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BytesLike = DataHexString | Uint8Array;",
      "doc": "An object that can be used to represent binary data.",
      "tags": []
    },
    {
      "name": "BigNumberish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BigNumberish = string | Numeric;",
      "doc": "Any type that can be used where a big number is needed.",
      "tags": []
    },
    {
      "name": "Numeric",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Numeric = number | bigint;",
      "doc": "Any type that can be used where a numeric value is needed.",
      "tags": []
    },
    {
      "name": "ErrorCode",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVAL",
      "doc": "All errors emitted by ethers have an **ErrorCode** to help\nidentify and coalesce errors to simplify programmatic analysis.\n\nEach **ErrorCode** is the %%code%% proerty of a coresponding\n[[EthersError]].\n\n**Generic Errors**\n\n**``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n\n**``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n\n**``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n\n**``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n\n**``\"SERVER_ERROR\"``** - see [[ServerError]]\n\n**``\"TIMEOUT\"``** - see [[TimeoutError]]\n\n**``\"BAD_DATA\"``** - see [[BadDataError]]\n\n**``\"CANCELLED\"``** - see [[CancelledError]]\n\n**Operational Errors**\n\n**``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n\n**``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n\n**Argument Errors**\n\n**``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n\n**``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n\n**``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n\n**``\"VALUE_MISMATCH\"``** - //unused//\n\n**Blockchain Errors**\n\n**``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n\n**``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n\n**``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n\n**``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n\n**``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n\n**``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n\n**``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n\n**User Interaction Errors**\n\n**``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]",
      "tags": []
    },
    {
      "name": "FixedFormat",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FixedFormat = number | string | {\n    signed?: boolean,\n    width?: number,\n    decimals?: number\n};",
      "doc": "A description of a fixed-point arithmetic field.\n\nWhen specifying the fixed format, the values override the default of\na ``fixed128x18``, which implies a signed 128-bit value with 18\ndecimals of precision.\n\nThe alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and\n``ufixed128x18`` respectively.\n\nWhen a fixed format string begins with a ``u``, it indicates the field\nis unsigned, so any negative values will overflow. The first number\nindicates the bit-width and the second number indicates the decimal\nprecision.\n\nWhen a ``number`` is used for a fixed format, it indicates the number\nof decimal places, and the default width and signed-ness will be used.\n\nThe bit-width must be byte aligned and the decimals can be at most 80.",
      "tags": []
    },
    {
      "name": "Utf8ErrorFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number) => number;",
      "doc": "A callback that can be used with [[toUtf8String]] to analysis or\nrecovery from invalid UTF-8 data.\n\nParsing UTF-8 data is done through a simple Finite-State Machine (FSM)\nwhich calls the ``Utf8ErrorFunc`` if a fault is detected.\n\nThe %%reason%% indicates where in the FSM execution the fault\noccurred and the %%offset%% indicates where the input failed.\n\nThe %%bytes%% represents the raw UTF-8 data that was provided and\n%%output%% is the current array of UTF-8 code-points, which may\nbe updated by the ``Utf8ErrorFunc``.\n\nThe value of the %%badCodepoint%% depends on the %%reason%%. See\n[[Utf8ErrorReason]] for details.\n\nThe function should return the number of bytes that should be skipped\nwhen control resumes to the FSM.",
      "tags": []
    },
    {
      "name": "UnicodeNormalizationForm",
      "kind": "TypeAliasDeclaration",
      "signature": "export type UnicodeNormalizationForm = \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\";",
      "doc": "The stanard normalization forms.",
      "tags": []
    },
    {
      "name": "Utf8ErrorReason",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Utf8ErrorReason = \"UNEXPECTED_CONTINUE\" | \"BAD_PREFIX\" | \"OVERRUN\" |\n    \"MISSING_CONTINUE\" | \"OUT_OF_RANGE\" | \"UTF16_SURROGATE\" | \"OVERLONG\";",
      "doc": "When using the UTF-8 error API the following errors can be intercepted\nand processed as the %%reason%% passed to the [[Utf8ErrorFunc]].\n\n**``\"UNEXPECTED_CONTINUE\"``** - a continuation byte was present where there\nwas nothing to continue.\n\n**``\"BAD_PREFIX\"``** - an invalid (non-continuation) byte to start a\nUTF-8 codepoint was found.\n\n**``\"OVERRUN\"``** - the string is too short to process the expected\ncodepoint length.\n\n**``\"MISSING_CONTINUE\"``** - a missing continuation byte was expected but\nnot found. The %%offset%% indicates the index the continuation byte\nwas expected at.\n\n**``\"OUT_OF_RANGE\"``** - the computed code point is outside the range\nfor UTF-8. The %%badCodepoint%% indicates the computed codepoint, which was\noutside the valid UTF-8 range.\n\n**``\"UTF16_SURROGATE\"``** - the UTF-8 strings contained a UTF-16 surrogate\npair. The %%badCodepoint%% is the computed codepoint, which was inside the\nUTF-16 surrogate range.\n\n**``\"OVERLONG\"``** - the string is an overlong representation. The\n%%badCodepoint%% indicates the computed codepoint, which has already\nbeen bounds checked.",
      "tags": [
        {
          "tagName": "returns",
          "text": "string"
        }
      ]
    },
    {
      "name": "RlpStructuredData",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RlpStructuredData = string | Array<RlpStructuredData>;",
      "doc": "An RLP-encoded structure.",
      "tags": []
    },
    {
      "name": "RlpStructuredDataish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RlpStructuredDataish = string | Uint8Array | Array<RlpStructuredDataish>;",
      "doc": "An RLP-encoded structure, which allows Uint8Array.",
      "tags": []
    },
    {
      "name": "GetUrlResponse",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GetUrlResponse = {\n    statusCode: number,\n    statusMessage: string,\n    headers: Record<string, string>,\n    body: null | Uint8Array\n};",
      "doc": "An environment's implementation of ``getUrl`` must return this type.",
      "tags": []
    },
    {
      "name": "FetchPreflightFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchPreflightFunc = (req: FetchRequest) => Promise<FetchRequest>;",
      "doc": "Called before any network request, allowing updated headers (e.g. Bearer tokens), etc.",
      "tags": []
    },
    {
      "name": "FetchProcessFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchProcessFunc = (req: FetchRequest, resp: FetchResponse) => Promise<FetchResponse>;",
      "doc": "Called on the response, allowing client-based throttling logic or post-processing.",
      "tags": []
    },
    {
      "name": "FetchRetryFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchRetryFunc = (req: FetchRequest, resp: FetchResponse, attempt: number) => Promise<boolean>;",
      "doc": "Called prior to each retry; return true to retry, false to abort.",
      "tags": []
    },
    {
      "name": "FetchGatewayFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchGatewayFunc = (url: string, signal?: FetchCancelSignal) => Promise<FetchRequest | FetchResponse>;",
      "doc": "Called on Gateway URLs.",
      "tags": []
    },
    {
      "name": "FetchGetUrlFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchGetUrlFunc = (req: FetchRequest, signal?: FetchCancelSignal) => Promise<GetUrlResponse>;",
      "doc": "Used to perform a fetch; use this to override the underlying network\nfetch layer. In NodeJS, the default uses the \"http\" and \"https\" libraries\nand in the browser ``fetch`` is used. If you wish to use Axios, this is\nhow you would register it.",
      "tags": []
    },
    {
      "name": "EthersError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  A short message describing the error, with minimal additional\n     *  details.\n     */\n    shortMessage: string;\n\n    /**\n     *  Additio",
      "doc": "All errors in Ethers include properties to assist in\nmachine-readable errors.",
      "tags": []
    },
    {
      "name": "UnknownError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}",
      "doc": "This Error is a catch-all for when there is no way for Ethers to\nknow what the underlying problem is.",
      "tags": []
    },
    {
      "name": "NotImplementedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}",
      "doc": "This Error is mostly used as a stub for functionality that is\nintended for the future, but is currently not implemented.",
      "tags": []
    },
    {
      "name": "UnsupportedOperationError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}",
      "doc": "This Error indicates that the attempted operation is not supported.\n\nThis could range from a specific JSON-RPC end-point not supporting\na feature to a specific configuration of an object prohibiting the\noperation.\n\nFor example, a [[Wallet]] with no connected [[Provider]] is unable\nto send a transaction.",
      "tags": []
    },
    {
      "name": "NetworkError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    /**\n     *  The network event.\n     */\n    event: string;\n}",
      "doc": "This Error indicates a problem connecting to a network.",
      "tags": []
    },
    {
      "name": "ServerError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}",
      "doc": "This Error indicates there was a problem fetching a resource from\na server.",
      "tags": []
    },
    {
      "name": "TimeoutError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}",
      "doc": "This Error indicates that the timeout duration has expired and\nthat the operation has been implicitly cancelled.\n\nThe side-effect of the operation may still occur, as this\ngenerally means a request has been sent and there has simply\nbeen no response to indicate whether it was processed or not.",
      "tags": []
    },
    {
      "name": "BadDataError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}",
      "doc": "This Error indicates that a provided set of data cannot\nbe correctly interpreted.",
      "tags": []
    },
    {
      "name": "CancelledError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CancelledError extends EthersError<\"CANCELLED\"> {\n}",
      "doc": "This Error indicates that the operation was cancelled by a\nprogrammatic call, for example to ``cancel()``.",
      "tags": []
    },
    {
      "name": "BufferOverrunError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n",
      "doc": "This Error indicates an attempt was made to read outside the bounds\nof protected data.\n\nMost operations in Ethers are protected by bounds checks, to mitigate\nexploits when parsing data.",
      "tags": []
    },
    {
      "name": "NumericFaultError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}",
      "doc": "This Error indicates an operation which would result in incorrect\narithmetic output has occurred.\n\nFor example, trying to divide by zero or using a ``uint8`` to store\na negative value.",
      "tags": []
    },
    {
      "name": "InvalidArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}",
      "doc": "This Error indicates an incorrect type or value was passed to\na function or method.",
      "tags": []
    },
    {
      "name": "MissingArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}",
      "doc": "This Error indicates there were too few arguments were provided.",
      "tags": []
    },
    {
      "name": "UnexpectedArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}",
      "doc": "This Error indicates too many arguments were provided.",
      "tags": []
    },
    {
      "name": "CallExceptionError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-reada",
      "doc": "This **Error** indicates a transaction reverted.",
      "tags": []
    },
    {
      "name": "InsufficientFundsError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "The sending account has insufficient funds to cover the\nentire transaction cost.",
      "tags": []
    },
    {
      "name": "NonceExpiredError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "The sending account has already used this nonce in a\ntransaction that has been included.",
      "tags": []
    },
    {
      "name": "OffchainFaultError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}",
      "doc": "A CCIP-read exception, which cannot be recovered from or\nbe further processed.",
      "tags": []
    },
    {
      "name": "ReplacementUnderpricedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "An attempt was made to replace a transaction, but with an\ninsufficient additional fee to afford evicting the old\ntransaction from the memory pool.",
      "tags": []
    },
    {
      "name": "TransactionReplacedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was repla",
      "doc": "A pending transaction was replaced by another.",
      "tags": []
    },
    {
      "name": "UnconfiguredNameError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}",
      "doc": "This Error indicates an ENS name was used, but the name has not\nbeen configured.\n\nThis could indicate an ENS name is unowned or that the current\naddress being pointed to is the [[ZeroAddress]].",
      "tags": []
    },
    {
      "name": "ActionRejectedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n ",
      "doc": "This Error indicates a request was rejected by the user.\n\nIn most clients (such as MetaMask), when an operation requires user\nauthorization (such as ``signer.sendTransaction``), the client\npresents a dialog box to the user. If the user denies the request\nthis error is thrown.",
      "tags": []
    },
    {
      "name": "CodedEthersError",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T ex",
      "doc": "A conditional type that transforms the [[ErrorCode]] T into\nits EthersError type.",
      "tags": [
        {
          "tagName": "flatworm-skip-docs",
          "text": ""
        }
      ]
    },
    {
      "name": "CallExceptionAction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"sendTransaction\" | \"unknown\";",
      "doc": "The action that resulted in the call exception.",
      "tags": []
    },
    {
      "name": "CallExceptionTransaction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};",
      "doc": "The related transaction that caused the error.",
      "tags": []
    },
    {
      "name": "EventEmitterable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EventEmitterable<T> {\n    /**\n     *  Registers a %%listener%% that is called whenever the\n     *  %%event%% occurs until unregistered.\n     */\n    on(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Registers a %%listener%% that is called the next time\n     *  %%event",
      "doc": "An **EventEmitterable** behaves similar to an EventEmitter\nexcept provides async access to its methods.\n\nAn EventEmitter implements the observer pattern.",
      "tags": []
    },
    {
      "name": "Listener",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Listener = (...args: Array<any>) => void;",
      "doc": "A callback function called when a an event is triggered.",
      "tags": []
    },
    {
      "name": "CrowdsaleAccount",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CrowdsaleAccount = {\n    privateKey: string;\n    address: string;\n}",
      "doc": "The data stored within a JSON Crowdsale wallet is fairly\nminimal.",
      "tags": []
    },
    {
      "name": "KeystoreAccount",
      "kind": "TypeAliasDeclaration",
      "signature": "export type KeystoreAccount = {\n    address: string;\n    privateKey: string;\n    mnemonic?: {\n        path?: string;\n        locale?: string;\n        entropy: string;\n    }\n};",
      "doc": "The contents of a JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "EncryptOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type EncryptOptions = {\n   progressCallback?: ProgressCallback;\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}",
      "doc": "The parameters to use when encrypting a JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "version",
      "kind": "VariableDeclaration",
      "signature": "version: string = \"6.15.0\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "wordlists",
      "kind": "VariableDeclaration",
      "signature": "wordlists: Record<string, Wordlist> = {\n  cz: LangCz.wordlist(),\n  en: LangEn.wordlist(),\n  es: LangEs.wordlist(),\n  fr: LangFr.wordlist(),\n  it: LangIt.wordlist(),\n  pt: LangPt.wordlist(),\n  ja: LangJa.wordlist(),\n  ko: LangKo.wordlist(),\n  zh_cn: LangZh.wordlist(\"cn\"),\n  zh_tw: LangZh.wordlist(\"tw",
      "doc": "",
      "tags": []
    },
    {
      "name": "LangCz",
      "kind": "ClassDeclaration",
      "signature": "export class LangCz extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the Czech language Wordlist.\n     *\n     *  Using the constructor should be unnecessary, instead use the\n     *  [[wordlist]] singleton method.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"cz\", words,",
      "doc": "The [[link-bip39-cz]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangEs",
      "kind": "ClassDeclaration",
      "signature": "export class LangEs extends WordlistOwlA {\n\n    /**\n     *  Creates a new instance of the Spanish language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEs]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"es\", words, a",
      "doc": "The [[link-bip39-es]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangFr",
      "kind": "ClassDeclaration",
      "signature": "export class LangFr extends WordlistOwlA {\n\n    /**\n     *  Creates a new instance of the French language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langFr]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"fr\", words, ac",
      "doc": "The [[link-bip39-fr]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangJa",
      "kind": "ClassDeclaration",
      "signature": "export class LangJa extends Wordlist {\n\n    /**\n     *  Creates a new instance of the Japanese language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langJa]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"ja\"); }\n\n    get",
      "doc": "The [[link-bip39-ja]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangKo",
      "kind": "ClassDeclaration",
      "signature": "export class LangKo extends Wordlist {\n\n    /**\n     *  Creates a new instance of the Korean language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langKo]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() {\n        super(\"ko\");\n    ",
      "doc": "The [[link-bip39-ko]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangIt",
      "kind": "ClassDeclaration",
      "signature": "export class LangIt extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the Italian language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langIt]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"it\", words, ch",
      "doc": "The [[link-bip39-it]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangPt",
      "kind": "ClassDeclaration",
      "signature": "export class LangPt extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the Portuguese language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langPt]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"pt\", words,",
      "doc": "The [[link-bip39-pt]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangZh",
      "kind": "ClassDeclaration",
      "signature": "export class LangZh extends Wordlist {\n\n    /**\n     *  Creates a new instance of the Chinese language Wordlist for\n     *  the %%dialect%%, either ``\"cn\"`` or ``\"tw\"`` for simplified\n     *  or traditional, respectively.\n     *\n     *  This should be unnecessary most of the time as the exported\n   ",
      "doc": "The [[link-bip39-zh_cn]] and [[link-bip39-zh_tw]] for\n[mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "wordlists",
      "kind": "VariableDeclaration",
      "signature": "wordlists: Record<string, Wordlist> = {\n  en: LangEn.wordlist(),\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "Wordlist",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Wordlist {\n    locale!: string;\n\n    /**\n     *  Creates a new Wordlist instance.\n     *\n     *  Sub-classes MUST call this if they provide their own constructor,\n     *  passing in the locale string of the language.\n     *\n     *  Generally there is no need to create instances",
      "doc": "A Wordlist represents a collection of language-specific\nwords used to encode and devoce [[link-bip-39]] encoded data\nby mapping words to 11-bit values and vice versa.",
      "tags": []
    },
    {
      "name": "WordlistOwlA",
      "kind": "ClassDeclaration",
      "signature": "export class WordlistOwlA extends WordlistOwl {\n    #accent: string;\n\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%\n     *  and %%accent%% data and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, accent: string, checksum: str",
      "doc": "An OWL-A format Wordlist extends the OWL format to add an\noverlay onto an OWL format Wordlist to support diacritic\nmarks.\n\nThis class is generally not useful to most developers as\nit is used mainly internally to keep Wordlists for languages\nbased on latin-1 small.\n\nIf necessary, there are tools within the ``generation/`` folder\nto create the necessary data.",
      "tags": []
    },
    {
      "name": "WordlistOwl",
      "kind": "ClassDeclaration",
      "signature": "export class WordlistOwl extends Wordlist {\n    #data: string;\n    #checksum: string;\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, checksum: string) {\n        super(",
      "doc": "An OWL format Wordlist is an encoding method that exploits\nthe general locality of alphabetically sorted words to\nachieve a simple but effective means of compression.\n\nThis class is generally not useful to most developers as\nit is used mainly internally to keep Wordlists for languages\nbased on ASCII-7 small.\n\nIf necessary, there are tools within the ``generation/`` folder\nto create the necessary data.",
      "tags": []
    },
    {
      "name": "LangZh",
      "kind": "ClassDeclaration",
      "signature": "export class LangZh extends Wordlist {\n\n    /**\n     *  Creates a new instance of the Chinese language Wordlist for\n     *  the %%dialect%%, either ``\"cn\"`` or ``\"tw\"`` for simplified\n     *  or traditional, respectively.\n     *\n     *  This should be unnecessary most of the time as the exported\n   ",
      "doc": "The [[link-bip39-zh_cn]] and [[link-bip39-zh_tw]] for\n[mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangPt",
      "kind": "ClassDeclaration",
      "signature": "export class LangPt extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the Portuguese language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langPt]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"pt\", words,",
      "doc": "The [[link-bip39-pt]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangKo",
      "kind": "ClassDeclaration",
      "signature": "export class LangKo extends Wordlist {\n\n    /**\n     *  Creates a new instance of the Korean language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langKo]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() {\n        super(\"ko\");\n    ",
      "doc": "The [[link-bip39-ko]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangJa",
      "kind": "ClassDeclaration",
      "signature": "export class LangJa extends Wordlist {\n\n    /**\n     *  Creates a new instance of the Japanese language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langJa]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"ja\"); }\n\n    get",
      "doc": "The [[link-bip39-ja]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangIt",
      "kind": "ClassDeclaration",
      "signature": "export class LangIt extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the Italian language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langIt]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"it\", words, ch",
      "doc": "The [[link-bip39-it]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangFr",
      "kind": "ClassDeclaration",
      "signature": "export class LangFr extends WordlistOwlA {\n\n    /**\n     *  Creates a new instance of the French language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langFr]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"fr\", words, ac",
      "doc": "The [[link-bip39-fr]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangEs",
      "kind": "ClassDeclaration",
      "signature": "export class LangEs extends WordlistOwlA {\n\n    /**\n     *  Creates a new instance of the Spanish language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEs]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"es\", words, a",
      "doc": "The [[link-bip39-es]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangEn",
      "kind": "ClassDeclaration",
      "signature": "export class LangEn extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the English language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEn]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"en\", words, ch",
      "doc": "The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "LangCz",
      "kind": "ClassDeclaration",
      "signature": "export class LangCz extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the Czech language Wordlist.\n     *\n     *  Using the constructor should be unnecessary, instead use the\n     *  [[wordlist]] singleton method.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"cz\", words,",
      "doc": "The [[link-bip39-cz]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "Wordlist",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Wordlist {\n    locale!: string;\n\n    /**\n     *  Creates a new Wordlist instance.\n     *\n     *  Sub-classes MUST call this if they provide their own constructor,\n     *  passing in the locale string of the language.\n     *\n     *  Generally there is no need to create instances",
      "doc": "A Wordlist represents a collection of language-specific\nwords used to encode and devoce [[link-bip-39]] encoded data\nby mapping words to 11-bit values and vice versa.",
      "tags": []
    },
    {
      "name": "LangEn",
      "kind": "ClassDeclaration",
      "signature": "export class LangEn extends WordlistOwl {\n\n    /**\n     *  Creates a new instance of the English language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEn]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"en\", words, ch",
      "doc": "The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/wordlists"
        }
      ]
    },
    {
      "name": "WordlistOwl",
      "kind": "ClassDeclaration",
      "signature": "export class WordlistOwl extends Wordlist {\n    #data: string;\n    #checksum: string;\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, checksum: string) {\n        super(",
      "doc": "An OWL format Wordlist is an encoding method that exploits\nthe general locality of alphabetically sorted words to\nachieve a simple but effective means of compression.\n\nThis class is generally not useful to most developers as\nit is used mainly internally to keep Wordlists for languages\nbased on ASCII-7 small.\n\nIf necessary, there are tools within the ``generation/`` folder\nto create the necessary data.",
      "tags": []
    },
    {
      "name": "WordlistOwlA",
      "kind": "ClassDeclaration",
      "signature": "export class WordlistOwlA extends WordlistOwl {\n    #accent: string;\n\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%\n     *  and %%accent%% data and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, accent: string, checksum: str",
      "doc": "An OWL-A format Wordlist extends the OWL format to add an\noverlay onto an OWL format Wordlist to support diacritic\nmarks.\n\nThis class is generally not useful to most developers as\nit is used mainly internally to keep Wordlists for languages\nbased on latin-1 small.\n\nIf necessary, there are tools within the ``generation/`` folder\nto create the necessary data.",
      "tags": []
    },
    {
      "name": "wordlists",
      "kind": "VariableDeclaration",
      "signature": "wordlists: Record<string, Wordlist> = {\n  cz: LangCz.wordlist(),\n  en: LangEn.wordlist(),\n  es: LangEs.wordlist(),\n  fr: LangFr.wordlist(),\n  it: LangIt.wordlist(),\n  pt: LangPt.wordlist(),\n  ja: LangJa.wordlist(),\n  ko: LangKo.wordlist(),\n  zh_cn: LangZh.wordlist(\"cn\"),\n  zh_tw: LangZh.wordlist(\"tw",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeOwlA(data: string, accents: string): Array<string> {\n    let words = decodeOwl(data).join(\",\");\n\n    // Inject the accents\n    accents.split(/,/g).forEach((accent) => {\n\n        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);\n        assertArgument(match !== null, ",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "decodeOwlA.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwlA.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "decode",
      "kind": "FunctionDeclaration",
      "signature": "export function decode(data: string, subs: string): Array<string> {\n\n    // Replace all the substitutions with their expanded form\n    for (let i = subsChrs.length - 1; i >= 0; i--) {\n        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));\n    }\n\n    // Get all tle clumps; eac",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "decode.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "decode.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "decodeOwl",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeOwl(data: string): Array<string> {\n    assertArgument(data[0] === \"0\", \"unsupported auwl data\", \"data\", data);\n\n    return decode(\n        data.substring(1 + 2 * subsChrs.length),\n        data.substring(1, 1 + 2 * subsChrs.length));\n}",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "decodeOwl.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeOwl.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "decodeBits",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBits(width: number, data: string): Array<number> {\n    const maxValue = (1 << width) - 1;\n    const result: Array<number> = [ ];\n    let accum = 0, bits = 0, flood = 0;\n    for (let i = 0; i < data.length; i++) {\n\n        // Accumulate 6 bits of data\n        accum = ((accum << ",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "decodeBits.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBits.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "extractAccents",
      "kind": "FunctionDeclaration",
      "signature": "export function extractAccents(words: Array<string>): { accents: Array<AccentSet>, words: Array<string> } {\n\n    // Build a list that maps accents to the letters it can follow\n    const followsMap: Map<number, string> = new Map();\n    for (const word of words) {\n        for (let i = 0; i < word.leng",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeOwl",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeOwl(words: Array<string>): { subs: string, data: string } {\n\n    // Fold the sorted words by indicating delta for the first 2 letters\n    let data = camelcase(fold(fold(words, \":\"), \";\"));\n\n    // Replace semicolons with counts (e.g. \";;;\" with \"3\")\n    data = data.replace(/(;+",
      "doc": "",
      "tags": []
    },
    {
      "name": "BitWriter",
      "kind": "ClassDeclaration",
      "signature": "export class BitWriter {\n    readonly width: number;\n    readonly #data: Array<number>;\n\n    #bitLength: number;\n\n    constructor(width: number) {\n        this.width = width;\n        this.#data = [ ];\n        this.#bitLength = 0;\n    }\n\n    write(value: number): void {\n        const maxValue = ((1 <",
      "doc": "",
      "tags": []
    },
    {
      "name": "AccentSet",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AccentSet {\n    accent: number;\n    follows: string;\n    positions: Array<number>;\n    positionsLength: number;\n    positionData: string;\n    positionDataLength: number;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "Wallet",
      "kind": "ClassDeclaration",
      "signature": "export class Wallet extends BaseWallet {\n\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */\n    constructor(key: string | SigningKey, provider?: null | Provider) {\n        if (typeof(key) === \"string\" && !key.startsWith(\"0x\")) {\n      ",
      "doc": "A **Wallet** manages a single private key which is used to sign\ntransactions, messages and other common payloads.\n\nThis class is generally the main entry point for developers\nthat wish to use a private key directly, as it can create\ninstances from a large variety of common sources, including\nraw private key, [[link-bip-39]] mnemonics and encrypte JSON\nwallets.",
      "tags": []
    },
    {
      "name": "looseArrayify",
      "kind": "FunctionDeclaration",
      "signature": "export function looseArrayify(hexString: string): Uint8Array {\n    if (typeof(hexString) === \"string\" && !hexString.startsWith(\"0x\")) {\n        hexString = \"0x\" + hexString;\n    }\n    return getBytesCopy(hexString);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "looseArrayify.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "zpad",
      "kind": "FunctionDeclaration",
      "signature": "export function zpad(value: String | number, length: number): String {\n    value = String(value);\n    while (value.length < length) { value = '0' + value; }\n    return value;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.charAt",
      "kind": "MethodSignature",
      "signature": "charAt(pos:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.charCodeAt",
      "kind": "MethodSignature",
      "signature": "charCodeAt(index:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.concat",
      "kind": "MethodSignature",
      "signature": "concat(...strings:string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchString:string,position?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchString:string,position?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.localeCompare",
      "kind": "MethodSignature",
      "signature": "localeCompare(that:string):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.match",
      "kind": "MethodSignature",
      "signature": "match(regexp:string|RegExp):RegExpMatchArray|null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.replace",
      "kind": "MethodSignature",
      "signature": "replace(searchValue:string|RegExp,replaceValue:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.search",
      "kind": "MethodSignature",
      "signature": "search(regexp:string|RegExp):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.split",
      "kind": "MethodSignature",
      "signature": "split(separator:string|RegExp,limit?:number):string[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.substring",
      "kind": "MethodSignature",
      "signature": "substring(start:number,end?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.toLowerCase",
      "kind": "MethodSignature",
      "signature": "toLowerCase():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.toLocaleLowerCase",
      "kind": "MethodSignature",
      "signature": "toLocaleLowerCase(locales?:string|string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.toUpperCase",
      "kind": "MethodSignature",
      "signature": "toUpperCase():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.toLocaleUpperCase",
      "kind": "MethodSignature",
      "signature": "toLocaleUpperCase(locales?:string|string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.trim",
      "kind": "MethodSignature",
      "signature": "trim():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.substr",
      "kind": "MethodSignature",
      "signature": "substr(from:number,length?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.codePointAt",
      "kind": "MethodSignature",
      "signature": "codePointAt(pos:number):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchString:string,position?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.endsWith",
      "kind": "MethodSignature",
      "signature": "endsWith(searchString:string,endPosition?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.normalize",
      "kind": "MethodSignature",
      "signature": "normalize(form:\"NFC\"|\"NFD\"|\"NFKC\"|\"NFKD\"):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.repeat",
      "kind": "MethodSignature",
      "signature": "repeat(count:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.startsWith",
      "kind": "MethodSignature",
      "signature": "startsWith(searchString:string,position?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.anchor",
      "kind": "MethodSignature",
      "signature": "anchor(name:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.big",
      "kind": "MethodSignature",
      "signature": "big():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.blink",
      "kind": "MethodSignature",
      "signature": "blink():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.bold",
      "kind": "MethodSignature",
      "signature": "bold():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.fixed",
      "kind": "MethodSignature",
      "signature": "fixed():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.fontcolor",
      "kind": "MethodSignature",
      "signature": "fontcolor(color:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.fontsize",
      "kind": "MethodSignature",
      "signature": "fontsize(size:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.italics",
      "kind": "MethodSignature",
      "signature": "italics():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.link",
      "kind": "MethodSignature",
      "signature": "link(url:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.small",
      "kind": "MethodSignature",
      "signature": "small():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.strike",
      "kind": "MethodSignature",
      "signature": "strike():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.sub",
      "kind": "MethodSignature",
      "signature": "sub():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.sup",
      "kind": "MethodSignature",
      "signature": "sup():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.padStart",
      "kind": "MethodSignature",
      "signature": "padStart(maxLength:number,fillString?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.padEnd",
      "kind": "MethodSignature",
      "signature": "padEnd(maxLength:number,fillString?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.trimEnd",
      "kind": "MethodSignature",
      "signature": "trimEnd():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.trimStart",
      "kind": "MethodSignature",
      "signature": "trimStart():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.trimLeft",
      "kind": "MethodSignature",
      "signature": "trimLeft():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.trimRight",
      "kind": "MethodSignature",
      "signature": "trimRight():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.matchAll",
      "kind": "MethodSignature",
      "signature": "matchAll(regexp:RegExp):RegExpStringIterator<RegExpExecArray>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():StringIterator<string>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "zpad.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "getPassword",
      "kind": "FunctionDeclaration",
      "signature": "export function getPassword(password: string | Uint8Array): Uint8Array {\n    if (typeof(password) === 'string') {\n        return toUtf8Bytes(password, \"NFKC\");\n    }\n    return getBytesCopy(password);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPassword.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "spelunk",
      "kind": "FunctionDeclaration",
      "signature": "export function spelunk<T>(object: any, _path: string): T {\n\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n    assertArgument(match != null, \"invalid path\", \"path\", _path);\n\n    const path = match[1];\n    const type = match[3];\n    const reqd = (match[4] === \"!\");\n\n    let cur",
      "doc": "",
      "tags": []
    },
    {
      "name": "Mnemonic",
      "kind": "ClassDeclaration",
      "signature": "export class Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    readonly phrase!: string;\n\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     * ",
      "doc": "A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\nseeds and convert between phrases and entropy.",
      "tags": []
    },
    {
      "name": "isKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export function isKeystoreJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version): 0);\n        if (version === 3) { return true; }\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%json%% is a valid JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJsonSync",
      "kind": "FunctionDeclaration",
      "signature": "export function decryptKeystoreJsonSync(json: string, _password: string | Uint8Array): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dk",
      "doc": "Returns the account details for the JSON Keystore Wallet %%json%%\nusing %%password%%.\n\nIt is preferred to use the [async version](decryptKeystoreJson)\ninstead, which allows a [[ProgressCallback]] to keep the user informed\nas to the decryption status.\n\nThis method will block the event loop (freezing all UI) until decryption\nis complete, which can take quite some time, depending on the wallet\nparamters and platform.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function decryptKeystoreJson(json: string, _password: string | Uint8Array, progress?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pb",
      "doc": "Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n%%password%%.\n\nIf provided, %%progress%% will be called periodically during the\ndecrpytion to provide feedback, and if the function returns\n``false`` will halt decryption.\n\nThe %%progressCallback%% will **always** receive ``0`` before\ndecryption begins and ``1`` when complete.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJsonSync",
      "kind": "FunctionDeclaration",
      "signature": "export function encryptKeystoreJsonSync(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): string {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = scryptSync(",
      "doc": "Return the JSON Keystore Wallet for %%account%% encrypted with\n%%password%%.\n\nThe %%options%% can be used to tune the password-based key\nderivation function parameters, explicitly set the random values\nused. Any provided [[ProgressCallback]] is ignord.",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function encryptKeystoreJson(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): Promise<string> {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = ",
      "doc": "Resolved to the JSON Keystore Wallet for %%account%% encrypted\nwith %%password%%.\n\nThe %%options%% can be used to tune the password-based key\nderivation function parameters, explicitly set the random values\nused and provide a [[ProgressCallback]] to receive periodic updates\non the completion status..",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "KeystoreAccount",
      "kind": "TypeAliasDeclaration",
      "signature": "export type KeystoreAccount = {\n    address: string;\n    privateKey: string;\n    mnemonic?: {\n        path?: string;\n        locale?: string;\n        entropy: string;\n    }\n};",
      "doc": "The contents of a JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "EncryptOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type EncryptOptions = {\n   progressCallback?: ProgressCallback;\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}",
      "doc": "The parameters to use when encrypting a JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "isCrowdsaleJson",
      "kind": "FunctionDeclaration",
      "signature": "export function isCrowdsaleJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) { return true; }\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%json%% is a valid JSON Crowdsale wallet.",
      "tags": []
    },
    {
      "name": "decryptCrowdsaleJson",
      "kind": "FunctionDeclaration",
      "signature": "export function decryptCrowdsaleJson(json: string, _password: string | Uint8Array): CrowdsaleAccount {\n    const data = JSON.parse(json);\n    const password = getPassword(_password);\n\n    // Ethereum Address\n    const address = getAddress(spelunk(data, \"ethaddr:string!\"));\n\n    // Encrypted Seed\n   ",
      "doc": "Before Ethereum launched, it was necessary to create a wallet\nformat for backers to use, which would be used to receive ether\nas a reward for contributing to the project.\n\nThe [[link-crowdsale]] format is now obsolete, but it is still\nuseful to support and the additional code is fairly trivial as\nall the primitives required are used through core portions of\nthe library.",
      "tags": []
    },
    {
      "name": "CrowdsaleAccount",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CrowdsaleAccount = {\n    privateKey: string;\n    address: string;\n}",
      "doc": "The data stored within a JSON Crowdsale wallet is fairly\nminimal.",
      "tags": []
    },
    {
      "name": "BaseWallet",
      "kind": "ClassDeclaration",
      "signature": "export class BaseWallet extends AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    readonly address!: string;\n\n    readonly #signingKey: SigningKey;\n\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%",
      "doc": "The **BaseWallet** is a stream-lined implementation of a\n[[Signer]] that operates with a private key.\n\nIt is preferred to use the [[Wallet]] class, as it offers\nadditional functionality and simplifies loading a variety\nof JSON formats, Mnemonic Phrases, etc.\n\nThis class may be of use for those attempting to implement\na minimal Signer.",
      "tags": []
    },
    {
      "name": "defaultPath",
      "kind": "VariableDeclaration",
      "signature": "defaultPath: string = \"m/44'/60'/0'/0/0\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAccountPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${ index }'/0/0`;\n}",
      "doc": "Returns the [[link-bip-32]] path for the account at %%index%%.\n\nThis is the pattern used by wallets like Ledger.\n\nThere is also an [alternate pattern](getIndexedAccountPath) used by\nsome software.",
      "tags": []
    },
    {
      "name": "getIndexedAccountPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getIndexedAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${ index}`;\n}",
      "doc": "Returns the path using an alternative pattern for deriving accounts,\nat %%index%%.\n\nThis derivation path uses the //index// component rather than the\n//account// component to derive sequential accounts.\n\nThis is the pattern used by wallets like MetaMask.",
      "tags": []
    },
    {
      "name": "HDNodeWallet",
      "kind": "ClassDeclaration",
      "signature": "export class HDNodeWallet extends BaseWallet {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with ",
      "doc": "An **HDNodeWallet** is a [[Signer]] backed by the private key derived\nfrom an HD Node using the [[link-bip-32]] stantard.\n\nAn HD Node forms a hierarchal structure with each HD Node having a\nprivate key and the ability to derive child HD Nodes, defined by\na path indicating the index of each child.",
      "tags": []
    },
    {
      "name": "HDNodeVoidWallet",
      "kind": "ClassDeclaration",
      "signature": "export class HDNodeVoidWallet extends VoidSigner {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal w",
      "doc": "A **HDNodeVoidWallet** cannot sign, but provides access to\nthe children nodes of a [[link-bip-32]] HD wallet addresses.\n\nThe can be created by using an extended ``xpub`` key to\n[[HDNodeWallet_fromExtendedKey]] or by \n[nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].",
      "tags": []
    },
    {
      "name": "isCrowdsaleJson",
      "kind": "FunctionDeclaration",
      "signature": "export function isCrowdsaleJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) { return true; }\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%json%% is a valid JSON Crowdsale wallet.",
      "tags": []
    },
    {
      "name": "decryptCrowdsaleJson",
      "kind": "FunctionDeclaration",
      "signature": "export function decryptCrowdsaleJson(json: string, _password: string | Uint8Array): CrowdsaleAccount {\n    const data = JSON.parse(json);\n    const password = getPassword(_password);\n\n    // Ethereum Address\n    const address = getAddress(spelunk(data, \"ethaddr:string!\"));\n\n    // Encrypted Seed\n   ",
      "doc": "Before Ethereum launched, it was necessary to create a wallet\nformat for backers to use, which would be used to receive ether\nas a reward for contributing to the project.\n\nThe [[link-crowdsale]] format is now obsolete, but it is still\nuseful to support and the additional code is fairly trivial as\nall the primitives required are used through core portions of\nthe library.",
      "tags": []
    },
    {
      "name": "isKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export function isKeystoreJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version): 0);\n        if (version === 3) { return true; }\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%json%% is a valid JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJsonSync",
      "kind": "FunctionDeclaration",
      "signature": "export function decryptKeystoreJsonSync(json: string, _password: string | Uint8Array): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dk",
      "doc": "Returns the account details for the JSON Keystore Wallet %%json%%\nusing %%password%%.\n\nIt is preferred to use the [async version](decryptKeystoreJson)\ninstead, which allows a [[ProgressCallback]] to keep the user informed\nas to the decryption status.\n\nThis method will block the event loop (freezing all UI) until decryption\nis complete, which can take quite some time, depending on the wallet\nparamters and platform.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function decryptKeystoreJson(json: string, _password: string | Uint8Array, progress?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pb",
      "doc": "Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n%%password%%.\n\nIf provided, %%progress%% will be called periodically during the\ndecrpytion to provide feedback, and if the function returns\n``false`` will halt decryption.\n\nThe %%progressCallback%% will **always** receive ``0`` before\ndecryption begins and ``1`` when complete.",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decryptKeystoreJson.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function encryptKeystoreJson(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): Promise<string> {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = ",
      "doc": "Resolved to the JSON Keystore Wallet for %%account%% encrypted\nwith %%password%%.\n\nThe %%options%% can be used to tune the password-based key\nderivation function parameters, explicitly set the random values\nused and provide a [[ProgressCallback]] to receive periodic updates\non the completion status..",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJson.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encryptKeystoreJsonSync",
      "kind": "FunctionDeclaration",
      "signature": "export function encryptKeystoreJsonSync(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): string {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = scryptSync(",
      "doc": "Return the JSON Keystore Wallet for %%account%% encrypted with\n%%password%%.\n\nThe %%options%% can be used to tune the password-based key\nderivation function parameters, explicitly set the random values\nused. Any provided [[ProgressCallback]] is ignord.",
      "tags": []
    },
    {
      "name": "Mnemonic",
      "kind": "ClassDeclaration",
      "signature": "export class Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    readonly phrase!: string;\n\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     * ",
      "doc": "A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\nseeds and convert between phrases and entropy.",
      "tags": []
    },
    {
      "name": "Wallet",
      "kind": "ClassDeclaration",
      "signature": "export class Wallet extends BaseWallet {\n\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */\n    constructor(key: string | SigningKey, provider?: null | Provider) {\n        if (typeof(key) === \"string\" && !key.startsWith(\"0x\")) {\n      ",
      "doc": "A **Wallet** manages a single private key which is used to sign\ntransactions, messages and other common payloads.\n\nThis class is generally the main entry point for developers\nthat wish to use a private key directly, as it can create\ninstances from a large variety of common sources, including\nraw private key, [[link-bip-39]] mnemonics and encrypte JSON\nwallets.",
      "tags": []
    },
    {
      "name": "CrowdsaleAccount",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CrowdsaleAccount = {\n    privateKey: string;\n    address: string;\n}",
      "doc": "The data stored within a JSON Crowdsale wallet is fairly\nminimal.",
      "tags": []
    },
    {
      "name": "KeystoreAccount",
      "kind": "TypeAliasDeclaration",
      "signature": "export type KeystoreAccount = {\n    address: string;\n    privateKey: string;\n    mnemonic?: {\n        path?: string;\n        locale?: string;\n        entropy: string;\n    }\n};",
      "doc": "The contents of a JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "EncryptOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type EncryptOptions = {\n   progressCallback?: ProgressCallback;\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}",
      "doc": "The parameters to use when encrypting a JSON Keystore Wallet.",
      "tags": []
    },
    {
      "name": "getAccountPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${ index }'/0/0`;\n}",
      "doc": "Returns the [[link-bip-32]] path for the account at %%index%%.\n\nThis is the pattern used by wallets like Ledger.\n\nThere is also an [alternate pattern](getIndexedAccountPath) used by\nsome software.",
      "tags": []
    },
    {
      "name": "getIndexedAccountPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getIndexedAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${ index}`;\n}",
      "doc": "Returns the path using an alternative pattern for deriving accounts,\nat %%index%%.\n\nThis derivation path uses the //index// component rather than the\n//account// component to derive sequential accounts.\n\nThis is the pattern used by wallets like MetaMask.",
      "tags": []
    },
    {
      "name": "defaultPath",
      "kind": "VariableDeclaration",
      "signature": "defaultPath: string = \"m/44'/60'/0'/0/0\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "HDNodeWallet",
      "kind": "ClassDeclaration",
      "signature": "export class HDNodeWallet extends BaseWallet {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with ",
      "doc": "An **HDNodeWallet** is a [[Signer]] backed by the private key derived\nfrom an HD Node using the [[link-bip-32]] stantard.\n\nAn HD Node forms a hierarchal structure with each HD Node having a\nprivate key and the ability to derive child HD Nodes, defined by\na path indicating the index of each child.",
      "tags": []
    },
    {
      "name": "HDNodeVoidWallet",
      "kind": "ClassDeclaration",
      "signature": "export class HDNodeVoidWallet extends VoidSigner {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal w",
      "doc": "A **HDNodeVoidWallet** cannot sign, but provides access to\nthe children nodes of a [[link-bip-32]] HD wallet addresses.\n\nThe can be created by using an extended ``xpub`` key to\n[[HDNodeWallet_fromExtendedKey]] or by \n[nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].",
      "tags": []
    },
    {
      "name": "BaseWallet",
      "kind": "ClassDeclaration",
      "signature": "export class BaseWallet extends AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    readonly address!: string;\n\n    readonly #signingKey: SigningKey;\n\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%",
      "doc": "The **BaseWallet** is a stream-lined implementation of a\n[[Signer]] that operates with a private key.\n\nIt is preferred to use the [[Wallet]] class, as it offers\nadditional functionality and simplifies loading a variety\nof JSON formats, Mnemonic Phrases, etc.\n\nThis class may be of use for those attempting to implement\na minimal Signer.",
      "tags": []
    },
    {
      "name": "uuidV4",
      "kind": "FunctionDeclaration",
      "signature": "export function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - cloc",
      "doc": "Returns the version 4 [[link-uuid]] for the %%randomBytes%%.",
      "tags": [
        {
          "tagName": "see",
          "text": ": https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)"
        }
      ]
    },
    {
      "name": "toUtf8Bytes",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array {\n    assertArgument(typeof(str) === \"string\", \"invalid string value\", \"str\", str);\n\n    if (form != null) {\n        assertNormalize(form);\n        str = str.normalize(form);\n    }\n\n    let result: Array<number> = ",
      "doc": "Returns the UTF-8 byte representation of %%str%%.\n\nIf %%form%% is specified, the string is normalized.",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toUtf8String",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}",
      "doc": "Returns the string represented by the UTF-8 data %%bytes%%.\n\nWhen %%onError%% function is specified, it is called on UTF-8\nerrors allowing recovery using the [[Utf8ErrorFunc]] API.\n(default: [error](Utf8ErrorFuncs))",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8CodePoints(str: string, form?: UnicodeNormalizationForm): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}",
      "doc": "Returns the UTF-8 code-points for %%str%%.\n\nIf %%form%% is specified, the string is normalized.",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "UnicodeNormalizationForm",
      "kind": "TypeAliasDeclaration",
      "signature": "export type UnicodeNormalizationForm = \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\";",
      "doc": "The stanard normalization forms.",
      "tags": []
    },
    {
      "name": "Utf8ErrorReason",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Utf8ErrorReason = \"UNEXPECTED_CONTINUE\" | \"BAD_PREFIX\" | \"OVERRUN\" |\n    \"MISSING_CONTINUE\" | \"OUT_OF_RANGE\" | \"UTF16_SURROGATE\" | \"OVERLONG\";",
      "doc": "When using the UTF-8 error API the following errors can be intercepted\nand processed as the %%reason%% passed to the [[Utf8ErrorFunc]].\n\n**``\"UNEXPECTED_CONTINUE\"``** - a continuation byte was present where there\nwas nothing to continue.\n\n**``\"BAD_PREFIX\"``** - an invalid (non-continuation) byte to start a\nUTF-8 codepoint was found.\n\n**``\"OVERRUN\"``** - the string is too short to process the expected\ncodepoint length.\n\n**``\"MISSING_CONTINUE\"``** - a missing continuation byte was expected but\nnot found. The %%offset%% indicates the index the continuation byte\nwas expected at.\n\n**``\"OUT_OF_RANGE\"``** - the computed code point is outside the range\nfor UTF-8. The %%badCodepoint%% indicates the computed codepoint, which was\noutside the valid UTF-8 range.\n\n**``\"UTF16_SURROGATE\"``** - the UTF-8 strings contained a UTF-16 surrogate\npair. The %%badCodepoint%% is the computed codepoint, which was inside the\nUTF-16 surrogate range.\n\n**``\"OVERLONG\"``** - the string is an overlong representation. The\n%%badCodepoint%% indicates the computed codepoint, which has already\nbeen bounds checked.",
      "tags": [
        {
          "tagName": "returns",
          "text": "string"
        }
      ]
    },
    {
      "name": "Utf8ErrorFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number) => number;",
      "doc": "A callback that can be used with [[toUtf8String]] to analysis or\nrecovery from invalid UTF-8 data.\n\nParsing UTF-8 data is done through a simple Finite-State Machine (FSM)\nwhich calls the ``Utf8ErrorFunc`` if a fault is detected.\n\nThe %%reason%% indicates where in the FSM execution the fault\noccurred and the %%offset%% indicates where the input failed.\n\nThe %%bytes%% represents the raw UTF-8 data that was provided and\n%%output%% is the current array of UTF-8 code-points, which may\nbe updated by the ``Utf8ErrorFunc``.\n\nThe value of the %%badCodepoint%% depends on the %%reason%%. See\n[[Utf8ErrorReason]] for details.\n\nThe function should return the number of bytes that should be skipped\nwhen control resumes to the FSM.",
      "tags": []
    },
    {
      "name": "Utf8ErrorFuncs",
      "kind": "VariableDeclaration",
      "signature": "Utf8ErrorFuncs: Readonly<Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>> = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatUnits",
      "kind": "FunctionDeclaration",
      "signature": "export function formatUnits(value: BigNumberish, unit?: string | Numeric): string {\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (un",
      "doc": "Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\nplaces. The %%unit%% may be the number of decimal places or the name of\na unit (e.g. ``\"gwei\"`` for 9 decimal places).",
      "tags": []
    },
    {
      "name": "parseUnits",
      "kind": "FunctionDeclaration",
      "signature": "export function parseUnits(value: string, unit?: string | Numeric): bigint {\n    assertArgument(typeof(value) === \"string\", \"value must be a string\", \"value\", value);\n\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index ",
      "doc": "Converts the //decimal string// %%value%% to a BigInt, assuming\n%%unit%% decimal places. The %%unit%% may the number of decimal places\nor the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).",
      "tags": []
    },
    {
      "name": "formatEther",
      "kind": "FunctionDeclaration",
      "signature": "export function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}",
      "doc": "Converts %%value%% into a //decimal string// using 18 decimal places.",
      "tags": []
    },
    {
      "name": "parseEther",
      "kind": "FunctionDeclaration",
      "signature": "export function parseEther(ether: string): bigint {\n    return parseUnits(ether, 18);\n}",
      "doc": "Converts the //decimal string// %%ether%% to a BigInt, using 18\ndecimal places.",
      "tags": []
    },
    {
      "name": "decodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeRlp(_data: BytesLike): RlpStructuredData {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}",
      "doc": "Decodes %%data%% into the structured data it represents.",
      "tags": []
    },
    {
      "name": "encodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeRlp(object: RlpStructuredDataish): string {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}",
      "doc": "Encodes %%object%% as an RLP-encoded [[DataHexString]].",
      "tags": []
    },
    {
      "name": "RlpStructuredData",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RlpStructuredData = string | Array<RlpStructuredData>;",
      "doc": "An RLP-encoded structure.",
      "tags": []
    },
    {
      "name": "RlpStructuredDataish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RlpStructuredDataish = string | Uint8Array | Array<RlpStructuredDataish>;",
      "doc": "An RLP-encoded structure, which allows Uint8Array.",
      "tags": []
    },
    {
      "name": "encodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeRlp(object: RlpStructuredDataish): string {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}",
      "doc": "Encodes %%object%% as an RLP-encoded [[DataHexString]].",
      "tags": []
    },
    {
      "name": "decodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeRlp(_data: BytesLike): RlpStructuredData {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}",
      "doc": "Decodes %%data%% into the structured data it represents.",
      "tags": []
    },
    {
      "name": "resolveProperties",
      "kind": "FunctionDeclaration",
      "signature": "export async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        ac",
      "doc": "Resolves to a new object that is a copy of %%value%%, but with all\nvalues resolved.",
      "tags": []
    },
    {
      "name": "resolveProperties.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "defineProperties",
      "kind": "FunctionDeclaration",
      "signature": "export function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n",
      "doc": "Assigns the %%values%% to %%target%% as read-only values.\n\nIt %%types%% is specified, the values are checked.",
      "tags": []
    },
    {
      "name": "fromTwos",
      "kind": "FunctionDeclaration",
      "signature": "export function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _",
      "doc": "Convert %%value%% from a twos-compliment representation of %%width%%\nbits to its value.\n\nIf the highest bit is ``1``, the result will be negative.",
      "tags": []
    },
    {
      "name": "toTwos",
      "kind": "FunctionDeclaration",
      "signature": "export function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too ",
      "doc": "Convert %%value%% to a twos-compliment representation of\n%%width%% bits.\n\nThe result will always be positive.",
      "tags": []
    },
    {
      "name": "mask",
      "kind": "FunctionDeclaration",
      "signature": "export function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}",
      "doc": "Mask %%value%% with a bitmask of %%bits%% ones.",
      "tags": []
    },
    {
      "name": "getBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && ",
      "doc": "Gets a BigInt from %%value%%. If it is an invalid value for\na BigInt, then an ArgumentError will be thrown for %%name%%.",
      "tags": []
    },
    {
      "name": "getUint",
      "kind": "FunctionDeclaration",
      "signature": "export function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}",
      "doc": "Returns %%value%% as a bigint, validating it is valid as a bigint\nvalue and that it is positive.",
      "tags": []
    },
    {
      "name": "toBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            as",
      "doc": "Gets a //number// from %%value%%. If it is an invalid value for\na //number//, then an ArgumentError will be thrown for %%name%%.",
      "tags": []
    },
    {
      "name": "toNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}",
      "doc": "Converts %%value%% to a number. If %%value%% is a Uint8Array, it\nis treated as Big Endian data. Throws if the value is not safe.",
      "tags": []
    },
    {
      "name": "toBeHex",
      "kind": "FunctionDeclaration",
      "signature": "export function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n",
      "doc": "Converts %%value%% to a Big Endian hexstring, optionally padded to\n%%width%% bytes.",
      "tags": []
    },
    {
      "name": "toBeArray",
      "kind": "FunctionDeclaration",
      "signature": "export function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    f",
      "doc": "Converts %%value%% to a Big Endian Uint8Array.",
      "tags": []
    },
    {
      "name": "toBeArray.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toQuantity",
      "kind": "FunctionDeclaration",
      "signature": "export function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}",
      "doc": "Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n\nA //Quantity// does not have and leading 0 values unless the value is\nthe literal value `0x0`. This is most commonly used for JSSON-RPC\nnumeric values.",
      "tags": []
    },
    {
      "name": "Numeric",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Numeric = number | bigint;",
      "doc": "Any type that can be used where a numeric value is needed.",
      "tags": []
    },
    {
      "name": "BigNumberish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BigNumberish = string | Numeric;",
      "doc": "Any type that can be used where a big number is needed.",
      "tags": []
    },
    {
      "name": "decodeBase58",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase58(value: string): bigint {\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}",
      "doc": "Decode the Base58-encoded %%value%%.",
      "tags": []
    },
    {
      "name": "encodeBase58",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase58(_value: BytesLike): string {\n    const bytes = getBytes(_value);\n\n    let value = toBigInt(bytes);\n    let result = \"\";\n    while (value) {\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n\n    // Account for leading padding zeros\n",
      "doc": "Encode %%value%% as a Base58-encoded string.",
      "tags": []
    },
    {
      "name": "decodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase64(value: string): Uint8Array {\n    return getBytesCopy(Buffer.from(value, \"base64\"));\n}",
      "doc": "Decodes the base-64 encoded %%value%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// The decoded value is always binary data...\nresult = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n//_result:\n\n// ...use toUtf8String to convert it to a string.\ntoUtf8String(result)\n//_result:\n\n// Decoding binary data\ndecodeBase64(\"EjQ=\")\n//_result:"
        }
      ]
    },
    {
      "name": "decodeBase64.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "encodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase64(data: BytesLike): string {\n    return Buffer.from(getBytes(data)).toString(\"base64\");\n}",
      "doc": "Encodes %%data%% as a base-64 encoded string.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Encoding binary data as a hexstring\nencodeBase64(\"0x1234\")\n//_result:\n\n// Encoding binary data as a Uint8Array\nencodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n//_result:\n\n// The input MUST be data...\nencodeBase64(\"Hello World!!\")\n//_error:\n\n// ...use toUtf8Bytes for this.\nencodeBase64(toUtf8Bytes(\"Hello World!!\"))\n//_result:"
        }
      ]
    },
    {
      "name": "getBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}",
      "doc": "Get a typed Uint8Array for %%value%%. If already a Uint8Array\nthe original %%value%% is returned; if a copy is required use\n[[getBytesCopy]].",
      "tags": [
        {
          "tagName": "see",
          "text": ": getBytesCopy"
        }
      ]
    },
    {
      "name": "getBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "getBytesCopy",
      "kind": "FunctionDeclaration",
      "signature": "export function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}",
      "doc": "Get a typed Uint8Array for %%value%%, creating a copy if necessary\nto prevent any modifications of the returned value from being\nreflected elsewhere.",
      "tags": [
        {
          "tagName": "see",
          "text": ": getBytes"
        }
      ]
    },
    {
      "name": "getBytesCopy.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "isHexString",
      "kind": "FunctionDeclaration",
      "signature": "export function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (lengt",
      "doc": "Returns true if %%value%% is a valid [[HexString]].\n\nIf %%length%% is ``true`` or a //number//, it also checks that\n%%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\nbytes of data (e.g. ``0x1234`` is 2 bytes).",
      "tags": []
    },
    {
      "name": "isBytesLike",
      "kind": "FunctionDeclaration",
      "signature": "export function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}",
      "doc": "Returns true if %%value%% is a valid representation of arbitrary\ndata (i.e. a valid [[DataHexString]] or a Uint8Array).",
      "tags": []
    },
    {
      "name": "hexlify",
      "kind": "FunctionDeclaration",
      "signature": "export function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}",
      "doc": "Returns a [[DataHexString]] representation of %%data%%.",
      "tags": []
    },
    {
      "name": "concat",
      "kind": "FunctionDeclaration",
      "signature": "export function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}",
      "doc": "Returns a [[DataHexString]] by concatenating all values\nwithin %%data%%.",
      "tags": []
    },
    {
      "name": "dataLength",
      "kind": "FunctionDeclaration",
      "signature": "export function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}",
      "doc": "Returns the length of %%data%%, in bytes.",
      "tags": []
    },
    {
      "name": "dataSlice",
      "kind": "FunctionDeclaration",
      "signature": "export function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n",
      "doc": "Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\noffset to the %%end%% offset.\n\nBy default %%start%% is 0 and %%end%% is the length of %%data%%.",
      "tags": []
    },
    {
      "name": "stripZerosLeft",
      "kind": "FunctionDeclaration",
      "signature": "export function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}",
      "doc": "Return the [[DataHexString]] result by stripping all **leading**\n* zero bytes from %%data%%.",
      "tags": []
    },
    {
      "name": "zeroPadValue",
      "kind": "FunctionDeclaration",
      "signature": "export function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}",
      "doc": "Return the [[DataHexString]] of %%data%% padded on the **left**\nto %%length%% bytes.\n\nIf %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\nthrown.\n\nThis pads data the same as **values** are in Solidity\n(e.g. ``uint128``).",
      "tags": []
    },
    {
      "name": "zeroPadBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}",
      "doc": "Return the [[DataHexString]] of %%data%% padded on the **right**\nto %%length%% bytes.\n\nIf %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\nthrown.\n\nThis pads data the same as **bytes** are in Solidity\n(e.g. ``bytes16``).",
      "tags": []
    },
    {
      "name": "isCallException",
      "kind": "FunctionDeclaration",
      "signature": "export function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}",
      "doc": "Returns true if %%error%% is a [[CallExceptionError].",
      "tags": []
    },
    {
      "name": "isError",
      "kind": "FunctionDeclaration",
      "signature": "export function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}",
      "doc": "Returns true if the %%error%% matches an error thrown by ethers\nthat matches the error %%code%%.\n\nIn TypeScript environments, this can be used to check that %%error%%\nmatches an EthersError type, which means the expected properties will\nbe set.",
      "tags": [
        {
          "tagName": "See",
          "text": "[ErrorCodes](api:ErrorCode)"
        },
        {
          "tagName": "example",
          "text": "  try {\n    // code....\n  } catch (e) {\n    if (isError(e, \"CALL_EXCEPTION\")) {\n        // The Type Guard has validated this object\n        console.log(e.data);\n    }\n  }"
        }
      ]
    },
    {
      "name": "assert",
      "kind": "FunctionDeclaration",
      "signature": "export function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}",
      "doc": "Throws an EthersError with %%message%%, %%code%% and additional error\n%%info%% when %%check%% is falsish..",
      "tags": [
        {
          "tagName": "see",
          "text": "[[api:makeError]]"
        }
      ]
    },
    {
      "name": "assertArgument",
      "kind": "FunctionDeclaration",
      "signature": "export function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}",
      "doc": "A simple helper to simply ensuring provided arguments match expected\nconstraints, throwing if not.\n\nIn TypeScript environments, the %%check%% has been asserted true, so\nany further code does not need additional compile-time checks.",
      "tags": []
    },
    {
      "name": "assertArgumentCount",
      "kind": "FunctionDeclaration",
      "signature": "export function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n",
      "doc": "",
      "tags": []
    },
    {
      "name": "assertPrivate",
      "kind": "FunctionDeclaration",
      "signature": "export function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + ",
      "doc": "Many classes use file-scoped values to guard the constructor,\nmaking it effectively private. This facilitates that pattern\nby ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\nthrowing if not, indicating the %%className%% if provided.",
      "tags": []
    },
    {
      "name": "assertNormalize",
      "kind": "FunctionDeclaration",
      "signature": "export function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}",
      "doc": "Throws if the normalization %%form%% is not supported.",
      "tags": []
    },
    {
      "name": "makeError",
      "kind": "FunctionDeclaration",
      "signature": "export function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    let shortMessage = message;\n\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in inf",
      "doc": "Returns a new Error configured to the format ethers emits errors, with\nthe %%message%%, [[api:ErrorCode]] %%code%% and additional properties\nfor the corresponding EthersError.\n\nEach error in ethers includes the version of ethers, a\nmachine-readable [[ErrorCode]], and depending on %%code%%, additional\nrequired properties. The error message will also include the %%message%%,\nethers version, %%code%% and all additional properties, serialized.",
      "tags": []
    },
    {
      "name": "makeError.code",
      "kind": "PropertySignature",
      "signature": "code: ErrorCode;",
      "doc": "The string error code.",
      "tags": []
    },
    {
      "name": "makeError.shortMessage",
      "kind": "PropertySignature",
      "signature": "shortMessage: string;",
      "doc": "A short message describing the error, with minimal additional\ndetails.",
      "tags": []
    },
    {
      "name": "makeError.info",
      "kind": "PropertySignature",
      "signature": "info?: Record<string, any>;",
      "doc": "Additional info regarding the error that may be useful.\n\nThis is generally helpful mostly for human-based debugging.",
      "tags": []
    },
    {
      "name": "makeError.error",
      "kind": "PropertySignature",
      "signature": "error?: Error;",
      "doc": "Any related error.",
      "tags": []
    },
    {
      "name": "makeError.name",
      "kind": "PropertySignature",
      "signature": "name:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeError.message",
      "kind": "PropertySignature",
      "signature": "message:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeError.stack",
      "kind": "PropertySignature",
      "signature": "stack?:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "EventPayload",
      "kind": "ClassDeclaration",
      "signature": "export class EventPayload<T> {\n    /**\n     *  The event filter.\n     */\n    readonly filter!: T;\n\n    /**\n     *  The **EventEmitterable**.\n     */\n    readonly emitter!: EventEmitterable<T>;\n\n    readonly #listener: null | Listener;\n\n    /**\n     *  Create a new **EventPayload** for %%emitter%% wi",
      "doc": "When an [[EventEmitterable]] triggers a [[Listener]], the\ncallback always ahas one additional argument passed, which is\nan **EventPayload**.",
      "tags": []
    },
    {
      "name": "FetchRequest",
      "kind": "ClassDeclaration",
      "signature": "export class FetchRequest implements Iterable<[ key: string, value: string ]> {\n    #allowInsecure: boolean;\n    #gzip: boolean;\n    #headers: Record<string, string>;\n    #method: string;\n    #timeout: number;\n    #url: string;\n\n    #body?: Uint8Array;\n    #bodyType?: string;\n    #creds?: string;\n\n ",
      "doc": "Represents a request for a resource using a URI.\n\nBy default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\nand ``IPFS:``.\n\nAdditional schemes can be added globally using [[registerGateway]].",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nreq = new FetchRequest(\"https://www.ricmoo.com\")\nresp = await req.send()\nresp.body.length\n//_result:"
        }
      ]
    },
    {
      "name": "FetchResponse",
      "kind": "ClassDeclaration",
      "signature": "export class FetchResponse implements Iterable<[ key: string, value: string ]> {\n    #statusCode: number;\n    #statusMessage: string;\n    #headers: Record<string, string>;\n    #body: null | Readonly<Uint8Array>;\n    #request: null | FetchRequest;\n\n    #error: { error?: Error, message: string };\n\n   ",
      "doc": "The response for a FetchRequest.",
      "tags": []
    },
    {
      "name": "FetchCancelSignal",
      "kind": "ClassDeclaration",
      "signature": "export class FetchCancelSignal {\n    #listeners: Array<() => void>;\n    #cancelled: boolean;\n\n    constructor(request: FetchRequest) {\n        this.#listeners = [ ];\n        this.#cancelled = false;\n\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) { return; }\n            t",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "FixedNumber",
      "kind": "ClassDeclaration",
      "signature": "export class FixedNumber {\n\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    readonly format!: string;\n\n    readonly #format: _FixedFormat;\n\n    // The actual value (accounting for decimals)\n    #val: bigint;\n\n    // A base-10 value to multiple values by to maint",
      "doc": "A FixedNumber represents a value over its [[FixedFormat]]\narithmetic field.\n\nA FixedNumber can be used to perform math, losslessly, on\nvalues which have decmial places.\n\nA FixedNumber has a fixed bit-width to store values in, and stores all\nvalues internally by multiplying the value by 10 raised to the power of\n%%decimals%%.\n\nIf operations are performed that cause a value to grow too high (close to\npositive infinity) or too low (close to negative infinity), the value\nis said to //overflow//.\n\nFor example, an 8-bit signed value, with 0 decimals may only be within\nthe range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n\nMany operation have a normal and //unsafe// variant. The normal variant\nwill throw a [[NumericFaultError]] on any overflow, while the //unsafe//\nvariant will silently allow overflow, corrupting its value value.\n\nIf operations are performed that cause a value to become too small\n(close to zero), the value loses precison and is said to //underflow//.\n\nFor example, a value with 1 decimal place may store a number as small\nas ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\ninto 1 decimal place, so underflow occurs which means precision is lost\nand the value becomes ``0``.\n\nSome operations have a normal and //signalling// variant. The normal\nvariant will silently ignore underflow, while the //signalling// variant\nwill thow a [[NumericFaultError]] on underflow.",
      "tags": []
    },
    {
      "name": "fromTwos",
      "kind": "FunctionDeclaration",
      "signature": "export function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _",
      "doc": "Convert %%value%% from a twos-compliment representation of %%width%%\nbits to its value.\n\nIf the highest bit is ``1``, the result will be negative.",
      "tags": []
    },
    {
      "name": "toTwos",
      "kind": "FunctionDeclaration",
      "signature": "export function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too ",
      "doc": "Convert %%value%% to a twos-compliment representation of\n%%width%% bits.\n\nThe result will always be positive.",
      "tags": []
    },
    {
      "name": "mask",
      "kind": "FunctionDeclaration",
      "signature": "export function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}",
      "doc": "Mask %%value%% with a bitmask of %%bits%% ones.",
      "tags": []
    },
    {
      "name": "getBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && ",
      "doc": "Gets a BigInt from %%value%%. If it is an invalid value for\na BigInt, then an ArgumentError will be thrown for %%name%%.",
      "tags": []
    },
    {
      "name": "getNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            as",
      "doc": "Gets a //number// from %%value%%. If it is an invalid value for\na //number//, then an ArgumentError will be thrown for %%name%%.",
      "tags": []
    },
    {
      "name": "getUint",
      "kind": "FunctionDeclaration",
      "signature": "export function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}",
      "doc": "Returns %%value%% as a bigint, validating it is valid as a bigint\nvalue and that it is positive.",
      "tags": []
    },
    {
      "name": "toBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "toNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}",
      "doc": "Converts %%value%% to a number. If %%value%% is a Uint8Array, it\nis treated as Big Endian data. Throws if the value is not safe.",
      "tags": []
    },
    {
      "name": "toBeHex",
      "kind": "FunctionDeclaration",
      "signature": "export function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n",
      "doc": "Converts %%value%% to a Big Endian hexstring, optionally padded to\n%%width%% bytes.",
      "tags": []
    },
    {
      "name": "toBeArray",
      "kind": "FunctionDeclaration",
      "signature": "export function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    f",
      "doc": "Converts %%value%% to a Big Endian Uint8Array.",
      "tags": []
    },
    {
      "name": "toBeArray.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "toBeArray.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toQuantity",
      "kind": "FunctionDeclaration",
      "signature": "export function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}",
      "doc": "Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n\nA //Quantity// does not have and leading 0 values unless the value is\nthe literal value `0x0`. This is most commonly used for JSSON-RPC\nnumeric values.",
      "tags": []
    },
    {
      "name": "resolveProperties",
      "kind": "FunctionDeclaration",
      "signature": "export async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        ac",
      "doc": "Resolves to a new object that is a copy of %%value%%, but with all\nvalues resolved.",
      "tags": []
    },
    {
      "name": "resolveProperties.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProperties.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "defineProperties",
      "kind": "FunctionDeclaration",
      "signature": "export function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n",
      "doc": "Assigns the %%values%% to %%target%% as read-only values.\n\nIt %%types%% is specified, the values are checked.",
      "tags": []
    },
    {
      "name": "decodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeRlp(_data: BytesLike): RlpStructuredData {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}",
      "doc": "Decodes %%data%% into the structured data it represents.",
      "tags": []
    },
    {
      "name": "encodeRlp",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeRlp(object: RlpStructuredDataish): string {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}",
      "doc": "Encodes %%object%% as an RLP-encoded [[DataHexString]].",
      "tags": []
    },
    {
      "name": "formatEther",
      "kind": "FunctionDeclaration",
      "signature": "export function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}",
      "doc": "Converts %%value%% into a //decimal string// using 18 decimal places.",
      "tags": []
    },
    {
      "name": "parseEther",
      "kind": "FunctionDeclaration",
      "signature": "export function parseEther(ether: string): bigint {\n    return parseUnits(ether, 18);\n}",
      "doc": "Converts the //decimal string// %%ether%% to a BigInt, using 18\ndecimal places.",
      "tags": []
    },
    {
      "name": "formatUnits",
      "kind": "FunctionDeclaration",
      "signature": "export function formatUnits(value: BigNumberish, unit?: string | Numeric): string {\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (un",
      "doc": "Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\nplaces. The %%unit%% may be the number of decimal places or the name of\na unit (e.g. ``\"gwei\"`` for 9 decimal places).",
      "tags": []
    },
    {
      "name": "parseUnits",
      "kind": "FunctionDeclaration",
      "signature": "export function parseUnits(value: string, unit?: string | Numeric): bigint {\n    assertArgument(typeof(value) === \"string\", \"value must be a string\", \"value\", value);\n\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index ",
      "doc": "Converts the //decimal string// %%value%% to a BigInt, assuming\n%%unit%% decimal places. The %%unit%% may the number of decimal places\nor the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).",
      "tags": []
    },
    {
      "name": "toUtf8Bytes",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array {\n    assertArgument(typeof(str) === \"string\", \"invalid string value\", \"str\", str);\n\n    if (form != null) {\n        assertNormalize(form);\n        str = str.normalize(form);\n    }\n\n    let result: Array<number> = ",
      "doc": "Returns the UTF-8 byte representation of %%str%%.\n\nIf %%form%% is specified, the string is normalized.",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8Bytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8CodePoints(str: string, form?: UnicodeNormalizationForm): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}",
      "doc": "Returns the UTF-8 code-points for %%str%%.\n\nIf %%form%% is specified, the string is normalized.",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "toUtf8CodePoints.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "toUtf8String",
      "kind": "FunctionDeclaration",
      "signature": "export function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}",
      "doc": "Returns the string represented by the UTF-8 data %%bytes%%.\n\nWhen %%onError%% function is specified, it is called on UTF-8\nerrors allowing recovery using the [[Utf8ErrorFunc]] API.\n(default: [error](Utf8ErrorFuncs))",
      "tags": []
    },
    {
      "name": "Utf8ErrorFuncs",
      "kind": "VariableDeclaration",
      "signature": "Utf8ErrorFuncs: Readonly<Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>> = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "uuidV4",
      "kind": "FunctionDeclaration",
      "signature": "export function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - cloc",
      "doc": "Returns the version 4 [[link-uuid]] for the %%randomBytes%%.",
      "tags": [
        {
          "tagName": "see",
          "text": ": https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)"
        }
      ]
    },
    {
      "name": "BytesLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BytesLike = DataHexString | Uint8Array;",
      "doc": "An object that can be used to represent binary data.",
      "tags": []
    },
    {
      "name": "ErrorCode",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVAL",
      "doc": "All errors emitted by ethers have an **ErrorCode** to help\nidentify and coalesce errors to simplify programmatic analysis.\n\nEach **ErrorCode** is the %%code%% proerty of a coresponding\n[[EthersError]].\n\n**Generic Errors**\n\n**``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n\n**``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n\n**``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n\n**``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n\n**``\"SERVER_ERROR\"``** - see [[ServerError]]\n\n**``\"TIMEOUT\"``** - see [[TimeoutError]]\n\n**``\"BAD_DATA\"``** - see [[BadDataError]]\n\n**``\"CANCELLED\"``** - see [[CancelledError]]\n\n**Operational Errors**\n\n**``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n\n**``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n\n**Argument Errors**\n\n**``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n\n**``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n\n**``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n\n**``\"VALUE_MISMATCH\"``** - //unused//\n\n**Blockchain Errors**\n\n**``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n\n**``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n\n**``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n\n**``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n\n**``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n\n**``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n\n**``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n\n**User Interaction Errors**\n\n**``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]",
      "tags": []
    },
    {
      "name": "EthersError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  A short message describing the error, with minimal additional\n     *  details.\n     */\n    shortMessage: string;\n\n    /**\n     *  Additio",
      "doc": "All errors in Ethers include properties to assist in\nmachine-readable errors.",
      "tags": []
    },
    {
      "name": "UnknownError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}",
      "doc": "This Error is a catch-all for when there is no way for Ethers to\nknow what the underlying problem is.",
      "tags": []
    },
    {
      "name": "NotImplementedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}",
      "doc": "This Error is mostly used as a stub for functionality that is\nintended for the future, but is currently not implemented.",
      "tags": []
    },
    {
      "name": "UnsupportedOperationError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}",
      "doc": "This Error indicates that the attempted operation is not supported.\n\nThis could range from a specific JSON-RPC end-point not supporting\na feature to a specific configuration of an object prohibiting the\noperation.\n\nFor example, a [[Wallet]] with no connected [[Provider]] is unable\nto send a transaction.",
      "tags": []
    },
    {
      "name": "NetworkError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    /**\n     *  The network event.\n     */\n    event: string;\n}",
      "doc": "This Error indicates a problem connecting to a network.",
      "tags": []
    },
    {
      "name": "ServerError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}",
      "doc": "This Error indicates there was a problem fetching a resource from\na server.",
      "tags": []
    },
    {
      "name": "TimeoutError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}",
      "doc": "This Error indicates that the timeout duration has expired and\nthat the operation has been implicitly cancelled.\n\nThe side-effect of the operation may still occur, as this\ngenerally means a request has been sent and there has simply\nbeen no response to indicate whether it was processed or not.",
      "tags": []
    },
    {
      "name": "BadDataError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}",
      "doc": "This Error indicates that a provided set of data cannot\nbe correctly interpreted.",
      "tags": []
    },
    {
      "name": "CancelledError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CancelledError extends EthersError<\"CANCELLED\"> {\n}",
      "doc": "This Error indicates that the operation was cancelled by a\nprogrammatic call, for example to ``cancel()``.",
      "tags": []
    },
    {
      "name": "BufferOverrunError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n",
      "doc": "This Error indicates an attempt was made to read outside the bounds\nof protected data.\n\nMost operations in Ethers are protected by bounds checks, to mitigate\nexploits when parsing data.",
      "tags": []
    },
    {
      "name": "NumericFaultError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}",
      "doc": "This Error indicates an operation which would result in incorrect\narithmetic output has occurred.\n\nFor example, trying to divide by zero or using a ``uint8`` to store\na negative value.",
      "tags": []
    },
    {
      "name": "InvalidArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}",
      "doc": "This Error indicates an incorrect type or value was passed to\na function or method.",
      "tags": []
    },
    {
      "name": "MissingArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}",
      "doc": "This Error indicates there were too few arguments were provided.",
      "tags": []
    },
    {
      "name": "UnexpectedArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}",
      "doc": "This Error indicates too many arguments were provided.",
      "tags": []
    },
    {
      "name": "CallExceptionError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-reada",
      "doc": "This **Error** indicates a transaction reverted.",
      "tags": []
    },
    {
      "name": "InsufficientFundsError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "The sending account has insufficient funds to cover the\nentire transaction cost.",
      "tags": []
    },
    {
      "name": "NonceExpiredError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "The sending account has already used this nonce in a\ntransaction that has been included.",
      "tags": []
    },
    {
      "name": "OffchainFaultError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}",
      "doc": "A CCIP-read exception, which cannot be recovered from or\nbe further processed.",
      "tags": []
    },
    {
      "name": "ReplacementUnderpricedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "An attempt was made to replace a transaction, but with an\ninsufficient additional fee to afford evicting the old\ntransaction from the memory pool.",
      "tags": []
    },
    {
      "name": "TransactionReplacedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was repla",
      "doc": "A pending transaction was replaced by another.",
      "tags": []
    },
    {
      "name": "UnconfiguredNameError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}",
      "doc": "This Error indicates an ENS name was used, but the name has not\nbeen configured.\n\nThis could indicate an ENS name is unowned or that the current\naddress being pointed to is the [[ZeroAddress]].",
      "tags": []
    },
    {
      "name": "ActionRejectedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n ",
      "doc": "This Error indicates a request was rejected by the user.\n\nIn most clients (such as MetaMask), when an operation requires user\nauthorization (such as ``signer.sendTransaction``), the client\npresents a dialog box to the user. If the user denies the request\nthis error is thrown.",
      "tags": []
    },
    {
      "name": "CallExceptionAction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"sendTransaction\" | \"unknown\";",
      "doc": "The action that resulted in the call exception.",
      "tags": []
    },
    {
      "name": "CallExceptionTransaction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};",
      "doc": "The related transaction that caused the error.",
      "tags": []
    },
    {
      "name": "CodedEthersError",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T ex",
      "doc": "A conditional type that transforms the [[ErrorCode]] T into\nits EthersError type.",
      "tags": [
        {
          "tagName": "flatworm-skip-docs",
          "text": ""
        }
      ]
    },
    {
      "name": "EventEmitterable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EventEmitterable<T> {\n    /**\n     *  Registers a %%listener%% that is called whenever the\n     *  %%event%% occurs until unregistered.\n     */\n    on(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Registers a %%listener%% that is called the next time\n     *  %%event",
      "doc": "An **EventEmitterable** behaves similar to an EventEmitter\nexcept provides async access to its methods.\n\nAn EventEmitter implements the observer pattern.",
      "tags": []
    },
    {
      "name": "Listener",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Listener = (...args: Array<any>) => void;",
      "doc": "A callback function called when a an event is triggered.",
      "tags": []
    },
    {
      "name": "GetUrlResponse",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GetUrlResponse = {\n    statusCode: number,\n    statusMessage: string,\n    headers: Record<string, string>,\n    body: null | Uint8Array\n};",
      "doc": "An environment's implementation of ``getUrl`` must return this type.",
      "tags": []
    },
    {
      "name": "FetchPreflightFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchPreflightFunc = (req: FetchRequest) => Promise<FetchRequest>;",
      "doc": "Called before any network request, allowing updated headers (e.g. Bearer tokens), etc.",
      "tags": []
    },
    {
      "name": "FetchProcessFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchProcessFunc = (req: FetchRequest, resp: FetchResponse) => Promise<FetchResponse>;",
      "doc": "Called on the response, allowing client-based throttling logic or post-processing.",
      "tags": []
    },
    {
      "name": "FetchRetryFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchRetryFunc = (req: FetchRequest, resp: FetchResponse, attempt: number) => Promise<boolean>;",
      "doc": "Called prior to each retry; return true to retry, false to abort.",
      "tags": []
    },
    {
      "name": "FetchGatewayFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchGatewayFunc = (url: string, signal?: FetchCancelSignal) => Promise<FetchRequest | FetchResponse>;",
      "doc": "Called on Gateway URLs.",
      "tags": []
    },
    {
      "name": "FetchGetUrlFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchGetUrlFunc = (req: FetchRequest, signal?: FetchCancelSignal) => Promise<GetUrlResponse>;",
      "doc": "Used to perform a fetch; use this to override the underlying network\nfetch layer. In NodeJS, the default uses the \"http\" and \"https\" libraries\nand in the browser ``fetch`` is used. If you wish to use Axios, this is\nhow you would register it.",
      "tags": []
    },
    {
      "name": "FixedFormat",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FixedFormat = number | string | {\n    signed?: boolean,\n    width?: number,\n    decimals?: number\n};",
      "doc": "A description of a fixed-point arithmetic field.\n\nWhen specifying the fixed format, the values override the default of\na ``fixed128x18``, which implies a signed 128-bit value with 18\ndecimals of precision.\n\nThe alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and\n``ufixed128x18`` respectively.\n\nWhen a fixed format string begins with a ``u``, it indicates the field\nis unsigned, so any negative values will overflow. The first number\nindicates the bit-width and the second number indicates the decimal\nprecision.\n\nWhen a ``number`` is used for a fixed format, it indicates the number\nof decimal places, and the default width and signed-ness will be used.\n\nThe bit-width must be byte aligned and the decimals can be at most 80.",
      "tags": []
    },
    {
      "name": "BigNumberish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BigNumberish = string | Numeric;",
      "doc": "Any type that can be used where a big number is needed.",
      "tags": []
    },
    {
      "name": "Numeric",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Numeric = number | bigint;",
      "doc": "Any type that can be used where a numeric value is needed.",
      "tags": []
    },
    {
      "name": "RlpStructuredData",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RlpStructuredData = string | Array<RlpStructuredData>;",
      "doc": "An RLP-encoded structure.",
      "tags": []
    },
    {
      "name": "RlpStructuredDataish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RlpStructuredDataish = string | Uint8Array | Array<RlpStructuredDataish>;",
      "doc": "An RLP-encoded structure, which allows Uint8Array.",
      "tags": []
    },
    {
      "name": "Utf8ErrorFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number) => number;",
      "doc": "A callback that can be used with [[toUtf8String]] to analysis or\nrecovery from invalid UTF-8 data.\n\nParsing UTF-8 data is done through a simple Finite-State Machine (FSM)\nwhich calls the ``Utf8ErrorFunc`` if a fault is detected.\n\nThe %%reason%% indicates where in the FSM execution the fault\noccurred and the %%offset%% indicates where the input failed.\n\nThe %%bytes%% represents the raw UTF-8 data that was provided and\n%%output%% is the current array of UTF-8 code-points, which may\nbe updated by the ``Utf8ErrorFunc``.\n\nThe value of the %%badCodepoint%% depends on the %%reason%%. See\n[[Utf8ErrorReason]] for details.\n\nThe function should return the number of bytes that should be skipped\nwhen control resumes to the FSM.",
      "tags": []
    },
    {
      "name": "UnicodeNormalizationForm",
      "kind": "TypeAliasDeclaration",
      "signature": "export type UnicodeNormalizationForm = \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\";",
      "doc": "The stanard normalization forms.",
      "tags": []
    },
    {
      "name": "Utf8ErrorReason",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Utf8ErrorReason = \"UNEXPECTED_CONTINUE\" | \"BAD_PREFIX\" | \"OVERRUN\" |\n    \"MISSING_CONTINUE\" | \"OUT_OF_RANGE\" | \"UTF16_SURROGATE\" | \"OVERLONG\";",
      "doc": "When using the UTF-8 error API the following errors can be intercepted\nand processed as the %%reason%% passed to the [[Utf8ErrorFunc]].\n\n**``\"UNEXPECTED_CONTINUE\"``** - a continuation byte was present where there\nwas nothing to continue.\n\n**``\"BAD_PREFIX\"``** - an invalid (non-continuation) byte to start a\nUTF-8 codepoint was found.\n\n**``\"OVERRUN\"``** - the string is too short to process the expected\ncodepoint length.\n\n**``\"MISSING_CONTINUE\"``** - a missing continuation byte was expected but\nnot found. The %%offset%% indicates the index the continuation byte\nwas expected at.\n\n**``\"OUT_OF_RANGE\"``** - the computed code point is outside the range\nfor UTF-8. The %%badCodepoint%% indicates the computed codepoint, which was\noutside the valid UTF-8 range.\n\n**``\"UTF16_SURROGATE\"``** - the UTF-8 strings contained a UTF-16 surrogate\npair. The %%badCodepoint%% is the computed codepoint, which was inside the\nUTF-16 surrogate range.\n\n**``\"OVERLONG\"``** - the string is an overlong representation. The\n%%badCodepoint%% indicates the computed codepoint, which has already\nbeen bounds checked.",
      "tags": [
        {
          "tagName": "returns",
          "text": "string"
        }
      ]
    },
    {
      "name": "createGetUrl",
      "kind": "FunctionDeclaration",
      "signature": "export function createGetUrl(options?: Record<string, any>): FetchGetUrlFunc {\n\n    async function getUrl(req: FetchRequest, signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n        // Make sure we weren't cancelled before sending\n        assert(signal == null || !signal.cancelled, \"request ca",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "getUrl",
      "kind": "FunctionDeclaration",
      "signature": "export async function getUrl(req: FetchRequest, signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n    return defaultGetUrl(req, signal);\n}",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "getUrl.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUrl.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUrl.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUrl.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createGetUrl",
      "kind": "FunctionDeclaration",
      "signature": "export function createGetUrl(options?: Record<string, any>): FetchGetUrlFunc {\n\n    async function getUrl(req: FetchRequest, _signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n        assert(_signal == null || !_signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n\n        const ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUrl",
      "kind": "FunctionDeclaration",
      "signature": "export async function getUrl(req: FetchRequest, _signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n    return defaultGetUrl(req, _signal);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUrl.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUrl.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUrl.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUrl.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "FixedFormat",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FixedFormat = number | string | {\n    signed?: boolean,\n    width?: number,\n    decimals?: number\n};",
      "doc": "A description of a fixed-point arithmetic field.\n\nWhen specifying the fixed format, the values override the default of\na ``fixed128x18``, which implies a signed 128-bit value with 18\ndecimals of precision.\n\nThe alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and\n``ufixed128x18`` respectively.\n\nWhen a fixed format string begins with a ``u``, it indicates the field\nis unsigned, so any negative values will overflow. The first number\nindicates the bit-width and the second number indicates the decimal\nprecision.\n\nWhen a ``number`` is used for a fixed format, it indicates the number\nof decimal places, and the default width and signed-ness will be used.\n\nThe bit-width must be byte aligned and the decimals can be at most 80.",
      "tags": []
    },
    {
      "name": "FixedNumber",
      "kind": "ClassDeclaration",
      "signature": "export class FixedNumber {\n\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    readonly format!: string;\n\n    readonly #format: _FixedFormat;\n\n    // The actual value (accounting for decimals)\n    #val: bigint;\n\n    // A base-10 value to multiple values by to maint",
      "doc": "A FixedNumber represents a value over its [[FixedFormat]]\narithmetic field.\n\nA FixedNumber can be used to perform math, losslessly, on\nvalues which have decmial places.\n\nA FixedNumber has a fixed bit-width to store values in, and stores all\nvalues internally by multiplying the value by 10 raised to the power of\n%%decimals%%.\n\nIf operations are performed that cause a value to grow too high (close to\npositive infinity) or too low (close to negative infinity), the value\nis said to //overflow//.\n\nFor example, an 8-bit signed value, with 0 decimals may only be within\nthe range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n\nMany operation have a normal and //unsafe// variant. The normal variant\nwill throw a [[NumericFaultError]] on any overflow, while the //unsafe//\nvariant will silently allow overflow, corrupting its value value.\n\nIf operations are performed that cause a value to become too small\n(close to zero), the value loses precison and is said to //underflow//.\n\nFor example, a value with 1 decimal place may store a number as small\nas ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\ninto 1 decimal place, so underflow occurs which means precision is lost\nand the value becomes ``0``.\n\nSome operations have a normal and //signalling// variant. The normal\nvariant will silently ignore underflow, while the //signalling// variant\nwill thow a [[NumericFaultError]] on underflow.",
      "tags": []
    },
    {
      "name": "GetUrlResponse",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GetUrlResponse = {\n    statusCode: number,\n    statusMessage: string,\n    headers: Record<string, string>,\n    body: null | Uint8Array\n};",
      "doc": "An environment's implementation of ``getUrl`` must return this type.",
      "tags": []
    },
    {
      "name": "FetchThrottleParams",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchThrottleParams = {\n    maxAttempts?: number;\n    slotInterval?: number;\n};",
      "doc": "This can be used to control how throttling is handled in\n[[FetchRequest-setThrottleParams]].",
      "tags": []
    },
    {
      "name": "FetchPreflightFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchPreflightFunc = (req: FetchRequest) => Promise<FetchRequest>;",
      "doc": "Called before any network request, allowing updated headers (e.g. Bearer tokens), etc.",
      "tags": []
    },
    {
      "name": "FetchProcessFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchProcessFunc = (req: FetchRequest, resp: FetchResponse) => Promise<FetchResponse>;",
      "doc": "Called on the response, allowing client-based throttling logic or post-processing.",
      "tags": []
    },
    {
      "name": "FetchRetryFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchRetryFunc = (req: FetchRequest, resp: FetchResponse, attempt: number) => Promise<boolean>;",
      "doc": "Called prior to each retry; return true to retry, false to abort.",
      "tags": []
    },
    {
      "name": "FetchGatewayFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchGatewayFunc = (url: string, signal?: FetchCancelSignal) => Promise<FetchRequest | FetchResponse>;",
      "doc": "Called on Gateway URLs.",
      "tags": []
    },
    {
      "name": "FetchGetUrlFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FetchGetUrlFunc = (req: FetchRequest, signal?: FetchCancelSignal) => Promise<GetUrlResponse>;",
      "doc": "Used to perform a fetch; use this to override the underlying network\nfetch layer. In NodeJS, the default uses the \"http\" and \"https\" libraries\nand in the browser ``fetch`` is used. If you wish to use Axios, this is\nhow you would register it.",
      "tags": []
    },
    {
      "name": "FetchCancelSignal",
      "kind": "ClassDeclaration",
      "signature": "export class FetchCancelSignal {\n    #listeners: Array<() => void>;\n    #cancelled: boolean;\n\n    constructor(request: FetchRequest) {\n        this.#listeners = [ ];\n        this.#cancelled = false;\n\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) { return; }\n            t",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "FetchRequest",
      "kind": "ClassDeclaration",
      "signature": "export class FetchRequest implements Iterable<[ key: string, value: string ]> {\n    #allowInsecure: boolean;\n    #gzip: boolean;\n    #headers: Record<string, string>;\n    #method: string;\n    #timeout: number;\n    #url: string;\n\n    #body?: Uint8Array;\n    #bodyType?: string;\n    #creds?: string;\n\n ",
      "doc": "Represents a request for a resource using a URI.\n\nBy default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\nand ``IPFS:``.\n\nAdditional schemes can be added globally using [[registerGateway]].",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nreq = new FetchRequest(\"https://www.ricmoo.com\")\nresp = await req.send()\nresp.body.length\n//_result:"
        }
      ]
    },
    {
      "name": "FetchResponse",
      "kind": "ClassDeclaration",
      "signature": "export class FetchResponse implements Iterable<[ key: string, value: string ]> {\n    #statusCode: number;\n    #statusMessage: string;\n    #headers: Record<string, string>;\n    #body: null | Readonly<Uint8Array>;\n    #request: null | FetchRequest;\n\n    #error: { error?: Error, message: string };\n\n   ",
      "doc": "The response for a FetchRequest.",
      "tags": []
    },
    {
      "name": "Listener",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Listener = (...args: Array<any>) => void;",
      "doc": "A callback function called when a an event is triggered.",
      "tags": []
    },
    {
      "name": "EventEmitterable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EventEmitterable<T> {\n    /**\n     *  Registers a %%listener%% that is called whenever the\n     *  %%event%% occurs until unregistered.\n     */\n    on(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Registers a %%listener%% that is called the next time\n     *  %%event",
      "doc": "An **EventEmitterable** behaves similar to an EventEmitter\nexcept provides async access to its methods.\n\nAn EventEmitter implements the observer pattern.",
      "tags": []
    },
    {
      "name": "EventPayload",
      "kind": "ClassDeclaration",
      "signature": "export class EventPayload<T> {\n    /**\n     *  The event filter.\n     */\n    readonly filter!: T;\n\n    /**\n     *  The **EventEmitterable**.\n     */\n    readonly emitter!: EventEmitterable<T>;\n\n    readonly #listener: null | Listener;\n\n    /**\n     *  Create a new **EventPayload** for %%emitter%% wi",
      "doc": "When an [[EventEmitterable]] triggers a [[Listener]], the\ncallback always ahas one additional argument passed, which is\nan **EventPayload**.",
      "tags": []
    },
    {
      "name": "isError",
      "kind": "FunctionDeclaration",
      "signature": "export function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}",
      "doc": "Returns true if the %%error%% matches an error thrown by ethers\nthat matches the error %%code%%.\n\nIn TypeScript environments, this can be used to check that %%error%%\nmatches an EthersError type, which means the expected properties will\nbe set.",
      "tags": [
        {
          "tagName": "See",
          "text": "[ErrorCodes](api:ErrorCode)"
        },
        {
          "tagName": "example",
          "text": "  try {\n    // code....\n  } catch (e) {\n    if (isError(e, \"CALL_EXCEPTION\")) {\n        // The Type Guard has validated this object\n        console.log(e.data);\n    }\n  }"
        }
      ]
    },
    {
      "name": "isCallException",
      "kind": "FunctionDeclaration",
      "signature": "export function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}",
      "doc": "Returns true if %%error%% is a [[CallExceptionError].",
      "tags": []
    },
    {
      "name": "makeError",
      "kind": "FunctionDeclaration",
      "signature": "export function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    let shortMessage = message;\n\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in inf",
      "doc": "Returns a new Error configured to the format ethers emits errors, with\nthe %%message%%, [[api:ErrorCode]] %%code%% and additional properties\nfor the corresponding EthersError.\n\nEach error in ethers includes the version of ethers, a\nmachine-readable [[ErrorCode]], and depending on %%code%%, additional\nrequired properties. The error message will also include the %%message%%,\nethers version, %%code%% and all additional properties, serialized.",
      "tags": []
    },
    {
      "name": "makeError.code",
      "kind": "PropertySignature",
      "signature": "code: ErrorCode;",
      "doc": "The string error code.",
      "tags": []
    },
    {
      "name": "makeError.shortMessage",
      "kind": "PropertySignature",
      "signature": "shortMessage: string;",
      "doc": "A short message describing the error, with minimal additional\ndetails.",
      "tags": []
    },
    {
      "name": "makeError.info",
      "kind": "PropertySignature",
      "signature": "info?: Record<string, any>;",
      "doc": "Additional info regarding the error that may be useful.\n\nThis is generally helpful mostly for human-based debugging.",
      "tags": []
    },
    {
      "name": "makeError.error",
      "kind": "PropertySignature",
      "signature": "error?: Error;",
      "doc": "Any related error.",
      "tags": []
    },
    {
      "name": "makeError.name",
      "kind": "PropertySignature",
      "signature": "name:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeError.message",
      "kind": "PropertySignature",
      "signature": "message:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeError.stack",
      "kind": "PropertySignature",
      "signature": "stack?:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "assert",
      "kind": "FunctionDeclaration",
      "signature": "export function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}",
      "doc": "Throws an EthersError with %%message%%, %%code%% and additional error\n%%info%% when %%check%% is falsish..",
      "tags": [
        {
          "tagName": "see",
          "text": "[[api:makeError]]"
        }
      ]
    },
    {
      "name": "assertArgument",
      "kind": "FunctionDeclaration",
      "signature": "export function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}",
      "doc": "A simple helper to simply ensuring provided arguments match expected\nconstraints, throwing if not.\n\nIn TypeScript environments, the %%check%% has been asserted true, so\nany further code does not need additional compile-time checks.",
      "tags": []
    },
    {
      "name": "assertArgumentCount",
      "kind": "FunctionDeclaration",
      "signature": "export function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n",
      "doc": "",
      "tags": []
    },
    {
      "name": "assertNormalize",
      "kind": "FunctionDeclaration",
      "signature": "export function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}",
      "doc": "Throws if the normalization %%form%% is not supported.",
      "tags": []
    },
    {
      "name": "assertPrivate",
      "kind": "FunctionDeclaration",
      "signature": "export function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + ",
      "doc": "Many classes use file-scoped values to guard the constructor,\nmaking it effectively private. This facilitates that pattern\nby ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\nthrowing if not, indicating the %%className%% if provided.",
      "tags": []
    },
    {
      "name": "ErrorInfo",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ErrorInfo<T> = Omit<T, \"code\" | \"name\" | \"message\" | \"shortMessage\"> & { shortMessage?: string };",
      "doc": "An error may contain additional properties, but those must not\nconflict with any implicit properties.",
      "tags": []
    },
    {
      "name": "ErrorCode",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVAL",
      "doc": "All errors emitted by ethers have an **ErrorCode** to help\nidentify and coalesce errors to simplify programmatic analysis.\n\nEach **ErrorCode** is the %%code%% proerty of a coresponding\n[[EthersError]].\n\n**Generic Errors**\n\n**``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n\n**``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n\n**``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n\n**``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n\n**``\"SERVER_ERROR\"``** - see [[ServerError]]\n\n**``\"TIMEOUT\"``** - see [[TimeoutError]]\n\n**``\"BAD_DATA\"``** - see [[BadDataError]]\n\n**``\"CANCELLED\"``** - see [[CancelledError]]\n\n**Operational Errors**\n\n**``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n\n**``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n\n**Argument Errors**\n\n**``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n\n**``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n\n**``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n\n**``\"VALUE_MISMATCH\"``** - //unused//\n\n**Blockchain Errors**\n\n**``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n\n**``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n\n**``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n\n**``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n\n**``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n\n**``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n\n**``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n\n**User Interaction Errors**\n\n**``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]",
      "tags": []
    },
    {
      "name": "EthersError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  A short message describing the error, with minimal additional\n     *  details.\n     */\n    shortMessage: string;\n\n    /**\n     *  Additio",
      "doc": "All errors in Ethers include properties to assist in\nmachine-readable errors.",
      "tags": []
    },
    {
      "name": "UnknownError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}",
      "doc": "This Error is a catch-all for when there is no way for Ethers to\nknow what the underlying problem is.",
      "tags": []
    },
    {
      "name": "NotImplementedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}",
      "doc": "This Error is mostly used as a stub for functionality that is\nintended for the future, but is currently not implemented.",
      "tags": []
    },
    {
      "name": "UnsupportedOperationError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}",
      "doc": "This Error indicates that the attempted operation is not supported.\n\nThis could range from a specific JSON-RPC end-point not supporting\na feature to a specific configuration of an object prohibiting the\noperation.\n\nFor example, a [[Wallet]] with no connected [[Provider]] is unable\nto send a transaction.",
      "tags": []
    },
    {
      "name": "NetworkError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    /**\n     *  The network event.\n     */\n    event: string;\n}",
      "doc": "This Error indicates a problem connecting to a network.",
      "tags": []
    },
    {
      "name": "ServerError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}",
      "doc": "This Error indicates there was a problem fetching a resource from\na server.",
      "tags": []
    },
    {
      "name": "TimeoutError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}",
      "doc": "This Error indicates that the timeout duration has expired and\nthat the operation has been implicitly cancelled.\n\nThe side-effect of the operation may still occur, as this\ngenerally means a request has been sent and there has simply\nbeen no response to indicate whether it was processed or not.",
      "tags": []
    },
    {
      "name": "BadDataError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}",
      "doc": "This Error indicates that a provided set of data cannot\nbe correctly interpreted.",
      "tags": []
    },
    {
      "name": "CancelledError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CancelledError extends EthersError<\"CANCELLED\"> {\n}",
      "doc": "This Error indicates that the operation was cancelled by a\nprogrammatic call, for example to ``cancel()``.",
      "tags": []
    },
    {
      "name": "BufferOverrunError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n",
      "doc": "This Error indicates an attempt was made to read outside the bounds\nof protected data.\n\nMost operations in Ethers are protected by bounds checks, to mitigate\nexploits when parsing data.",
      "tags": []
    },
    {
      "name": "NumericFaultError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}",
      "doc": "This Error indicates an operation which would result in incorrect\narithmetic output has occurred.\n\nFor example, trying to divide by zero or using a ``uint8`` to store\na negative value.",
      "tags": []
    },
    {
      "name": "InvalidArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}",
      "doc": "This Error indicates an incorrect type or value was passed to\na function or method.",
      "tags": []
    },
    {
      "name": "MissingArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}",
      "doc": "This Error indicates there were too few arguments were provided.",
      "tags": []
    },
    {
      "name": "UnexpectedArgumentError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}",
      "doc": "This Error indicates too many arguments were provided.",
      "tags": []
    },
    {
      "name": "CallExceptionAction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"sendTransaction\" | \"unknown\";",
      "doc": "The action that resulted in the call exception.",
      "tags": []
    },
    {
      "name": "CallExceptionTransaction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};",
      "doc": "The related transaction that caused the error.",
      "tags": []
    },
    {
      "name": "CallExceptionError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-reada",
      "doc": "This **Error** indicates a transaction reverted.",
      "tags": []
    },
    {
      "name": "InsufficientFundsError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "The sending account has insufficient funds to cover the\nentire transaction cost.",
      "tags": []
    },
    {
      "name": "NonceExpiredError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "The sending account has already used this nonce in a\ntransaction that has been included.",
      "tags": []
    },
    {
      "name": "OffchainFaultError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}",
      "doc": "A CCIP-read exception, which cannot be recovered from or\nbe further processed.",
      "tags": []
    },
    {
      "name": "ReplacementUnderpricedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}",
      "doc": "An attempt was made to replace a transaction, but with an\ninsufficient additional fee to afford evicting the old\ntransaction from the memory pool.",
      "tags": []
    },
    {
      "name": "TransactionReplacedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was repla",
      "doc": "A pending transaction was replaced by another.",
      "tags": []
    },
    {
      "name": "UnconfiguredNameError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}",
      "doc": "This Error indicates an ENS name was used, but the name has not\nbeen configured.\n\nThis could indicate an ENS name is unowned or that the current\naddress being pointed to is the [[ZeroAddress]].",
      "tags": []
    },
    {
      "name": "ActionRejectedError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n ",
      "doc": "This Error indicates a request was rejected by the user.\n\nIn most clients (such as MetaMask), when an operation requires user\nauthorization (such as ``signer.sendTransaction``), the client\npresents a dialog box to the user. If the user denies the request\nthis error is thrown.",
      "tags": []
    },
    {
      "name": "CodedEthersError",
      "kind": "TypeAliasDeclaration",
      "signature": "export type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T ex",
      "doc": "A conditional type that transforms the [[ErrorCode]] T into\nits EthersError type.",
      "tags": [
        {
          "tagName": "flatworm-skip-docs",
          "text": ""
        }
      ]
    },
    {
      "name": "getBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}",
      "doc": "Get a typed Uint8Array for %%value%%. If already a Uint8Array\nthe original %%value%% is returned; if a copy is required use\n[[getBytesCopy]].",
      "tags": [
        {
          "tagName": "see",
          "text": ": getBytesCopy"
        }
      ]
    },
    {
      "name": "getBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "getBytesCopy",
      "kind": "FunctionDeclaration",
      "signature": "export function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}",
      "doc": "Get a typed Uint8Array for %%value%%, creating a copy if necessary\nto prevent any modifications of the returned value from being\nreflected elsewhere.",
      "tags": [
        {
          "tagName": "see",
          "text": ": getBytes"
        }
      ]
    },
    {
      "name": "getBytesCopy.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getBytesCopy.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "isHexString",
      "kind": "FunctionDeclaration",
      "signature": "export function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (lengt",
      "doc": "Returns true if %%value%% is a valid [[HexString]].\n\nIf %%length%% is ``true`` or a //number//, it also checks that\n%%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\nbytes of data (e.g. ``0x1234`` is 2 bytes).",
      "tags": []
    },
    {
      "name": "isBytesLike",
      "kind": "FunctionDeclaration",
      "signature": "export function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}",
      "doc": "Returns true if %%value%% is a valid representation of arbitrary\ndata (i.e. a valid [[DataHexString]] or a Uint8Array).",
      "tags": []
    },
    {
      "name": "hexlify",
      "kind": "FunctionDeclaration",
      "signature": "export function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}",
      "doc": "Returns a [[DataHexString]] representation of %%data%%.",
      "tags": []
    },
    {
      "name": "concat",
      "kind": "FunctionDeclaration",
      "signature": "export function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}",
      "doc": "Returns a [[DataHexString]] by concatenating all values\nwithin %%data%%.",
      "tags": []
    },
    {
      "name": "dataLength",
      "kind": "FunctionDeclaration",
      "signature": "export function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}",
      "doc": "Returns the length of %%data%%, in bytes.",
      "tags": []
    },
    {
      "name": "dataSlice",
      "kind": "FunctionDeclaration",
      "signature": "export function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n",
      "doc": "Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\noffset to the %%end%% offset.\n\nBy default %%start%% is 0 and %%end%% is the length of %%data%%.",
      "tags": []
    },
    {
      "name": "stripZerosLeft",
      "kind": "FunctionDeclaration",
      "signature": "export function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}",
      "doc": "Return the [[DataHexString]] result by stripping all **leading**\n* zero bytes from %%data%%.",
      "tags": []
    },
    {
      "name": "zeroPadValue",
      "kind": "FunctionDeclaration",
      "signature": "export function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}",
      "doc": "Return the [[DataHexString]] of %%data%% padded on the **left**\nto %%length%% bytes.\n\nIf %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\nthrown.\n\nThis pads data the same as **values** are in Solidity\n(e.g. ``uint128``).",
      "tags": []
    },
    {
      "name": "zeroPadBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}",
      "doc": "Return the [[DataHexString]] of %%data%% padded on the **right**\nto %%length%% bytes.\n\nIf %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\nthrown.\n\nThis pads data the same as **bytes** are in Solidity\n(e.g. ``bytes16``).",
      "tags": []
    },
    {
      "name": "DataHexString",
      "kind": "TypeAliasDeclaration",
      "signature": "export type DataHexString = string;",
      "doc": "A [[HexString]] whose length is even, which ensures it is a valid\nrepresentation of binary data.",
      "tags": []
    },
    {
      "name": "HexString",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HexString = string;",
      "doc": "A string which is prefixed with ``0x`` and followed by any number\nof case-agnostic hexadecimal characters.\n\nIt must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.",
      "tags": []
    },
    {
      "name": "BytesLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BytesLike = DataHexString | Uint8Array;",
      "doc": "An object that can be used to represent binary data.",
      "tags": []
    },
    {
      "name": "decodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase64(value: string): Uint8Array {\n    return getBytesCopy(Buffer.from(value, \"base64\"));\n}",
      "doc": "Decodes the base-64 encoded %%value%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// The decoded value is always binary data...\nresult = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n//_result:\n\n// ...use toUtf8String to convert it to a string.\ntoUtf8String(result)\n//_result:\n\n// Decoding binary data\ndecodeBase64(\"EjQ=\")\n//_result:"
        }
      ]
    },
    {
      "name": "decodeBase64.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "encodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase64(data: BytesLike): string {\n    return Buffer.from(getBytes(data)).toString(\"base64\");\n}",
      "doc": "Encodes %%data%% as a base-64 encoded string.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Encoding binary data as a hexstring\nencodeBase64(\"0x1234\")\n//_result:\n\n// Encoding binary data as a Uint8Array\nencodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n//_result:\n\n// The input MUST be data...\nencodeBase64(\"Hello World!!\")\n//_error:\n\n// ...use toUtf8Bytes for this.\nencodeBase64(toUtf8Bytes(\"Hello World!!\"))\n//_result:"
        }
      ]
    },
    {
      "name": "decodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase64(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = new Uint8Array(textData.length);\n    for (let i = 0; i < textData.length; i++) {\n        data[i] = textData.charCodeAt(i);\n    }\n    return getBytes(data);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeBase64.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "encodeBase64",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase64(_data: BytesLike): string {\n    const data = getBytes(_data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeBase58",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBase58(_value: BytesLike): string {\n    const bytes = getBytes(_value);\n\n    let value = toBigInt(bytes);\n    let result = \"\";\n    while (value) {\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n\n    // Account for leading padding zeros\n",
      "doc": "Encode %%value%% as a Base58-encoded string.",
      "tags": []
    },
    {
      "name": "decodeBase58",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBase58(value: string): bigint {\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}",
      "doc": "Decode the Base58-encoded %%value%%.",
      "tags": []
    },
    {
      "name": "TransactionLike",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionLike<A = string> {\n    /**\n     *  The type.\n     */\n    type?: null | number;\n\n    /**\n     *  The recipient address or ``null`` for an ``init`` transaction.\n     */\n    to?: null | A;\n\n    /**\n     *  The sender.\n     */\n    from?: null | A;\n\n    /**\n     *  The nonce.\n",
      "doc": "A **TransactionLike** is an object which is appropriate as a loose\ninput for many operations which will populate missing properties of\na transaction.",
      "tags": []
    },
    {
      "name": "Blob",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Blob {\n    data: string;\n    proof: string;\n    commitment: string;\n}",
      "doc": "A full-valid BLOb object for [[link-eip-4844]] transactions.\n\nThe commitment and proof should have been computed using a\nKZG library.",
      "tags": []
    },
    {
      "name": "BlobLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BlobLike = BytesLike | {\n    data: BytesLike;\n    proof: BytesLike;\n    commitment: BytesLike;\n};",
      "doc": "A BLOb object that can be passed for [[link-eip-4844]]\ntransactions.\n\nIt may have had its commitment and proof already provided\nor rely on an attached [[KzgLibrary]] to compute them.",
      "tags": []
    },
    {
      "name": "KzgLibrary",
      "kind": "InterfaceDeclaration",
      "signature": "export interface KzgLibrary {\n    blobToKzgCommitment: (blob: Uint8Array) => Uint8Array;\n    computeBlobKzgProof: (blob: Uint8Array, commitment: Uint8Array) => Uint8Array;\n}",
      "doc": "A KZG Library with the necessary functions to compute\nBLOb commitments and proofs.",
      "tags": []
    },
    {
      "name": "KzgLibraryLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type KzgLibraryLike  = KzgLibrary | {\n    // kzg-wasm >= 0.5.0\n    blobToKZGCommitment: (blob: string) => string;\n    computeBlobKZGProof: (blob: string, commitment: string) => string;\n} | {\n    // micro-ecc-signer\n    blobToKzgCommitment: (blob: string) => string | Uint8Array;\n    computeBlo",
      "doc": "A KZG Library with any of the various API configurations.\nAs the library is still experimental and the API is not\nstable, depending on the version used the method names and\nsignatures are still in flux.\n\nThis allows any of the versions to be passed into Transaction\nwhile providing a stable external API.",
      "tags": []
    },
    {
      "name": "Transaction",
      "kind": "ClassDeclaration",
      "signature": "export class Transaction implements TransactionLike<string> {\n    #type: null | number;\n    #to: null | string;\n    #data: string;\n    #nonce: number;\n    #gasLimit: bigint;\n    #gasPrice: null | bigint;\n    #maxPriorityFeePerGas: null | bigint;\n    #maxFeePerGas: null | bigint;\n    #value: bigint;\n",
      "doc": "A **Transaction** describes an operation to be executed on\nEthereum by an Externally Owned Account (EOA). It includes\nwho (the [[to]] address), what (the [[data]]) and how much (the\n[[value]] in ether) the operation should entail.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\ntx = new Transaction()\n//_result:\n\ntx.data = \"0x1234\";\n//_result:"
        }
      ]
    },
    {
      "name": "AccessListEntry",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessListEntry = { address: string, storageKeys: Array<string> };",
      "doc": "A single [[AccessList]] entry of storage keys (slots) for an address.",
      "tags": []
    },
    {
      "name": "AccessList",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessList = Array<AccessListEntry>;",
      "doc": "An ordered collection of [[AccessList]] entries.",
      "tags": []
    },
    {
      "name": "AccessListish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;",
      "doc": "Any ethers-supported access list structure.",
      "tags": []
    },
    {
      "name": "Authorization",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Authorization {\n    address: string;\n    nonce: bigint;\n    chainId: bigint;\n    signature: Signature;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "AuthorizationLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AuthorizationLike = {\n    address: string;\n    nonce: BigNumberish;\n    chainId: BigNumberish;\n    signature: SignatureLike\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify",
      "kind": "FunctionDeclaration",
      "signature": "export function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.le",
      "doc": "Returns a [[AccessList]] from any ethers-supported access-list structure.",
      "tags": []
    },
    {
      "name": "accessListify.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "authorizationify",
      "kind": "FunctionDeclaration",
      "signature": "export function authorizationify(auth: AuthorizationLike): Authorization {\n    return {\n        address: getAddress(auth.address),\n        nonce: getBigInt((auth.nonce != null) ? auth.nonce: 0),\n        chainId: getBigInt((auth.chainId != null)? auth.chainId: 0),\n        signature: Signature.from(au",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.address",
      "kind": "PropertySignature",
      "signature": "address: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.nonce",
      "kind": "PropertySignature",
      "signature": "nonce: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.chainId",
      "kind": "PropertySignature",
      "signature": "chainId: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.signature",
      "kind": "PropertySignature",
      "signature": "signature: Signature;",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function computeAddress(key: string | SigningKey): string {\n    let pubkey: string;\n    if (typeof(key) === \"string\") {\n        pubkey = SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).subs",
      "doc": "Returns the address for the %%key%%.\n\nThe key may be any standard form of public key or a private key.",
      "tags": []
    },
    {
      "name": "recoverAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\n}",
      "doc": "Returns the recovered address for the private key that was\nused to sign %%digest%% that resulted in %%signature%%.",
      "tags": []
    },
    {
      "name": "Transaction",
      "kind": "ClassDeclaration",
      "signature": "export class Transaction implements TransactionLike<string> {\n    #type: null | number;\n    #to: null | string;\n    #data: string;\n    #nonce: number;\n    #gasLimit: bigint;\n    #gasPrice: null | bigint;\n    #maxPriorityFeePerGas: null | bigint;\n    #maxFeePerGas: null | bigint;\n    #value: bigint;\n",
      "doc": "A **Transaction** describes an operation to be executed on\nEthereum by an Externally Owned Account (EOA). It includes\nwho (the [[to]] address), what (the [[data]]) and how much (the\n[[value]] in ether) the operation should entail.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\ntx = new Transaction()\n//_result:\n\ntx.data = \"0x1234\";\n//_result:"
        }
      ]
    },
    {
      "name": "Blob",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Blob {\n    data: string;\n    proof: string;\n    commitment: string;\n}",
      "doc": "A full-valid BLOb object for [[link-eip-4844]] transactions.\n\nThe commitment and proof should have been computed using a\nKZG library.",
      "tags": []
    },
    {
      "name": "BlobLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BlobLike = BytesLike | {\n    data: BytesLike;\n    proof: BytesLike;\n    commitment: BytesLike;\n};",
      "doc": "A BLOb object that can be passed for [[link-eip-4844]]\ntransactions.\n\nIt may have had its commitment and proof already provided\nor rely on an attached [[KzgLibrary]] to compute them.",
      "tags": []
    },
    {
      "name": "KzgLibrary",
      "kind": "InterfaceDeclaration",
      "signature": "export interface KzgLibrary {\n    blobToKzgCommitment: (blob: Uint8Array) => Uint8Array;\n    computeBlobKzgProof: (blob: Uint8Array, commitment: Uint8Array) => Uint8Array;\n}",
      "doc": "A KZG Library with the necessary functions to compute\nBLOb commitments and proofs.",
      "tags": []
    },
    {
      "name": "KzgLibraryLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type KzgLibraryLike  = KzgLibrary | {\n    // kzg-wasm >= 0.5.0\n    blobToKZGCommitment: (blob: string) => string;\n    computeBlobKZGProof: (blob: string, commitment: string) => string;\n} | {\n    // micro-ecc-signer\n    blobToKzgCommitment: (blob: string) => string | Uint8Array;\n    computeBlo",
      "doc": "A KZG Library with any of the various API configurations.\nAs the library is still experimental and the API is not\nstable, depending on the version used the method names and\nsignatures are still in flux.\n\nThis allows any of the versions to be passed into Transaction\nwhile providing a stable external API.",
      "tags": []
    },
    {
      "name": "TransactionLike",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionLike<A = string> {\n    /**\n     *  The type.\n     */\n    type?: null | number;\n\n    /**\n     *  The recipient address or ``null`` for an ``init`` transaction.\n     */\n    to?: null | A;\n\n    /**\n     *  The sender.\n     */\n    from?: null | A;\n\n    /**\n     *  The nonce.\n",
      "doc": "A **TransactionLike** is an object which is appropriate as a loose\ninput for many operations which will populate missing properties of\na transaction.",
      "tags": []
    },
    {
      "name": "authorizationify",
      "kind": "FunctionDeclaration",
      "signature": "export function authorizationify(auth: AuthorizationLike): Authorization {\n    return {\n        address: getAddress(auth.address),\n        nonce: getBigInt((auth.nonce != null) ? auth.nonce: 0),\n        chainId: getBigInt((auth.chainId != null)? auth.chainId: 0),\n        signature: Signature.from(au",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.address",
      "kind": "PropertySignature",
      "signature": "address: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.nonce",
      "kind": "PropertySignature",
      "signature": "nonce: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.chainId",
      "kind": "PropertySignature",
      "signature": "chainId: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "authorizationify.signature",
      "kind": "PropertySignature",
      "signature": "signature: Signature;",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function computeAddress(key: string | SigningKey): string {\n    let pubkey: string;\n    if (typeof(key) === \"string\") {\n        pubkey = SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).subs",
      "doc": "Returns the address for the %%key%%.\n\nThe key may be any standard form of public key or a private key.",
      "tags": []
    },
    {
      "name": "recoverAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\n}",
      "doc": "Returns the recovered address for the private key that was\nused to sign %%digest%% that resulted in %%signature%%.",
      "tags": []
    },
    {
      "name": "accessListify",
      "kind": "FunctionDeclaration",
      "signature": "export function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.le",
      "doc": "Returns a [[AccessList]] from any ethers-supported access-list structure.",
      "tags": []
    },
    {
      "name": "accessListify.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "accessListify.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "WebSocket",
      "kind": "ClassDeclaration",
      "signature": "export class WebSocket {\n        constructor(...args: Array<any>);\n\n        onopen: null | ((...args: Array<any>) => any);\n        onmessage: null | ((...args: Array<any>) => any);\n        onerror: null | ((...args: Array<any>) => any);\n\n        readyState: number;\n\n        send(payload: any): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "WebSocket",
      "kind": "VariableDeclaration",
      "signature": "_WebSocket = getGlobal().WebSocket",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPollingSubscriber",
      "kind": "FunctionDeclaration",
      "signature": "export function getPollingSubscriber(provider: AbstractProvider, event: ProviderEvent): Subscriber {\n    if (event === \"block\") { return new PollingBlockSubscriber(provider); }\n    if (isHexString(event, 32)) { return new PollingTransactionSubscriber(provider, event); }\n\n    assert(false, \"unsupport",
      "doc": "Return the polling subscriber for common events.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "getPollingSubscriber.start",
      "kind": "MethodSignature",
      "signature": "start(): void;",
      "doc": "Called initially when a subscriber is added the first time.",
      "tags": []
    },
    {
      "name": "getPollingSubscriber.stop",
      "kind": "MethodSignature",
      "signature": "stop(): void;",
      "doc": "Called when there are no more subscribers to the event.",
      "tags": []
    },
    {
      "name": "getPollingSubscriber.pause",
      "kind": "MethodSignature",
      "signature": "pause(dropWhilePaused?: boolean): void;",
      "doc": "Called when the subscription should pause.\n\nIf %%dropWhilePaused%%, events that occur while paused should not\nbe emitted [[resume]].",
      "tags": []
    },
    {
      "name": "getPollingSubscriber.resume",
      "kind": "MethodSignature",
      "signature": "resume(): void;",
      "doc": "Resume a paused subscriber.",
      "tags": []
    },
    {
      "name": "getPollingSubscriber.pollingInterval",
      "kind": "PropertySignature",
      "signature": "pollingInterval?: number;",
      "doc": "The frequency (in ms) to poll for events, if polling is used by\nthe subscriber.\n\nFor non-polling subscribers, this must return ``undefined``.",
      "tags": []
    },
    {
      "name": "PollingBlockSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class PollingBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poller: null | number;\n\n    #interval: number;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: nu",
      "doc": "A **PollingBlockSubscriber** polls at a regular interval for a change\nin the block number.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "OnBlockSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class OnBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poll: (b: number) => void;\n    #running: boolean;\n\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = ",
      "doc": "An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\nimplmentation which will be called on every new block.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "PollingBlockTagSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class PollingBlockTagSubscriber extends OnBlockSubscriber {\n    readonly #tag: string;\n    #lastBlock: number;\n\n    constructor(provider: AbstractProvider, tag: string) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n\n    pause(dropWhilePaused?: boolean",
      "doc": "",
      "tags": []
    },
    {
      "name": "PollingOrphanSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter: OrphanFilter;\n\n    constructor(provider: AbstractProvider, filter: OrphanFilter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Prom",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        },
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "PollingTransactionSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash: string;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider: AbstractProvider, hash: string) {\n        super(provider",
      "doc": "A **PollingTransactionSubscriber** will poll for a given transaction\nhash for its receipt.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "PollingEventSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class PollingEventSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #filter: EventFilter;\n    #poller: (b: number) => void;\n\n    #running: boolean;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial b",
      "doc": "A **PollingEventSubscriber** will poll for a given filter for its logs.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "FilterIdSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class FilterIdSubscriber implements Subscriber {\n    #provider: JsonRpcApiProvider;\n\n    #filterIdPromise: null | Promise<string>;\n    #poller: (b: number) => Promise<void>;\n\n    #running: boolean;\n\n    #network: null | Network;\n\n    #hault: boolean;\n\n    /**\n     *  Creates a new **FilterIdS",
      "doc": "Some backends support subscribing to events using a Filter ID.\n\nWhen subscribing with this technique, the node issues a unique\n//Filter ID//. At this point the node dedicates resources to\nthe filter, so that periodic calls to follow up on the //Filter ID//\nwill receive any events since the last call.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "FilterIdEventSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event: EventFilter;\n\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider: JsonRpcApiProvider, filter: EventFilter) {\n        super(",
      "doc": "A **FilterIdSubscriber** for receiving contract events.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "FilterIdPendingSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        return await provider.send(\"eth_newPendingTransactionFilter\", [ ]);\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Prom",
      "doc": "A **FilterIdSubscriber** for receiving pending transactions events.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "ConnectionRpcProvider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConnectionRpcProvider extends Provider {\n    //send(method: string, params: Array<any>): Promise<any>;\n    _subscribe(param: Array<any>, processFunc: (result: any) => void): number;\n    _unsubscribe(filterId: number): void;\n}",
      "doc": "",
      "tags": [
        {
          "tagName": "TODO",
          "text": ""
        },
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "BlockConnectionSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class BlockConnectionSubscriber implements Subscriber {\n    #provider: ConnectionRpcProvider;\n    #blockNumber: number;\n\n    #running: boolean;\n\n    #filterId: null | number;\n\n    constructor(provider: ConnectionRpcProvider) {\n        this.#provider = provider;\n        this.#blockNumber = -2;",
      "doc": "",
      "tags": [
        {
          "tagName": "TODO",
          "text": ""
        },
        {
          "tagName": "_docloc",
          "text": ": api/providers/abstract-provider"
        }
      ]
    },
    {
      "name": "Signer",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Signer extends Addressable, ContractRunner, NameResolver {\n\n    /**\n     *  The [[Provider]] attached to this Signer (if any).\n     */\n    provider: null | Provider;\n\n    /**\n     *  Returns a new instance of this Signer connected to //provider// or detached\n     *  from any Provide",
      "doc": "A Signer represents an account on the Ethereum Blockchain, and is most often\nbacked by a private key represented by a mnemonic or residing on a Hardware Wallet.\n\nThe API remains abstract though, so that it can deal with more advanced exotic\nSigning entities, such as Smart Contract Wallets or Virtual Wallets (where the\nprivate key may not be known).",
      "tags": []
    },
    {
      "name": "NonceManager",
      "kind": "ClassDeclaration",
      "signature": "export class NonceManager extends AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer!: Signer;\n\n    #noncePromise: null | Promise<number>;\n    #delta: number;\n\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer: Signer) {\n  ",
      "doc": "A **NonceManager** wraps another [[Signer]] and automatically manages\nthe nonce, ensuring serialized and sequential nonces are used during\ntransaction.",
      "tags": []
    },
    {
      "name": "copyRequest",
      "kind": "FunctionDeclaration",
      "signature": "export function copyRequest(req: TransactionRequest): PreparedTransactionRequest {\n    const result: any = { };\n\n    // These could be addresses, ENS names or Addressables\n    if (req.to) { result.to = req.to; }\n    if (req.from) { result.from = req.from; }\n\n    if (req.data) { result.data = hexlify",
      "doc": "Returns a copy of %%req%% with all properties coerced to their strict\ntypes.",
      "tags": []
    },
    {
      "name": "copyRequest.type",
      "kind": "PropertySignature",
      "signature": "type?: number;",
      "doc": "The transaction type.",
      "tags": []
    },
    {
      "name": "copyRequest.to",
      "kind": "PropertySignature",
      "signature": "to?: AddressLike;",
      "doc": "The target of the transaction.",
      "tags": []
    },
    {
      "name": "copyRequest.from",
      "kind": "PropertySignature",
      "signature": "from?: AddressLike;",
      "doc": "The sender of the transaction.",
      "tags": []
    },
    {
      "name": "copyRequest.nonce",
      "kind": "PropertySignature",
      "signature": "nonce?: number;",
      "doc": "The nonce of the transaction, used to prevent replay attacks.",
      "tags": []
    },
    {
      "name": "copyRequest.gasLimit",
      "kind": "PropertySignature",
      "signature": "gasLimit?: bigint;",
      "doc": "The maximum amount of gas to allow this transaction to consume.",
      "tags": []
    },
    {
      "name": "copyRequest.gasPrice",
      "kind": "PropertySignature",
      "signature": "gasPrice?: bigint;",
      "doc": "The gas price to use for legacy transactions or transactions on\nlegacy networks.\n\nMost of the time the ``max*FeePerGas`` is preferred.",
      "tags": []
    },
    {
      "name": "copyRequest.maxPriorityFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxPriorityFeePerGas?: bigint;",
      "doc": "The [[link-eip-1559]] maximum priority fee to pay per gas.",
      "tags": []
    },
    {
      "name": "copyRequest.maxFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxFeePerGas?: bigint;",
      "doc": "The [[link-eip-1559]] maximum total fee to pay per gas. The actual\nvalue used is protocol enforced to be the block's base fee.",
      "tags": []
    },
    {
      "name": "copyRequest.data",
      "kind": "PropertySignature",
      "signature": "data?: string;",
      "doc": "The transaction data.",
      "tags": []
    },
    {
      "name": "copyRequest.value",
      "kind": "PropertySignature",
      "signature": "value?: bigint;",
      "doc": "The transaction value (in wei).",
      "tags": []
    },
    {
      "name": "copyRequest.chainId",
      "kind": "PropertySignature",
      "signature": "chainId?: bigint;",
      "doc": "The chain ID for the network this transaction is valid on.",
      "tags": []
    },
    {
      "name": "copyRequest.accessList",
      "kind": "PropertySignature",
      "signature": "accessList?: AccessList;",
      "doc": "The [[link-eip-2930]] access list. Storage slots included in the access\nlist are //warmed// by pre-loading them, so their initial cost to\nfetch is guaranteed, but then each additional access is cheaper.",
      "tags": []
    },
    {
      "name": "copyRequest.authorizationList",
      "kind": "PropertySignature",
      "signature": "authorizationList?: Array<Authorization>;",
      "doc": "The [[link-eip-7702]] authorizations (if any).",
      "tags": []
    },
    {
      "name": "copyRequest.customData",
      "kind": "PropertySignature",
      "signature": "customData?: any;",
      "doc": "A custom object, which can be passed along for network-specific\nvalues.",
      "tags": []
    },
    {
      "name": "copyRequest.blockTag",
      "kind": "PropertySignature",
      "signature": "blockTag?: BlockTag;",
      "doc": "When using ``call`` or ``estimateGas``, this allows a specific\nblock to be queried. Many backends do not support this and when\nunsupported errors are silently squelched and ``\"latest\"`` is used.",
      "tags": []
    },
    {
      "name": "copyRequest.enableCcipRead",
      "kind": "PropertySignature",
      "signature": "enableCcipRead?: boolean;",
      "doc": "When using ``call``, this enables CCIP-read, which permits the\nprovider to be redirected to web-based content during execution,\nwhich is then further validated by the contract.\n\nThere are potential security implications allowing CCIP-read, as\nit could be used to expose the IP address or user activity during\nthe fetch to unexpected parties.",
      "tags": []
    },
    {
      "name": "BlockTag",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BlockTag = BigNumberish | string;",
      "doc": "A **BlockTag** specifies a specific block.\n\n**numeric value** - specifies the block height, where\nthe genesis block is block 0; many operations accept a negative\nvalue which indicates the block number should be deducted from\nthe most recent block. A numeric value may be a ``number``, ``bigint``,\nor a decimal of hex string.\n\n**blockhash** - specifies a specific block by its blockhash; this allows\npotentially orphaned blocks to be specifed, without ambiguity, but many\nbackends do not support this for some operations.",
      "tags": []
    },
    {
      "name": "FeeData",
      "kind": "ClassDeclaration",
      "signature": "export class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    readonly gasPrice!: null | bigint;\n\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of",
      "doc": "A **FeeData** wraps all the fee-related values associated with\nthe network.",
      "tags": []
    },
    {
      "name": "TransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: null | number;\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: null | AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: null | AddressLike;\n\n    /**\n     *  T",
      "doc": "A **TransactionRequest** is a transactions with potentially various\nproperties not defined, or with less strict types for its values.\n\nThis is used to pass to various operations, which will internally\ncoerce any types and populate any necessary values.",
      "tags": []
    },
    {
      "name": "PreparedTransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PreparedTransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: number;\n\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: AddressLike;\n\n    /**\n     *  The nonce of ",
      "doc": "A **PreparedTransactionRequest** is identical to a [[TransactionRequest]]\nexcept all the property types are strictly enforced.",
      "tags": []
    },
    {
      "name": "MinedBlock",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinedBlock extends Block {\n    /**\n     *  The block number also known as the block height.\n     */\n    readonly number: number;\n\n    /**\n     *  The block hash.\n     */\n    readonly hash: string;\n\n    /**\n     *  The block timestamp, in seconds from epoch.\n     */\n    readonly time",
      "doc": "An Interface to indicate a [[Block]] has been included in the\nblockchain. This asserts a Type Guard that necessary properties\nare non-null.\n\nBefore a block is included, it is a //pending// block.",
      "tags": []
    },
    {
      "name": "Block",
      "kind": "ClassDeclaration",
      "signature": "export class Block implements BlockParams, Iterable<string> {\n\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  ",
      "doc": "A **Block** represents the data associated with a full block on\nEthereum.",
      "tags": []
    },
    {
      "name": "Log",
      "kind": "ClassDeclaration",
      "signature": "export class Log implements LogParams {\n\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransacti",
      "doc": "A **Log** in Ethereum represents an event that has been included in a\ntransaction using the ``LOG*`` opcodes, which are most commonly used by\nSolidity's emit for announcing events.",
      "tags": []
    },
    {
      "name": "TransactionReceipt",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionReceipt implements TransactionReceiptParams, Iterable<Log> {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The address the transaction was sent to.\n     */\n  ",
      "doc": "A **TransactionReceipt** includes additional information about a\ntransaction that is only available after it has been mined.",
      "tags": []
    },
    {
      "name": "MinedTransactionResponse",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinedTransactionResponse extends TransactionResponse {\n    /**\n     *  The block number this transaction occurred in.\n     */\n    blockNumber: number;\n\n    /**\n     *  The block hash this transaction occurred in.\n     */\n    blockHash: string;\n\n    /**\n     *  The date this transact",
      "doc": "A **MinedTransactionResponse** is an interface representing a\ntransaction which has been mined and allows for a type guard for its\nproperty values being defined.",
      "tags": []
    },
    {
      "name": "TransactionResponse",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionResponse implements TransactionLike<string>, TransactionResponseParams {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The bl",
      "doc": "A **TransactionResponse** includes all properties about a transaction\nthat was sent to the network, which may or may not be included in a\nblock.\n\nThe [[TransactionResponse-isMined]] can be used to check if the\ntransaction has been mined as well as type guard that the otherwise\npossibly ``null`` properties are defined.",
      "tags": []
    },
    {
      "name": "OrphanFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OrphanFilter = {\n    orphan: \"drop-block\",\n    hash: string,\n    number: number\n} | {\n    orphan: \"drop-transaction\",\n    tx: { hash: string, blockHash: string, blockNumber: number },\n    other?: { hash: string, blockHash: string, blockNumber: number }\n} | {\n    orphan: \"reorder-transact",
      "doc": "An Orphan Filter allows detecting when an orphan block has\nresulted in dropping a block or transaction or has resulted\nin transactions changing order.\n\nNot currently fully supported.",
      "tags": []
    },
    {
      "name": "TopicFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type TopicFilter = Array<null | string | Array<string>>;",
      "doc": "A **TopicFilter** provides a struture to define bloom-filter\nqueries.\n\nEach field that is ``null`` matches **any** value, a field that is\na ``string`` must match exactly that value and ``array`` is\neffectively an ``OR``-ed set, where any one of those values must\nmatch.",
      "tags": []
    },
    {
      "name": "EventFilter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EventFilter {\n    address?: AddressLike | Array<AddressLike>;\n    topics?: TopicFilter;\n}",
      "doc": "An **EventFilter** allows efficiently filtering logs (also known as\nevents) using bloom filters included within blocks.",
      "tags": []
    },
    {
      "name": "Filter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Filter extends EventFilter {\n\n    /**\n     *  The start block for the filter (inclusive).\n     */\n    fromBlock?: BlockTag;\n\n    /**\n     *  The end block for the filter (inclusive).\n     */\n    toBlock?: BlockTag;\n}",
      "doc": "A **Filter** allows searching a specific range of blocks for mathcing\nlogs.",
      "tags": []
    },
    {
      "name": "FilterByBlockHash",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FilterByBlockHash extends EventFilter {\n    /**\n     *  The blockhash of the specific block for the filter.\n     */\n    blockHash?: string;\n}",
      "doc": "A **FilterByBlockHash** allows searching a specific block for mathcing\nlogs.",
      "tags": []
    },
    {
      "name": "ProviderEvent",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProviderEvent = string | Array<string | Array<string>> | EventFilter | OrphanFilter;",
      "doc": "A **ProviderEvent** provides the types of events that can be subscribed\nto on a [[Provider]].\n\nEach provider may include additional possible events it supports, but\nthe most commonly supported are:\n\n**``\"block\"``** - calls the listener with the current block number on each\nnew block.\n\n**``\"error\"``** - calls the listener on each async error that occurs during\nthe event loop, with the error.\n\n**``\"debug\"``** - calls the listener on debug events, which can be used to\ntroubleshoot network errors, provider problems, etc.\n\n**``transaction hash``** - calls the listener on each block after the\ntransaction has been mined; generally ``.once`` is more appropriate for\nthis event.\n\n**``Array``** - calls the listener on each log that matches the filter.\n\n[[EventFilter]] - calls the listener with each matching log",
      "tags": []
    },
    {
      "name": "Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Provider extends ContractRunner, EventEmitterable<ProviderEvent>, NameResolver {\n\n    /**\n     *  The provider iteself.\n     *\n     *  This is part of the necessary API for executing a contract, as\n     *  it provides a common property on any [[ContractRunner]] that\n     *  can be u",
      "doc": "A **Provider** is the primary method to interact with the read-only\ncontent on Ethereum.\n\nIt allows access to details about accounts, blocks and transactions\nand the ability to query event logs and simulate contract execution.\n\nAccount data includes the [balance](getBalance),\n[transaction count](getTransactionCount), [code](getCode) and\n[state trie storage](getStorage).\n\nSimulating execution can be used to [call](call),\n[estimate gas](estimateGas) and\n[get transaction results](getTransactionResult).\n\nThe [[broadcastTransaction]] is the only method which allows updating\nthe blockchain, but it is usually accessed by a [[Signer]], since a\nprivate key must be used to sign the transaction before it can be\nbroadcast.",
      "tags": []
    },
    {
      "name": "WebSocketLike",
      "kind": "InterfaceDeclaration",
      "signature": "export interface WebSocketLike {\n    onopen: null | ((...args: Array<any>) => any);\n    onmessage: null | ((...args: Array<any>) => any);\n    onerror: null | ((...args: Array<any>) => any);\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}",
      "doc": "A generic interface to a Websocket-like object.",
      "tags": []
    },
    {
      "name": "WebSocketCreator",
      "kind": "TypeAliasDeclaration",
      "signature": "export type WebSocketCreator = () => WebSocketLike;",
      "doc": "A function which can be used to re-create a WebSocket connection\non disconnect.",
      "tags": []
    },
    {
      "name": "WebSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class WebSocketProvider extends SocketProvider {\n    #connect: null | WebSocketCreator;\n\n    #websocket: null | WebSocketLike;\n    get websocket(): WebSocketLike {\n        if (this.#websocket == null) { throw new Error(\"websocket closed\"); }\n        return this.#websocket;\n    }\n\n    construc",
      "doc": "A JSON-RPC provider which is backed by a WebSocket.\n\nWebSockets are often preferred because they retain a live connection\nto a server, which permits more instant access to events.\n\nHowever, this incurs higher server infrasturture costs, so additional\nresources may be required to host your own WebSocket nodes and many\nthird-party services charge additional fees for WebSocket endpoints.",
      "tags": []
    },
    {
      "name": "SocketSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketSubscriber implements Subscriber {\n    #provider: SocketProvider;\n\n    #filter: string;\n\n    /**\n     *  The filter.\n     */\n    get filter(): Array<any> { return JSON.parse(this.#filter); }\n\n    #filterId: null | Promise<string |number>;\n    #paused: null | boolean;\n\n    #emitPro",
      "doc": "A **SocketSubscriber** uses a socket transport to handle events and\nshould use [[_emit]] to manage the events.",
      "tags": []
    },
    {
      "name": "SocketBlockSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newHeads\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"block\", parseInt",
      "doc": "A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n``\"block\"`` events.",
      "tags": []
    },
    {
      "name": "SocketPendingSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketPendingSubscriber extends SocketSubscriber {\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newPendingTransactions\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(",
      "doc": "A **SocketPendingSubscriber** listens for pending transacitons and emits\n``\"pending\"`` events.",
      "tags": []
    },
    {
      "name": "SocketEventSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketEventSubscriber extends SocketSubscriber {\n    #logFilter: string;\n\n    /**\n     *  The filter.\n     */\n    get logFilter(): EventFilter { return JSON.parse(this.#logFilter); }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider, filter: EventFilter) {\n    ",
      "doc": "A **SocketEventSubscriber** listens for event logs.",
      "tags": []
    },
    {
      "name": "SocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class SocketProvider extends JsonRpcApiProvider {\n    #callbacks: Map<number, { payload: JsonRpcPayload, resolve: (r: any) => void, reject: (e: Error) => void }>;\n\n    // Maps each filterId to its subscriber\n    #subs: Map<number | string, SocketSubscriber>;\n\n    // If any events come in befo",
      "doc": "A **SocketProvider** is backed by a long-lived connection over a\nsocket, which can subscribe and receive real-time messages over\nits communication channel.",
      "tags": []
    },
    {
      "name": "QuickNodeProvider",
      "kind": "ClassDeclaration",
      "signature": "export class QuickNodeProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API token.\n     */\n    readonly token!: string;\n\n    /**\n     *  Creates a new **QuickNodeProvider**.\n     */\n    constructor(_network?: Networkish, token?: null | string) {\n        if (_netw",
      "doc": "The **QuickNodeProvider** connects to the [[link-quicknode]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API token is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-quicknode).",
      "tags": []
    },
    {
      "name": "PocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class PocketProvider extends JsonRpcProvider implements CommunityResourcable {\n\n    /**\n     *  The Application ID for the Pocket connection.\n     */\n    readonly applicationId!: string;\n\n    /**\n     *  The Application Secret for making authenticated requests\n     *  to the Pocket connection",
      "doc": "The **PocketProvider** connects to the [[link-pocket]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-pocket-signup).",
      "tags": []
    },
    {
      "name": "JsonRpcPayload",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcPayload = {\n    /**\n     *  The JSON-RPC request ID.\n     */\n    id: number;\n\n    /**\n     *  The JSON-RPC request method.\n     */\n    method: string;\n\n    /**\n     *  The JSON-RPC request parameters.\n     */\n    params: Array<any> | Record<string, any>;\n\n    /**\n     *  A require",
      "doc": "A JSON-RPC payload, which are sent to a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcResult",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcResult = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response result.\n     */\n    result: any;\n};",
      "doc": "A JSON-RPC result, which are returned on success from a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcError",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcError = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response error.\n     */\n    error: {\n        code: number;\n        message?: string;\n        data?: any;\n    }\n};",
      "doc": "A JSON-RPC error, which are returned on failure from a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "DebugEventJsonRpcApiProvider",
      "kind": "TypeAliasDeclaration",
      "signature": "export type DebugEventJsonRpcApiProvider = {\n    action: \"sendRpcPayload\",\n    payload: JsonRpcPayload | Array<JsonRpcPayload>\n} | {\n    action: \"receiveRpcResult\",\n    result: Array<JsonRpcResult | JsonRpcError>\n} | {\n    action: \"receiveRpcError\",\n    error: Error\n};",
      "doc": "When subscribing to the ``\"debug\"`` event, the [[Listener]] will\nreceive this object as the first parameter.",
      "tags": []
    },
    {
      "name": "JsonRpcApiProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcApiProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n    batchStallTime?: number;\n    batchMaxSize?: number;\n    batchMaxCount?: number;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};",
      "doc": "Options for configuring a [[JsonRpcApiProvider]]. Much of this\nis targetted towards sub-classes, which often will not expose\nany of these options to their consumers.\n\n**``polling``** - use the polling strategy is used immediately\nfor events; otherwise, attempt to use filters and fall back onto\npolling (default: ``false``)\n\n**``staticNetwork``** - do not request chain ID on requests to\nvalidate the underlying chain has not changed (default: ``null``)\n\nThis should **ONLY** be used if it is **certain** that the network\ncannot change, such as when using INFURA (since the URL dictates the\nnetwork). If the network is assumed static and it does change, this\ncan have tragic consequences. For example, this **CANNOT** be used\nwith MetaMask, since the user can select a new network from the\ndrop-down at any time.\n\n**``batchStallTime``** - how long (ms) to aggregate requests into a\nsingle batch. ``0`` indicates batching will only encompass the current\nevent loop. If ``batchMaxCount = 1``, this is ignored. (default: ``10``)\n\n**``batchMaxSize``** - target maximum size (bytes) to allow per batch\nrequest (default: 1Mb)\n\n**``batchMaxCount``** - maximum number of requests to allow in a batch.\nIf ``batchMaxCount = 1``, then batching is disabled. (default: ``100``)\n\n**``cacheTimeout``** - passed as [[AbstractProviderOptions]].",
      "tags": []
    },
    {
      "name": "JsonRpcTransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcTransactionRequest {\n     /**\n      *  The sender address to use when signing.\n      */\n     from?: string;\n\n     /**\n      *  The target address.\n      */\n     to?: string;\n\n     /**\n      *  The transaction data.\n      */\n     data?: string;\n\n     /**\n      *  The chain ID ",
      "doc": "A **JsonRpcTransactionRequest** is formatted as needed by the JSON-RPC\nEthereum API specification.",
      "tags": []
    },
    {
      "name": "JsonRpcSigner",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcSigner extends AbstractSigner<JsonRpcApiProvider> {\n    address!: string;\n\n    constructor(provider: JsonRpcApiProvider, address: string) {\n        super(provider);\n        address = getAddress(address);\n        defineProperties<JsonRpcSigner>(this, { address });\n    }\n\n    conne",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcApiProvider",
      "kind": "ClassDeclaration",
      "signature": "export abstract class JsonRpcApiProvider extends AbstractProvider {\n\n    #options: Required<JsonRpcApiProviderOptions>;\n\n    // The next ID to use for the JSON-RPC ID field\n    #nextId: number;\n\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads: Array<Payload>;\n ",
      "doc": "The JsonRpcApiProvider is an abstract class and **MUST** be\nsub-classed.\n\nIt provides the base for all JSON-RPC-based Provider interaction.\n\nSub-classing Notes:\n- a sub-class MUST override _send\n- a sub-class MUST call the `_start()` method once connected",
      "tags": []
    },
    {
      "name": "JsonRpcApiPollingProvider",
      "kind": "ClassDeclaration",
      "signature": "export abstract class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval: number;\n    constructor(network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n\n        let pollingInterval = this._getOption(\"pollingInterval\");\n        if (poll",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "JsonRpcProvider",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect: FetchRequest;\n\n    constructor(url?: string | FetchRequest, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        if (url == null) { url = \"http:/\\/localhost:8545\"; }\n        super(network, options);\n\n     ",
      "doc": "The JsonRpcProvider is one of the most common Providers,\nwhich performs all operations over HTTP (or HTTPS) requests.\n\nEvents are processed by polling the backend for the current block\nnumber; when it advances, all block-base events are then checked\nfor updates.",
      "tags": []
    },
    {
      "name": "IpcSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class IpcSocketProvider extends SocketProvider {\n    #socket: Socket;\n\n    /**\n     *  The connected socket.\n     */\n    get socket(): Socket { return this.#socket; }\n\n    constructor(path: string, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n ",
      "doc": "An **IpcSocketProvider** connects over an IPC socket on the host\nwhich provides fast access to the node, but requires the node and\nthe script run on the same machine.",
      "tags": []
    },
    {
      "name": "IpcSocketProvider",
      "kind": "VariableDeclaration",
      "signature": "IpcSocketProvider = undefined",
      "doc": "",
      "tags": []
    },
    {
      "name": "InfuraWebSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    readonly projectId!: string;\n\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This s",
      "doc": "The **InfuraWebSocketProvider** connects to the [[link-infura]]\nWebSocket end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-infura-signup).",
      "tags": []
    },
    {
      "name": "InfuraProvider",
      "kind": "ClassDeclaration",
      "signature": "export class InfuraProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    readonly projectId!: string;\n\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This should not\n  ",
      "doc": "The **InfuraProvider** connects to the [[link-infura]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-infura-signup).",
      "tags": []
    },
    {
      "name": "FallbackProviderConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FallbackProviderConfig {\n\n    /**\n     *  The provider.\n     */\n    provider: AbstractProvider;\n\n    /**\n     *  The amount of time to wait before kicking off the next provider.\n     *\n     *  Any providers that have not responded can still respond and be\n     *  counted, but this e",
      "doc": "A configuration entry for how to use a [[Provider]].",
      "tags": []
    },
    {
      "name": "FallbackProviderState",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FallbackProviderState extends Required<FallbackProviderConfig> {\n\n    /**\n     *  The most recent blockNumber this provider has reported (-2 if none).\n     */\n    blockNumber: number;\n\n    /**\n     *  The number of total requests ever sent to this provider.\n     */\n    requests: num",
      "doc": "The statistics and state maintained for a [[Provider]].",
      "tags": []
    },
    {
      "name": "FallbackProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FallbackProviderOptions = {\n    // How many providers must agree on a value before reporting\n    // back the response\n    quorum?: number;\n\n    // How many providers must have reported the same event\n    // for it to be emitted (currently unimplmented)\n    eventQuorum?: number;\n\n    // H",
      "doc": "Additional options to configure a [[FallbackProvider]].",
      "tags": []
    },
    {
      "name": "FallbackProvider",
      "kind": "ClassDeclaration",
      "signature": "export class FallbackProvider extends AbstractProvider {\n\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    readonly quorum: number;\n\n    /**\n     *  @_ignore:\n     */\n    readonly eventQuorum: number;\n\n    /**\n     *  @_ignore:\n     */\n    ",
      "doc": "A **FallbackProvider** manages several [[Providers]] providing\nresilience by switching between slow or misbehaving nodes, security\nby requiring multiple backends to aggree and performance by allowing\nfaster backends to respond earlier.",
      "tags": []
    },
    {
      "name": "DebugEventEtherscanProvider",
      "kind": "TypeAliasDeclaration",
      "signature": "export type DebugEventEtherscanProvider = {\n    action: \"sendRequest\",\n    id: number,\n    url: string,\n    payload: Record<string, any>\n} | {\n    action: \"receiveRequest\",\n    id: number,\n    result: any\n} | {\n    action: \"receiveError\",\n    id: number,\n    error: any\n};",
      "doc": "When subscribing to the ``\"debug\"`` event on an Etherscan-based\nprovider, the events receive a **DebugEventEtherscanProvider**\npayload.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "EtherscanPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class EtherscanPlugin extends NetworkPlugin {\n    /**\n     *  The Etherscan API base URL.\n     */\n    readonly baseUrl!: string;\n\n    /**\n     *  Creates a new **EtherscanProvider** which will use\n     *  %%baseUrl%%.\n     */\n    constructor(baseUrl: string) {\n        super(EtherscanPluginId)",
      "doc": "A Network can include an **EtherscanPlugin** to provide\na custom base URL.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "EtherscanProvider",
      "kind": "ClassDeclaration",
      "signature": "export class EtherscanProvider extends AbstractProvider {\n\n    /**\n     *  The connected network.\n     */\n    readonly network!: Network;\n\n    /**\n     *  The API key or null if using the community provided bandwidth.\n     */\n    readonly apiKey!: null | string;\n\n    readonly #plugin: null | Ethersc",
      "doc": "The **EtherscanBaseProvider** is the super-class of\n[[EtherscanProvider]], which should generally be used instead.\n\nSince the **EtherscanProvider** includes additional code for\n[[Contract]] access, in //rare cases// that contracts are not\nused, this class can reduce code size.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "CloudflareProvider",
      "kind": "ClassDeclaration",
      "signature": "export class CloudflareProvider extends JsonRpcProvider {\n    constructor(_network?: Networkish) {\n        if (_network == null) { _network = \"mainnet\"; }\n        const network = Network.from(_network);\n        assertArgument(network.name === \"mainnet\", \"unsupported network\", \"network\", _network);\n ",
      "doc": "About Cloudflare...",
      "tags": []
    },
    {
      "name": "ChainstackProvider",
      "kind": "ClassDeclaration",
      "signature": "export class ChainstackProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API key for the Chainstack connection.\n     */\n    readonly apiKey!: string;\n\n    /**\n     *  Creates a new **ChainstackProvider**.\n     */\n    constructor(_network?: Networkish, apiKey?: nu",
      "doc": "The **ChainstackProvider** connects to the [[link-chainstack]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-chainstack).",
      "tags": []
    },
    {
      "name": "Eip1193Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Eip1193Provider {\n    /**\n     *  See [[link-eip-1193]] for details on this method.\n     */\n    request(request: { method: string, params?: Array<any> | Record<string, any> }): Promise<any>;\n}",
      "doc": "The interface to an [[link-eip-1193]] provider, which is a standard\nused by most injected providers, which the [[BrowserProvider]] accepts\nand exposes the API of.",
      "tags": []
    },
    {
      "name": "DebugEventBrowserProvider",
      "kind": "TypeAliasDeclaration",
      "signature": "export type DebugEventBrowserProvider = {\n    action: \"sendEip1193Payload\",\n    payload: { method: string, params: Array<any> }\n} | {\n    action: \"receiveEip1193Result\",\n    result: any\n} | {\n    action: \"receiveEip1193Error\",\n    error: Error\n};",
      "doc": "The possible additional events dispatched when using the ``\"debug\"``\nevent on a [[BrowserProvider]].",
      "tags": []
    },
    {
      "name": "Eip6963ProviderInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Eip6963ProviderInfo {\n    uuid: string;\n    name: string;\n    icon: string;\n    rdns: string;\n}",
      "doc": "Provider info provided by the [[link-eip-6963]] discovery mechanism.",
      "tags": []
    },
    {
      "name": "BrowserProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BrowserProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n\n    providerInfo?: Eip6963ProviderInfo;\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "BrowserDiscoverOptions",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BrowserDiscoverOptions {\n    /**\n     *  Override provider detection with this provider.\n     */\n    provider?: Eip1193Provider;\n\n    /**\n     *  Duration to wait to detect providers. (default: 300ms)\n     */\n    timeout?: number;\n\n    /**\n     *  Return the first detected provider.",
      "doc": "Specifies how [[link-eip-6963]] discovery should proceed.\n\nSee: [[BrowserProvider-discover]]",
      "tags": []
    },
    {
      "name": "BrowserProvider",
      "kind": "ClassDeclaration",
      "signature": "export class BrowserProvider extends JsonRpcApiPollingProvider {\n    #request: (method: string, params: Array<any> | Record<string, any>) => Promise<any>;\n\n    #providerInfo: null | Eip6963ProviderInfo;\n\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%",
      "doc": "A **BrowserProvider** is intended to wrap an injected provider which\nadheres to the [[link-eip-1193]] standard, which most (if not all)\ncurrently do.",
      "tags": []
    },
    {
      "name": "BlockscoutProvider",
      "kind": "ClassDeclaration",
      "signature": "export class BlockscoutProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API key.\n     */\n    readonly apiKey!: null | string;\n\n    /**\n     *  Creates a new **BlockscoutProvider**.\n     */\n    constructor(_network?: Networkish, apiKey?: null | string) {\n        ",
      "doc": "The **BlockscoutProvider** connects to the [[link-blockscout]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-blockscout).",
      "tags": []
    },
    {
      "name": "AnkrProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AnkrProvider extends JsonRpcProvider implements CommunityResourcable {\n\n    /**\n     *  The API key for the Ankr connection.\n     */\n    readonly apiKey!: string;\n\n    /**\n     *  Create a new **AnkrProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n",
      "doc": "The **AnkrProvider** connects to the [[link-ankr]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-ankr-signup).",
      "tags": []
    },
    {
      "name": "AlchemyProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AlchemyProvider extends JsonRpcProvider implements CommunityResourcable {\n    readonly apiKey!: string;\n\n    constructor(_network?: Networkish, apiKey?: null | string) {\n        if (_network == null) { _network = \"mainnet\"; }\n        const network = Network.from(_network);\n        if (a",
      "doc": "The **AlchemyProvider** connects to the [[link-alchemy]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-alchemy-signup).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty"
        }
      ]
    },
    {
      "name": "NetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class NetworkPlugin {\n    /**\n     *  The name of the plugin.\n     *\n     *  It is recommended to use reverse-domain-notation, which permits\n     *  unique names with a known authority as well as hierarchal entries.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **NetworkP",
      "doc": "A **NetworkPlugin** provides additional functionality on a [[Network]].",
      "tags": []
    },
    {
      "name": "GasCostParameters",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GasCostParameters = {\n    /**\n     *  The transactions base fee.\n     */\n    txBase?: number;\n\n    /**\n     *  The fee for creating a new account.\n     */\n    txCreate?: number;\n\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    txDataZero?: number;\n\n    /**\n     *  The fee ",
      "doc": "The gas cost parameters for a [[GasCostPlugin]].",
      "tags": []
    },
    {
      "name": "GasCostPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class GasCostPlugin extends NetworkPlugin implements GasCostParameters {\n    /**\n     *  The block number to treat these values as valid from.\n     *\n     *  This allows a hardfork to have updated values included as well as\n     *  mulutiple hardforks to be supported.\n     */\n    readonly eff",
      "doc": "A **GasCostPlugin** allows a network to provide alternative values when\ncomputing the intrinsic gas required for a transaction.",
      "tags": []
    },
    {
      "name": "EnsPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class EnsPlugin extends NetworkPlugin {\n\n    /**\n     *  The ENS Registrty Contract address.\n     */\n    readonly address!: string;\n\n    /**\n     *  The chain ID that the ENS contract lives on.\n     */\n    readonly targetNetwork!: number;\n\n    /**\n     *  Creates a new **EnsPlugin** connected",
      "doc": "An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\nContract address and the target network to use when using that\ncontract.\n\nVarious testnets have their own instance of the contract to use, but\nin general, the mainnet instance supports multi-chain addresses and\nshould be used.",
      "tags": []
    },
    {
      "name": "FeeDataNetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class FeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #feeDataFunc: (provider: Provider) => Promise<FeeData>;\n\n    /**\n     *  The fee data function provided to the constructor.\n     */\n    get feeDataFunc(): (provider: Provider) => Promise<FeeData> {\n        return this.#feeDataFun",
      "doc": "A **FeeDataNetworkPlugin** allows a network to provide and alternate\nmeans to specify its fee data.\n\nFor example, a network which does not support [[link-eip-1559]] may\nchoose to use a Gas Station site to approximate the gas price.",
      "tags": []
    },
    {
      "name": "FetchUrlFeeDataNetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #url: string;\n    readonly #processFunc: (f: () => Promise<FeeData>, p: Provider, r: FetchRequest) => Promise<{ gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint }>;\n\n    /**\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "PluginIdFallbackProvider",
      "kind": "VariableDeclaration",
      "signature": "PluginIdFallbackProvider = \"org.ethers.plugins.provider.QualifiedPlugin\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "CheckQualifiedPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class CheckQualifiedPlugin implements AbstractProviderPlugin {\n    declare name: string;\n\n    constructor() {\n        defineProperties<CheckQualifiedPlugin>(this, { name: PluginIdFallbackProvider });\n    }\n\n    connect(provider: AbstractProvider): CheckQualifiedPlugin {\n        return this;\n ",
      "doc": "",
      "tags": []
    },
    {
      "name": "PossiblyPrunedTransactionPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class PossiblyPrunedTransactionPlugin extends CheckQualifiedPlugin {\n    isQualified(action: PerformActionRequest, result: any): boolean {\n        if (action.method === \"getTransaction\" || action.method === \"getTransactionReceipt\") {\n            if (result == null) { return false; }\n        }",
      "doc": "",
      "tags": []
    },
    {
      "name": "PaginationResult",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PaginationResult<R> extends Array<R> {\n    next(): Promise<PaginationResult<R>>;\n\n    // The total number of results available or null if unknown\n    totalResults: null | number;\n\n    done: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "Networkish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Networkish = Network | number | bigint | string | {\n    name?: string,\n    chainId?: number,\n    //layerOneConnection?: Provider,\n    ensAddress?: string,\n    ensNetwork?: number\n};",
      "doc": "A Networkish can be used to allude to a Network, by specifing:\n- a [[Network]] object\n- a well-known (or registered) network name\n- a well-known (or registered) chain ID\n- an object with sufficient details to describe a network",
      "tags": []
    },
    {
      "name": "Network",
      "kind": "ClassDeclaration",
      "signature": "export class Network {\n    #name: string;\n    #chainId: bigint;\n\n    #plugins: Map<string, NetworkPlugin>;\n\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */\n    constructor(name: string, chainId: BigNumberish) {\n        this.#name = name;\n        this.#chainId = getBig",
      "doc": "A **Network** provides access to a chain's properties and allows\nfor plug-ins to extend functionality.",
      "tags": []
    },
    {
      "name": "AbstractProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AbstractProvider implements Provider {\n\n    #subs: Map<string, Sub>;\n    #plugins: Map<string, AbstractProviderPlugin>;\n\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState: null | boolean;\n\n    #destroyed: boolean;\n\n    #networkPromise: null | Promise<Netwo",
      "doc": "An **AbstractProvider** provides a base class for other sub-classes to\nimplement the [[Provider]] API by normalizing input arguments and\nformatting output results as well as tracking events for consistent\nbehaviour on an eventually-consistent network.",
      "tags": []
    },
    {
      "name": "UnmanagedSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class UnmanagedSubscriber implements Subscriber {\n    /**\n     *  The name fof the event.\n     */\n    name!: string;\n\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name: string) { defineProperties<UnmanagedSubscriber>(this, { name }); }\n\n    start(): ",
      "doc": "An **UnmanagedSubscriber** is useful for events which do not require\nany additional management, such as ``\"debug\"`` which only requires\nemit in synchronous event loop triggered calls.",
      "tags": []
    },
    {
      "name": "AbstractSigner",
      "kind": "ClassDeclaration",
      "signature": "export abstract class AbstractSigner<P extends null | Provider = null | Provider> implements Signer {\n    /**\n     *  The provider this signer is connected to.\n     */\n    readonly provider!: P;\n\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider?: P) {\n",
      "doc": "An **AbstractSigner** includes most of teh functionality required\nto get a [[Signer]] working as expected, but requires a few\nSigner-specific methods be overridden.",
      "tags": []
    },
    {
      "name": "VoidSigner",
      "kind": "ClassDeclaration",
      "signature": "export class VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    readonly address!: string;\n\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address: string, provider?: null | Provider) {\n        ",
      "doc": "A **VoidSigner** is a class deisgned to allow an address to be used\nin any API which accepts a Signer, but for which there are no\ncredentials available to perform any actual signing.\n\nThis for example allow impersonating an account for the purpose of\nstatic calls or estimating gas, but does not allow sending transactions.",
      "tags": []
    },
    {
      "name": "showThrottleMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function showThrottleMessage(service: string): void {\n    if (shown.has(service)) { return; }\n    shown.add(service);\n\n    console.log(\"========= NOTICE =========\")\n    console.log(`Request-Rate Exceeded for ${ service } (this message will not be repeated)`);\n    console.log(\"\");\n    console.",
      "doc": "Displays a warning in the console when the community resource is\nbeing used too heavily by the app, recommending the developer\nacquire their own credentials instead of using the community\ncredentials.\n\nThe notification will only occur once per service.",
      "tags": []
    },
    {
      "name": "getDefaultProvider",
      "kind": "FunctionDeclaration",
      "signature": "export function getDefaultProvider(network?: string | Networkish | WebSocketLike, options?: any): AbstractProvider {\n    if (options == null) { options = { }; }\n\n    const allowService = (name: string) => {\n        if (options[name] === \"-\") { return false; }\n        if (typeof(options.exclusive) ==",
      "doc": "Returns a default provider for %%network%%.\n\nIf %%network%% is a [[WebSocketLike]] or string that begins with\n``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\nby that WebSocket or URL.\n\nIf %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\na [[JsonRpcProvider]] is returned connected to that URL.\n\nOtherwise, a default provider is created backed by well-known public\nWeb3 backends (such as [[link-infura]]) using community-provided API\nkeys.\n\nThe %%options%% allows specifying custom API keys per backend (setting\nan API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\ncan be set to either a backend name or and array of backend names, which\nwill whitelist **only** those backends.\n\nCurrent backend strings supported are:\n- ``\"alchemy\"``\n- ``\"ankr\"``\n- ``\"cloudflare\"``\n- ``\"chainstack\"``\n- ``\"etherscan\"``\n- ``\"infura\"``\n- ``\"publicPolygon\"``\n- ``\"quicknode\"``",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Connect to a local Geth node\nprovider = getDefaultProvider(\"http://localhost:8545/\");\n\n// Connect to Ethereum mainnet with any current and future\n// third-party services available\nprovider = getDefaultProvider(\"mainnet\");\n\n// Connect to Polygon, but only allow Etherscan and\n// INFURA and use \"MY_API_KEY\" in calls to Etherscan.\nprovider = getDefaultProvider(\"matic\", {\netherscan: \"MY_API_KEY\",\nexclusive: [ \"etherscan\", \"infura\" ]\n});"
        }
      ]
    },
    {
      "name": "getDefaultProvider.#subs",
      "kind": "PropertyDeclaration",
      "signature": "#subs: Map<string, Sub>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#plugins",
      "kind": "PropertyDeclaration",
      "signature": "#plugins: Map<string, AbstractProviderPlugin>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#pausedState",
      "kind": "PropertyDeclaration",
      "signature": "#pausedState: null | boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#destroyed",
      "kind": "PropertyDeclaration",
      "signature": "#destroyed: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#networkPromise",
      "kind": "PropertyDeclaration",
      "signature": "#networkPromise: null | Promise<Network>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#anyNetwork",
      "kind": "PropertyDeclaration",
      "signature": "readonly #anyNetwork: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#performCache",
      "kind": "PropertyDeclaration",
      "signature": "#performCache: Map<string, Promise<any>>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#lastBlockNumber",
      "kind": "PropertyDeclaration",
      "signature": "#lastBlockNumber: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#nextTimer",
      "kind": "PropertyDeclaration",
      "signature": "#nextTimer: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#timers",
      "kind": "PropertyDeclaration",
      "signature": "#timers: Map<number, { timer: null | Timer, func: () => void, time: number }>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#disableCcipRead",
      "kind": "PropertyDeclaration",
      "signature": "#disableCcipRead: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#options",
      "kind": "PropertyDeclaration",
      "signature": "#options: Required<AbstractProviderOptions>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.pollingInterval",
      "kind": "GetAccessor",
      "signature": "get pollingInterval(): number { return this.#options.pollingInterval; }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.provider",
      "kind": "GetAccessor",
      "signature": "get provider(): this { return this; }",
      "doc": "Returns ``this``, to allow an **AbstractProvider** to implement\nthe [[ContractRunner]] interface.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.plugins",
      "kind": "GetAccessor",
      "signature": "get plugins(): Array<AbstractProviderPlugin> {\n        return Array.from(this.#plugins.values());\n    }",
      "doc": "Returns all the registered plug-ins.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.attachPlugin",
      "kind": "MethodDeclaration",
      "signature": "attachPlugin(plugin: AbstractProviderPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name,  plugin.connect(this));\n        return this;\n    }",
      "doc": "Attach a new plug-in.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getPlugin",
      "kind": "MethodDeclaration",
      "signature": "getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }",
      "doc": "Get a plugin by name.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.disableCcipRead",
      "kind": "GetAccessor",
      "signature": "get disableCcipRead(): boolean { return this.#disableCcipRead; }",
      "doc": "Prevent any CCIP-read operation, regardless of whether requested\nin a [[call]] using ``enableCcipRead``.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#perform",
      "kind": "MethodDeclaration",
      "signature": "async #perform<T = any>(req: PerformActionRequest): Promise<T> {\n        const timeout = this.#options.cacheTimeout;\n\n        // Caching disabled\n        if (timeout < 0) { return await this._perform(req); }\n\n        // Create a tag\n        const tag = getTag(req.method, req);\n\n        let perform =",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.ccipReadFetch",
      "kind": "MethodDeclaration",
      "signature": "async ccipReadFetch(tx: PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n     ",
      "doc": "Resolves to the data for executing the CCIP-read operations.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapBlock",
      "kind": "MethodDeclaration",
      "signature": "_wrapBlock(value: BlockParams, network: Network): Block {\n        return new Block(formatBlock(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a block before\nreturning it, to add additional properties or an alternate\nsub-class of [[Block]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapLog",
      "kind": "MethodDeclaration",
      "signature": "_wrapLog(value: LogParams, network: Network): Log {\n        return new Log(formatLog(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a log before\nreturning it, to add additional properties or an alternate\nsub-class of [[Log]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapTransactionReceipt",
      "kind": "MethodDeclaration",
      "signature": "_wrapTransactionReceipt(value: TransactionReceiptParams, network: Network): TransactionReceipt {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a transaction\nreceipt before returning it, to add additional properties or an\nalternate sub-class of [[TransactionReceipt]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapTransactionResponse",
      "kind": "MethodDeclaration",
      "signature": "_wrapTransactionResponse(tx: TransactionResponseParams, network: Network): TransactionResponse {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a transaction\nresponse before returning it, to add additional properties or an\nalternate sub-class of [[TransactionResponse]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._detectNetwork",
      "kind": "MethodDeclaration",
      "signature": "_detectNetwork(): Promise<Network> {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }",
      "doc": "Resolves to the Network, forcing a network detection using whatever\ntechnique the sub-class requires.\n\nSub-classes **must** override this.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._perform",
      "kind": "MethodDeclaration",
      "signature": "async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        assert(false, `unsupported method: ${ req.method }`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }",
      "doc": "Sub-classes should use this to perform all built-in operations. All\nmethods sanitizes and normalizes the values passed into this.\n\nSub-classes **must** override this.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBlockNumber",
      "kind": "MethodDeclaration",
      "signature": "async getBlockNumber(): Promise<number> {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) { this.#lastBlockNumber = blockNumber; }\n        return blockNumber;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getAddress",
      "kind": "MethodDeclaration",
      "signature": "_getAddress(address: AddressLike): string | Promise<string> {\n        return resolveAddress(address, this);\n    }",
      "doc": "Returns or resolves to the address for %%address%%, resolving ENS\nnames and [[Addressable]] objects and returning if already an\naddress.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getBlockTag",
      "kind": "MethodDeclaration",
      "signature": "_getBlockTag(blockTag?: BlockTag): string | Promise<string> {\n        if (blockTag == null) { return \"latest\"; }\n\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            ca",
      "doc": "Returns or resolves to a valid block tag for %%blockTag%%, resolving\nnegative values and returning if already a valid block tag.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getFilter",
      "kind": "MethodDeclaration",
      "signature": "_getFilter(filter: Filter | FilterByBlockHash): PerformActionFilter | Promise<PerformActionFilter> {\n\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || [ ]).map((t) => {\n            if (t == null) { return null; }\n            if (Array.isArray(t)) {\n",
      "doc": "Returns or resolves to a filter for %%filter%%, resolving any ENS\nnames or [[Addressable]] object and returning if already a valid\nfilter.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getTransactionRequest",
      "kind": "MethodDeclaration",
      "signature": "_getTransactionRequest(_request: TransactionRequest): PerformActionTransaction | Promise<PerformActionTransaction> {\n        const request = <PerformActionTransaction>copyRequest(_request);\n\n        const promises: Array<Promise<void>> = [ ];\n        [ \"to\", \"from\" ].forEach((key) => {\n            i",
      "doc": "Returns or resolves to a transaction for %%request%%, resolving\nany ENS names or [[Addressable]] and returning if already a valid\ntransaction.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getNetwork",
      "kind": "MethodDeclaration",
      "signature": "async getNetwork(): Promise<Network> {\n\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n            ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getFeeData",
      "kind": "MethodDeclaration",
      "signature": "async getFeeData(): Promise<FeeData> {\n        const network = await this.getNetwork();\n\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await resolveProperties({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((a",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.estimateGas",
      "kind": "MethodDeclaration",
      "signature": "async estimateGas(_tx: TransactionRequest): Promise<bigint> {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) { tx = await tx; }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#call",
      "kind": "MethodDeclaration",
      "signature": "async #call(tx: PerformActionTransaction, blockTag: string, attempt: number): Promise<string> {\n        assert (attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n             reason: \"TOO_MANY_REDIRECTS\",\n             transaction: Object.assign({ }, tx, { b",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#checkNetwork",
      "kind": "MethodDeclaration",
      "signature": "async #checkNetwork<T>(promise: Promise<T>): Promise<T> {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.call",
      "kind": "MethodDeclaration",
      "signature": "async call(_tx: TransactionRequest): Promise<string> {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getAccountValue",
      "kind": "MethodDeclaration",
      "signature": "async #getAccountValue(request: _PerformAccountRequest, _address: AddressLike, _blockTag?: BlockTag): Promise<any> {\n        let address: string | Promise<string> = this._getAddress(_address);\n        let blockTag: string | Promise<string> = this._getBlockTag(_blockTag);\n\n        if (typeof(address)",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBalance",
      "kind": "MethodDeclaration",
      "signature": "async getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint> {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionCount",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number> {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getCode",
      "kind": "MethodDeclaration",
      "signature": "async getCode(address: AddressLike, blockTag?: BlockTag): Promise<string> {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getStorage",
      "kind": "MethodDeclaration",
      "signature": "async getStorage(address: AddressLike, _position: BigNumberish, blockTag?: BlockTag): Promise<string> {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.broadcastTransaction",
      "kind": "MethodDeclaration",
      "signature": "async broadcastTransaction(signedTx: string): Promise<TransactionResponse> {\n        const { blockNumber, hash, network } = await resolveProperties({\n             blockNumber: this.getBlockNumber(),\n             hash: this._perform({\n                 method: \"broadcastTransaction\",\n                 ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getBlock",
      "kind": "MethodDeclaration",
      "signature": "async #getBlock(block: BlockTag | string, includeTransactions: boolean): Promise<any> {\n        // @TODO: Add CustomBlockPlugin check\n\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBlock",
      "kind": "MethodDeclaration",
      "signature": "async getBlock(block: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) { return nul",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransaction",
      "kind": "MethodDeclaration",
      "signature": "async getTransaction(hash: string): Promise<null | TransactionResponse> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) { return null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionReceipt",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionReceipt(hash: string): Promise<null | TransactionReceipt> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) {",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionResult",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionResult(hash: string): Promise<null | string> {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) { return null; }\n       ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getLogs",
      "kind": "MethodDeclaration",
      "signature": "async getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>> {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) { filter = await filter; }\n\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getProvider",
      "kind": "MethodDeclaration",
      "signature": "_getProvider(chainId: number): AbstractProvider {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getResolver",
      "kind": "MethodDeclaration",
      "signature": "async getResolver(name: string): Promise<null | EnsResolver> {\n        return await EnsResolver.fromName(this, name);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getAvatar",
      "kind": "MethodDeclaration",
      "signature": "async getAvatar(name: string): Promise<null | string> {\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAvatar(); }\n        return null;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.resolveName",
      "kind": "MethodDeclaration",
      "signature": "async resolveName(name: string): Promise<null | string>{\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAddress(); }\n        return null;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.lookupAddress",
      "kind": "MethodDeclaration",
      "signature": "async lookupAddress(address: string): Promise<null | string> {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n\n        try {\n\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.waitForTransaction",
      "kind": "MethodDeclaration",
      "signature": "async waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms != null) ? _confirms: 1;\n        if (confirms === 0) { return this.getTransactionReceipt(hash); }\n\n        return new Promise(async (re",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.waitForBlock",
      "kind": "MethodDeclaration",
      "signature": "async waitForBlock(blockTag?: BlockTag): Promise<Block> {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._clearTimeout",
      "kind": "MethodDeclaration",
      "signature": "_clearTimeout(timerId: number): void {\n        const timer = this.#timers.get(timerId);\n        if (!timer) { return; }\n        if (timer.timer) { clearTimeout(timer.timer); }\n        this.#timers.delete(timerId);\n    }",
      "doc": "Clear a timer created using the [[_setTimeout]] method.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._setTimeout",
      "kind": "MethodDeclaration",
      "signature": "_setTimeout(_func: () => void, timeout?: number): number {\n        if (timeout == null) { timeout = 0; }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n\n        if (this.paused) {\n            this.#tim",
      "doc": "Create a timer that will execute %%func%% after at least %%timeout%%\n(in ms). If %%timeout%% is unspecified, then %%func%% will execute\nin the next event loop.\n\n[Pausing](AbstractProvider-paused) the provider will pause any\nassociated timers.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._forEachSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_forEachSubscriber(func: (s: Subscriber) => void): void {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }",
      "doc": "Perform %%func%% on each subscriber.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new PollingBlockSubscri",
      "doc": "Sub-classes may override this to customize subscription\nimplementations.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._recoverSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) { sub.subscriber.stop(); }\n                sub.subscriber = newSub;\n                if (sub.started) { new",
      "doc": "If a [[Subscriber]] fails and needs to replace itself, this\nmethod may be used.\n\nFor example, this is used for providers when using the\n``eth_getFilterChanges`` method, which can return null if state\nfilters are not supported by the backend, allowing the Subscriber\nto swap in a [[PollingEventSubscriber]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#hasSub",
      "kind": "MethodDeclaration",
      "signature": "async #hasSub(event: ProviderEvent, emitArgs?: Array<any>): Promise<null | Sub> {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getSub",
      "kind": "MethodDeclaration",
      "signature": "async #getSub(event: ProviderEvent): Promise<Sub> {\n        const subscription = await getSubscription(event, this);\n\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n          ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.on",
      "kind": "MethodDeclaration",
      "signature": "async on(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.once",
      "kind": "MethodDeclaration",
      "signature": "async once(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.emit",
      "kind": "MethodDeclaration",
      "signature": "async emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean> {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.len",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.listenerCount",
      "kind": "MethodDeclaration",
      "signature": "async listenerCount(event?: ProviderEvent): Promise<number> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        let total = 0;\n        for (const { listeners } of this.#subs.values()",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.listeners",
      "kind": "MethodDeclaration",
      "signature": "async listeners(event?: ProviderEvent): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return  [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result: Array<Listener> = [ ];\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.off",
      "kind": "MethodDeclaration",
      "signature": "async off(event: ProviderEvent, listener?: Listener): Promise<this> {\n        const sub = await this.#hasSub(event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { su",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.removeAllListeners",
      "kind": "MethodDeclaration",
      "signature": "async removeAllListeners(event?: ProviderEvent): Promise<this> {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) { subscriber.stop(); }\n            this.#subs.delete(tag);\n        } else {\n            for (const [ tag, { start",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.addListener",
      "kind": "MethodDeclaration",
      "signature": "async addListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return await this.on(event, listener);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.removeListener",
      "kind": "MethodDeclaration",
      "signature": "async removeListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return this.off(event, listener);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.destroyed",
      "kind": "GetAccessor",
      "signature": "get destroyed(): boolean {\n        return this.#destroyed;\n    }",
      "doc": "If this provider has been destroyed using the [[destroy]] method.\n\nOnce destroyed, all resources are reclaimed, internal event loops\nand timers are cleaned up and no further requests may be sent to\nthe provider.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.destroy",
      "kind": "MethodDeclaration",
      "signature": "destroy(): void {\n        // Stop all listeners\n        this.removeAllListeners();\n\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n\n        this.#destroyed = true;\n    }",
      "doc": "Sub-classes may use this to shutdown any sockets or release their\nresources and reject any pending requests.\n\nSub-classes **must** call ``super.destroy()``.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.paused",
      "kind": "GetAccessor",
      "signature": "get paused(): boolean { return (this.#pausedState != null); }",
      "doc": "Whether the provider is currently paused.\n\nA paused provider will not emit any events, and generally should\nnot make any requests to the network, but that is up to sub-classes\nto manage.\n\nSetting ``paused = true`` is identical to calling ``.pause(false)``,\nwhich will buffer any events that occur while paused until the\nprovider is unpaused.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.pause",
      "kind": "MethodDeclaration",
      "signature": "pause(dropWhilePaused?: boolean): void {\n        this.#lastBlockNumber = -1;\n\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) { return; }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                op",
      "doc": "Pause the provider. If %%dropWhilePaused%%, any events that occur\nwhile paused are dropped, otherwise all events will be emitted once\nthe provider is unpaused.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.resume",
      "kind": "MethodDeclaration",
      "signature": "resume(): void {\n        if (this.#pausedState == null) { return; }\n\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n    ",
      "doc": "Resume the provider.",
      "tags": []
    },
    {
      "name": "EnsResolver",
      "kind": "ClassDeclaration",
      "signature": "export class EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider!: AbstractProvider;\n\n    /**\n     *  The address of the resolver.\n     */\n    address!: string;\n\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name!: string;\n\n    // For EIP-2544 names,",
      "doc": "A connected object to a resolved ENS name resolver, which can be\nused to query additional details.",
      "tags": []
    },
    {
      "name": "MulticoinProviderPlugin",
      "kind": "ClassDeclaration",
      "signature": "export abstract class MulticoinProviderPlugin implements AbstractProviderPlugin {\n    /**\n     *  The name.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name: string) {\n        defineProperties<MulticoinProviderP",
      "doc": "A provider plugin super-class for processing multicoin address types.",
      "tags": []
    },
    {
      "name": "Network",
      "kind": "ClassDeclaration",
      "signature": "export class Network {\n    #name: string;\n    #chainId: bigint;\n\n    #plugins: Map<string, NetworkPlugin>;\n\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */\n    constructor(name: string, chainId: BigNumberish) {\n        this.#name = name;\n        this.#chainId = getBig",
      "doc": "A **Network** provides access to a chain's properties and allows\nfor plug-ins to extend functionality.",
      "tags": []
    },
    {
      "name": "NonceManager",
      "kind": "ClassDeclaration",
      "signature": "export class NonceManager extends AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer!: Signer;\n\n    #noncePromise: null | Promise<number>;\n    #delta: number;\n\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer: Signer) {\n  ",
      "doc": "A **NonceManager** wraps another [[Signer]] and automatically manages\nthe nonce, ensuring serialized and sequential nonces are used during\ntransaction.",
      "tags": []
    },
    {
      "name": "NetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class NetworkPlugin {\n    /**\n     *  The name of the plugin.\n     *\n     *  It is recommended to use reverse-domain-notation, which permits\n     *  unique names with a known authority as well as hierarchal entries.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **NetworkP",
      "doc": "A **NetworkPlugin** provides additional functionality on a [[Network]].",
      "tags": []
    },
    {
      "name": "GasCostPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class GasCostPlugin extends NetworkPlugin implements GasCostParameters {\n    /**\n     *  The block number to treat these values as valid from.\n     *\n     *  This allows a hardfork to have updated values included as well as\n     *  mulutiple hardforks to be supported.\n     */\n    readonly eff",
      "doc": "A **GasCostPlugin** allows a network to provide alternative values when\ncomputing the intrinsic gas required for a transaction.",
      "tags": []
    },
    {
      "name": "EnsPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class EnsPlugin extends NetworkPlugin {\n\n    /**\n     *  The ENS Registrty Contract address.\n     */\n    readonly address!: string;\n\n    /**\n     *  The chain ID that the ENS contract lives on.\n     */\n    readonly targetNetwork!: number;\n\n    /**\n     *  Creates a new **EnsPlugin** connected",
      "doc": "An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\nContract address and the target network to use when using that\ncontract.\n\nVarious testnets have their own instance of the contract to use, but\nin general, the mainnet instance supports multi-chain addresses and\nshould be used.",
      "tags": []
    },
    {
      "name": "FeeDataNetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class FeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #feeDataFunc: (provider: Provider) => Promise<FeeData>;\n\n    /**\n     *  The fee data function provided to the constructor.\n     */\n    get feeDataFunc(): (provider: Provider) => Promise<FeeData> {\n        return this.#feeDataFun",
      "doc": "A **FeeDataNetworkPlugin** allows a network to provide and alternate\nmeans to specify its fee data.\n\nFor example, a network which does not support [[link-eip-1559]] may\nchoose to use a Gas Station site to approximate the gas price.",
      "tags": []
    },
    {
      "name": "FetchUrlFeeDataNetworkPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #url: string;\n    readonly #processFunc: (f: () => Promise<FeeData>, p: Provider, r: FetchRequest) => Promise<{ gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint }>;\n\n    /**\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "Block",
      "kind": "ClassDeclaration",
      "signature": "export class Block implements BlockParams, Iterable<string> {\n\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  ",
      "doc": "A **Block** represents the data associated with a full block on\nEthereum.",
      "tags": []
    },
    {
      "name": "FeeData",
      "kind": "ClassDeclaration",
      "signature": "export class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    readonly gasPrice!: null | bigint;\n\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of",
      "doc": "A **FeeData** wraps all the fee-related values associated with\nthe network.",
      "tags": []
    },
    {
      "name": "Log",
      "kind": "ClassDeclaration",
      "signature": "export class Log implements LogParams {\n\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransacti",
      "doc": "A **Log** in Ethereum represents an event that has been included in a\ntransaction using the ``LOG*`` opcodes, which are most commonly used by\nSolidity's emit for announcing events.",
      "tags": []
    },
    {
      "name": "TransactionReceipt",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionReceipt implements TransactionReceiptParams, Iterable<Log> {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The address the transaction was sent to.\n     */\n  ",
      "doc": "A **TransactionReceipt** includes additional information about a\ntransaction that is only available after it has been mined.",
      "tags": []
    },
    {
      "name": "TransactionResponse",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionResponse implements TransactionLike<string>, TransactionResponseParams {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The bl",
      "doc": "A **TransactionResponse** includes all properties about a transaction\nthat was sent to the network, which may or may not be included in a\nblock.\n\nThe [[TransactionResponse-isMined]] can be used to check if the\ntransaction has been mined as well as type guard that the otherwise\npossibly ``null`` properties are defined.",
      "tags": []
    },
    {
      "name": "copyRequest",
      "kind": "FunctionDeclaration",
      "signature": "export function copyRequest(req: TransactionRequest): PreparedTransactionRequest {\n    const result: any = { };\n\n    // These could be addresses, ENS names or Addressables\n    if (req.to) { result.to = req.to; }\n    if (req.from) { result.from = req.from; }\n\n    if (req.data) { result.data = hexlify",
      "doc": "Returns a copy of %%req%% with all properties coerced to their strict\ntypes.",
      "tags": []
    },
    {
      "name": "copyRequest.type",
      "kind": "PropertySignature",
      "signature": "type?: number;",
      "doc": "The transaction type.",
      "tags": []
    },
    {
      "name": "copyRequest.to",
      "kind": "PropertySignature",
      "signature": "to?: AddressLike;",
      "doc": "The target of the transaction.",
      "tags": []
    },
    {
      "name": "copyRequest.from",
      "kind": "PropertySignature",
      "signature": "from?: AddressLike;",
      "doc": "The sender of the transaction.",
      "tags": []
    },
    {
      "name": "copyRequest.nonce",
      "kind": "PropertySignature",
      "signature": "nonce?: number;",
      "doc": "The nonce of the transaction, used to prevent replay attacks.",
      "tags": []
    },
    {
      "name": "copyRequest.gasLimit",
      "kind": "PropertySignature",
      "signature": "gasLimit?: bigint;",
      "doc": "The maximum amount of gas to allow this transaction to consume.",
      "tags": []
    },
    {
      "name": "copyRequest.gasPrice",
      "kind": "PropertySignature",
      "signature": "gasPrice?: bigint;",
      "doc": "The gas price to use for legacy transactions or transactions on\nlegacy networks.\n\nMost of the time the ``max*FeePerGas`` is preferred.",
      "tags": []
    },
    {
      "name": "copyRequest.maxPriorityFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxPriorityFeePerGas?: bigint;",
      "doc": "The [[link-eip-1559]] maximum priority fee to pay per gas.",
      "tags": []
    },
    {
      "name": "copyRequest.maxFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxFeePerGas?: bigint;",
      "doc": "The [[link-eip-1559]] maximum total fee to pay per gas. The actual\nvalue used is protocol enforced to be the block's base fee.",
      "tags": []
    },
    {
      "name": "copyRequest.data",
      "kind": "PropertySignature",
      "signature": "data?: string;",
      "doc": "The transaction data.",
      "tags": []
    },
    {
      "name": "copyRequest.value",
      "kind": "PropertySignature",
      "signature": "value?: bigint;",
      "doc": "The transaction value (in wei).",
      "tags": []
    },
    {
      "name": "copyRequest.chainId",
      "kind": "PropertySignature",
      "signature": "chainId?: bigint;",
      "doc": "The chain ID for the network this transaction is valid on.",
      "tags": []
    },
    {
      "name": "copyRequest.accessList",
      "kind": "PropertySignature",
      "signature": "accessList?: AccessList;",
      "doc": "The [[link-eip-2930]] access list. Storage slots included in the access\nlist are //warmed// by pre-loading them, so their initial cost to\nfetch is guaranteed, but then each additional access is cheaper.",
      "tags": []
    },
    {
      "name": "copyRequest.authorizationList",
      "kind": "PropertySignature",
      "signature": "authorizationList?: Array<Authorization>;",
      "doc": "The [[link-eip-7702]] authorizations (if any).",
      "tags": []
    },
    {
      "name": "copyRequest.customData",
      "kind": "PropertySignature",
      "signature": "customData?: any;",
      "doc": "A custom object, which can be passed along for network-specific\nvalues.",
      "tags": []
    },
    {
      "name": "copyRequest.blockTag",
      "kind": "PropertySignature",
      "signature": "blockTag?: BlockTag;",
      "doc": "When using ``call`` or ``estimateGas``, this allows a specific\nblock to be queried. Many backends do not support this and when\nunsupported errors are silently squelched and ``\"latest\"`` is used.",
      "tags": []
    },
    {
      "name": "copyRequest.enableCcipRead",
      "kind": "PropertySignature",
      "signature": "enableCcipRead?: boolean;",
      "doc": "When using ``call``, this enables CCIP-read, which permits the\nprovider to be redirected to web-based content during execution,\nwhich is then further validated by the contract.\n\nThere are potential security implications allowing CCIP-read, as\nit could be used to expose the IP address or user activity during\nthe fetch to unexpected parties.",
      "tags": []
    },
    {
      "name": "FallbackProvider",
      "kind": "ClassDeclaration",
      "signature": "export class FallbackProvider extends AbstractProvider {\n\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    readonly quorum: number;\n\n    /**\n     *  @_ignore:\n     */\n    readonly eventQuorum: number;\n\n    /**\n     *  @_ignore:\n     */\n    ",
      "doc": "A **FallbackProvider** manages several [[Providers]] providing\nresilience by switching between slow or misbehaving nodes, security\nby requiring multiple backends to aggree and performance by allowing\nfaster backends to respond earlier.",
      "tags": []
    },
    {
      "name": "JsonRpcApiProvider",
      "kind": "ClassDeclaration",
      "signature": "export abstract class JsonRpcApiProvider extends AbstractProvider {\n\n    #options: Required<JsonRpcApiProviderOptions>;\n\n    // The next ID to use for the JSON-RPC ID field\n    #nextId: number;\n\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads: Array<Payload>;\n ",
      "doc": "The JsonRpcApiProvider is an abstract class and **MUST** be\nsub-classed.\n\nIt provides the base for all JSON-RPC-based Provider interaction.\n\nSub-classing Notes:\n- a sub-class MUST override _send\n- a sub-class MUST call the `_start()` method once connected",
      "tags": []
    },
    {
      "name": "JsonRpcProvider",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect: FetchRequest;\n\n    constructor(url?: string | FetchRequest, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        if (url == null) { url = \"http:/\\/localhost:8545\"; }\n        super(network, options);\n\n     ",
      "doc": "The JsonRpcProvider is one of the most common Providers,\nwhich performs all operations over HTTP (or HTTPS) requests.\n\nEvents are processed by polling the backend for the current block\nnumber; when it advances, all block-base events are then checked\nfor updates.",
      "tags": []
    },
    {
      "name": "JsonRpcSigner",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcSigner extends AbstractSigner<JsonRpcApiProvider> {\n    address!: string;\n\n    constructor(provider: JsonRpcApiProvider, address: string) {\n        super(provider);\n        address = getAddress(address);\n        defineProperties<JsonRpcSigner>(this, { address });\n    }\n\n    conne",
      "doc": "",
      "tags": []
    },
    {
      "name": "BrowserProvider",
      "kind": "ClassDeclaration",
      "signature": "export class BrowserProvider extends JsonRpcApiPollingProvider {\n    #request: (method: string, params: Array<any> | Record<string, any>) => Promise<any>;\n\n    #providerInfo: null | Eip6963ProviderInfo;\n\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%",
      "doc": "A **BrowserProvider** is intended to wrap an injected provider which\nadheres to the [[link-eip-1193]] standard, which most (if not all)\ncurrently do.",
      "tags": []
    },
    {
      "name": "AlchemyProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AlchemyProvider extends JsonRpcProvider implements CommunityResourcable {\n    readonly apiKey!: string;\n\n    constructor(_network?: Networkish, apiKey?: null | string) {\n        if (_network == null) { _network = \"mainnet\"; }\n        const network = Network.from(_network);\n        if (a",
      "doc": "The **AlchemyProvider** connects to the [[link-alchemy]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-alchemy-signup).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty"
        }
      ]
    },
    {
      "name": "BlockscoutProvider",
      "kind": "ClassDeclaration",
      "signature": "export class BlockscoutProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API key.\n     */\n    readonly apiKey!: null | string;\n\n    /**\n     *  Creates a new **BlockscoutProvider**.\n     */\n    constructor(_network?: Networkish, apiKey?: null | string) {\n        ",
      "doc": "The **BlockscoutProvider** connects to the [[link-blockscout]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-blockscout).",
      "tags": []
    },
    {
      "name": "AnkrProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AnkrProvider extends JsonRpcProvider implements CommunityResourcable {\n\n    /**\n     *  The API key for the Ankr connection.\n     */\n    readonly apiKey!: string;\n\n    /**\n     *  Create a new **AnkrProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n",
      "doc": "The **AnkrProvider** connects to the [[link-ankr]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-ankr-signup).",
      "tags": []
    },
    {
      "name": "CloudflareProvider",
      "kind": "ClassDeclaration",
      "signature": "export class CloudflareProvider extends JsonRpcProvider {\n    constructor(_network?: Networkish) {\n        if (_network == null) { _network = \"mainnet\"; }\n        const network = Network.from(_network);\n        assertArgument(network.name === \"mainnet\", \"unsupported network\", \"network\", _network);\n ",
      "doc": "About Cloudflare...",
      "tags": []
    },
    {
      "name": "ChainstackProvider",
      "kind": "ClassDeclaration",
      "signature": "export class ChainstackProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API key for the Chainstack connection.\n     */\n    readonly apiKey!: string;\n\n    /**\n     *  Creates a new **ChainstackProvider**.\n     */\n    constructor(_network?: Networkish, apiKey?: nu",
      "doc": "The **ChainstackProvider** connects to the [[link-chainstack]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-chainstack).",
      "tags": []
    },
    {
      "name": "EtherscanProvider",
      "kind": "ClassDeclaration",
      "signature": "export class EtherscanProvider extends AbstractProvider {\n\n    /**\n     *  The connected network.\n     */\n    readonly network!: Network;\n\n    /**\n     *  The API key or null if using the community provided bandwidth.\n     */\n    readonly apiKey!: null | string;\n\n    readonly #plugin: null | Ethersc",
      "doc": "The **EtherscanBaseProvider** is the super-class of\n[[EtherscanProvider]], which should generally be used instead.\n\nSince the **EtherscanProvider** includes additional code for\n[[Contract]] access, in //rare cases// that contracts are not\nused, this class can reduce code size.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "EtherscanPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class EtherscanPlugin extends NetworkPlugin {\n    /**\n     *  The Etherscan API base URL.\n     */\n    readonly baseUrl!: string;\n\n    /**\n     *  Creates a new **EtherscanProvider** which will use\n     *  %%baseUrl%%.\n     */\n    constructor(baseUrl: string) {\n        super(EtherscanPluginId)",
      "doc": "A Network can include an **EtherscanPlugin** to provide\na custom base URL.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/providers/thirdparty:Etherscan"
        }
      ]
    },
    {
      "name": "InfuraProvider",
      "kind": "ClassDeclaration",
      "signature": "export class InfuraProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    readonly projectId!: string;\n\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This should not\n  ",
      "doc": "The **InfuraProvider** connects to the [[link-infura]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-infura-signup).",
      "tags": []
    },
    {
      "name": "InfuraWebSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    readonly projectId!: string;\n\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This s",
      "doc": "The **InfuraWebSocketProvider** connects to the [[link-infura]]\nWebSocket end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-infura-signup).",
      "tags": []
    },
    {
      "name": "PocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class PocketProvider extends JsonRpcProvider implements CommunityResourcable {\n\n    /**\n     *  The Application ID for the Pocket connection.\n     */\n    readonly applicationId!: string;\n\n    /**\n     *  The Application Secret for making authenticated requests\n     *  to the Pocket connection",
      "doc": "The **PocketProvider** connects to the [[link-pocket]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API key is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-pocket-signup).",
      "tags": []
    },
    {
      "name": "QuickNodeProvider",
      "kind": "ClassDeclaration",
      "signature": "export class QuickNodeProvider extends JsonRpcProvider implements CommunityResourcable {\n    /**\n     *  The API token.\n     */\n    readonly token!: string;\n\n    /**\n     *  Creates a new **QuickNodeProvider**.\n     */\n    constructor(_network?: Networkish, token?: null | string) {\n        if (_netw",
      "doc": "The **QuickNodeProvider** connects to the [[link-quicknode]]\nJSON-RPC end-points.\n\nBy default, a highly-throttled API token is used, which is\nappropriate for quick prototypes and simple scripts. To\ngain access to an increased rate-limit, it is highly\nrecommended to [sign up here](link-quicknode).",
      "tags": []
    },
    {
      "name": "IpcSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class IpcSocketProvider extends SocketProvider {\n    #socket: Socket;\n\n    /**\n     *  The connected socket.\n     */\n    get socket(): Socket { return this.#socket; }\n\n    constructor(path: string, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n ",
      "doc": "An **IpcSocketProvider** connects over an IPC socket on the host\nwhich provides fast access to the node, but requires the node and\nthe script run on the same machine.",
      "tags": []
    },
    {
      "name": "SocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class SocketProvider extends JsonRpcApiProvider {\n    #callbacks: Map<number, { payload: JsonRpcPayload, resolve: (r: any) => void, reject: (e: Error) => void }>;\n\n    // Maps each filterId to its subscriber\n    #subs: Map<number | string, SocketSubscriber>;\n\n    // If any events come in befo",
      "doc": "A **SocketProvider** is backed by a long-lived connection over a\nsocket, which can subscribe and receive real-time messages over\nits communication channel.",
      "tags": []
    },
    {
      "name": "WebSocketProvider",
      "kind": "ClassDeclaration",
      "signature": "export class WebSocketProvider extends SocketProvider {\n    #connect: null | WebSocketCreator;\n\n    #websocket: null | WebSocketLike;\n    get websocket(): WebSocketLike {\n        if (this.#websocket == null) { throw new Error(\"websocket closed\"); }\n        return this.#websocket;\n    }\n\n    construc",
      "doc": "A JSON-RPC provider which is backed by a WebSocket.\n\nWebSockets are often preferred because they retain a live connection\nto a server, which permits more instant access to events.\n\nHowever, this incurs higher server infrasturture costs, so additional\nresources may be required to host your own WebSocket nodes and many\nthird-party services charge additional fees for WebSocket endpoints.",
      "tags": []
    },
    {
      "name": "SocketSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketSubscriber implements Subscriber {\n    #provider: SocketProvider;\n\n    #filter: string;\n\n    /**\n     *  The filter.\n     */\n    get filter(): Array<any> { return JSON.parse(this.#filter); }\n\n    #filterId: null | Promise<string |number>;\n    #paused: null | boolean;\n\n    #emitPro",
      "doc": "A **SocketSubscriber** uses a socket transport to handle events and\nshould use [[_emit]] to manage the events.",
      "tags": []
    },
    {
      "name": "SocketBlockSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newHeads\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"block\", parseInt",
      "doc": "A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n``\"block\"`` events.",
      "tags": []
    },
    {
      "name": "SocketPendingSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketPendingSubscriber extends SocketSubscriber {\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newPendingTransactions\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(",
      "doc": "A **SocketPendingSubscriber** listens for pending transacitons and emits\n``\"pending\"`` events.",
      "tags": []
    },
    {
      "name": "SocketEventSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class SocketEventSubscriber extends SocketSubscriber {\n    #logFilter: string;\n\n    /**\n     *  The filter.\n     */\n    get logFilter(): EventFilter { return JSON.parse(this.#logFilter); }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider, filter: EventFilter) {\n    ",
      "doc": "A **SocketEventSubscriber** listens for event logs.",
      "tags": []
    },
    {
      "name": "AbstractProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AbstractProviderOptions = {\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};",
      "doc": "Options for configuring some internal aspects of an [[AbstractProvider]].\n\n**``cacheTimeout``** - how long to cache a low-level ``_perform``\nfor, based on input parameters. This reduces the number of calls\nto getChainId and getBlockNumber, but may break test chains which\ncan perform operations (internally) synchronously. Use ``-1`` to\ndisable, ``0`` will only buffer within the same event loop and\nany other value is in ms. (default: ``250``)",
      "tags": []
    },
    {
      "name": "Subscription",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Subscription = {\n    type: \"block\" | \"close\" | \"debug\" | \"error\" | \"finalized\" | \"network\" | \"pending\" | \"safe\",\n    tag: string\n} | {\n    type: \"transaction\",\n    tag: string,\n    hash: string\n} | {\n    type: \"event\",\n    tag: string,\n    filter: EventFilter\n} | {\n    type: \"orphan\",\n  ",
      "doc": "The value passed to the [[AbstractProvider-_getSubscriber]] method.\n\nOnly developers sub-classing [[AbstractProvider[[ will care about this,\nif they are modifying a low-level feature of how subscriptions operate.",
      "tags": []
    },
    {
      "name": "Subscriber",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Subscriber {\n    /**\n     *  Called initially when a subscriber is added the first time.\n     */\n    start(): void;\n\n    /**\n     *  Called when there are no more subscribers to the event.\n     */\n    stop(): void;\n\n    /**\n     *  Called when the subscription should pause.\n     *\n ",
      "doc": "A **Subscriber** manages a subscription.\n\nOnly developers sub-classing [[AbstractProvider[[ will care about this,\nif they are modifying a low-level feature of how subscriptions operate.",
      "tags": []
    },
    {
      "name": "AbstractProviderPlugin",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AbstractProviderPlugin {\n    /**\n     *  The reverse domain notation of the plugin.\n     */\n    readonly name: string;\n\n    /**\n     *  Creates a new instance of the plugin, connected to %%provider%%.\n     */\n    connect(provider: AbstractProvider): AbstractProviderPlugin;\n}",
      "doc": "An **AbstractPlugin** is used to provide additional internal services\nto an [[AbstractProvider]] without adding backwards-incompatible changes\nto method signatures or other internal and complex logic.",
      "tags": []
    },
    {
      "name": "PerformActionFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PerformActionFilter = {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n} | {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    blockHash?: string;\n};",
      "doc": "A normalized filter used for [[PerformActionRequest]] objects.",
      "tags": []
    },
    {
      "name": "PerformActionTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PerformActionTransaction extends PreparedTransactionRequest {\n    /**\n     *  The ``to`` address of the transaction.\n     */\n    to?: string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: string;\n}",
      "doc": "A normalized transactions used for [[PerformActionRequest]] objects.",
      "tags": []
    },
    {
      "name": "PerformActionRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PerformActionRequest = {\n    method: \"broadcastTransaction\",\n    signedTransaction: string\n} | {\n    method: \"call\",\n    transaction: PerformActionTransaction, blockTag: BlockTag\n} | {\n    method: \"chainId\"\n} | {\n    method: \"estimateGas\",\n    transaction: PerformActionTransaction\n} | {\n",
      "doc": "The [[AbstractProvider]] methods will normalize all values and pass this\ntype to [[AbstractProvider-_perform]].",
      "tags": []
    },
    {
      "name": "ContractRunner",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractRunner {\n    /**\n     *  The provider used for necessary state querying operations.\n     *\n     *  This can also point to the **ContractRunner** itself, in the\n     *  case of an [[AbstractProvider]].\n     */\n    provider: null | Provider;\n\n    /**\n     *  Required to estima",
      "doc": "A **ContractRunner** is a generic interface which defines an object\ncapable of interacting with a Contract on the network.\n\nThe more operations supported, the more utility it is capable of.\n\nThe most common ContractRunners are [Providers](Provider) which enable\nread-only access and [Signers](Signer) which enable write-access.",
      "tags": []
    },
    {
      "name": "BlockParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BlockParams {\n    /**\n     *  The block hash.\n     */\n    hash?: null | string;\n\n    /**\n     *  The block number.\n     */\n    number: number;\n\n    /**\n     *  The timestamp for this block, which is the number of seconds\n     *  since epoch that this block was included.\n     */\n    ",
      "doc": "a **BlockParams** encodes the minimal required properties for a\nformatted block.",
      "tags": []
    },
    {
      "name": "LogParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LogParams {\n    /**\n     *  The transaction hash for the transaxction the log occurred in.\n     */\n    transactionHash: string;\n\n    /**\n     *  The block hash of the block that included the transaction for this\n     *  log.\n     */\n    blockHash: string;\n\n    /**\n     *  The block ",
      "doc": "a **LogParams** encodes the minimal required properties for a\nformatted log.",
      "tags": []
    },
    {
      "name": "TransactionReceiptParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionReceiptParams {\n    /**\n     *  The target of the transaction. If null, the transaction was trying\n     *  to deploy a transaction with the ``data`` as the initi=code.\n     */\n    to: null | string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from: string;",
      "doc": "a **TransactionReceiptParams** encodes the minimal required properties\nfor a formatted transaction receipt.",
      "tags": []
    },
    {
      "name": "TransactionResponseParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionResponseParams {\n    /**\n     *  The block number of the block that included this transaction.\n     */\n    blockNumber: null | number;\n\n    /**\n     *  The block hash of the block that included this transaction.\n     */\n    blockHash: null | string;\n\n    /**\n     *  The t",
      "doc": "a **TransactionResponseParams** encodes the minimal required properties\nfor a formatted transaction response.",
      "tags": []
    },
    {
      "name": "CommunityResourcable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CommunityResourcable {\n    /**\n     *  Returns true if the instance is connected using the community\n     *  credentials.\n     */\n    isCommunityResource(): boolean;\n}",
      "doc": "There are many awesome community services that provide Ethereum\nnodes both for developers just starting out and for large-scale\ncommunities.\nProviders which offer community credentials should extend this\nto notify any interested consumers whether community credentials\nare in-use.",
      "tags": [
        {
          "tagName": "_section",
          "text": ": api/providers/thirdparty: Community Providers  [thirdparty]"
        }
      ]
    },
    {
      "name": "Networkish",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Networkish = Network | number | bigint | string | {\n    name?: string,\n    chainId?: number,\n    //layerOneConnection?: Provider,\n    ensAddress?: string,\n    ensNetwork?: number\n};",
      "doc": "A Networkish can be used to allude to a Network, by specifing:\n- a [[Network]] object\n- a well-known (or registered) network name\n- a well-known (or registered) chain ID\n- an object with sufficient details to describe a network",
      "tags": []
    },
    {
      "name": "GasCostParameters",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GasCostParameters = {\n    /**\n     *  The transactions base fee.\n     */\n    txBase?: number;\n\n    /**\n     *  The fee for creating a new account.\n     */\n    txCreate?: number;\n\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    txDataZero?: number;\n\n    /**\n     *  The fee ",
      "doc": "The gas cost parameters for a [[GasCostPlugin]].",
      "tags": []
    },
    {
      "name": "BlockTag",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BlockTag = BigNumberish | string;",
      "doc": "A **BlockTag** specifies a specific block.\n\n**numeric value** - specifies the block height, where\nthe genesis block is block 0; many operations accept a negative\nvalue which indicates the block number should be deducted from\nthe most recent block. A numeric value may be a ``number``, ``bigint``,\nor a decimal of hex string.\n\n**blockhash** - specifies a specific block by its blockhash; this allows\npotentially orphaned blocks to be specifed, without ambiguity, but many\nbackends do not support this for some operations.",
      "tags": []
    },
    {
      "name": "TransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: null | number;\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: null | AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: null | AddressLike;\n\n    /**\n     *  T",
      "doc": "A **TransactionRequest** is a transactions with potentially various\nproperties not defined, or with less strict types for its values.\n\nThis is used to pass to various operations, which will internally\ncoerce any types and populate any necessary values.",
      "tags": []
    },
    {
      "name": "PreparedTransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PreparedTransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: number;\n\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: AddressLike;\n\n    /**\n     *  The nonce of ",
      "doc": "A **PreparedTransactionRequest** is identical to a [[TransactionRequest]]\nexcept all the property types are strictly enforced.",
      "tags": []
    },
    {
      "name": "EventFilter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EventFilter {\n    address?: AddressLike | Array<AddressLike>;\n    topics?: TopicFilter;\n}",
      "doc": "An **EventFilter** allows efficiently filtering logs (also known as\nevents) using bloom filters included within blocks.",
      "tags": []
    },
    {
      "name": "Filter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Filter extends EventFilter {\n\n    /**\n     *  The start block for the filter (inclusive).\n     */\n    fromBlock?: BlockTag;\n\n    /**\n     *  The end block for the filter (inclusive).\n     */\n    toBlock?: BlockTag;\n}",
      "doc": "A **Filter** allows searching a specific range of blocks for mathcing\nlogs.",
      "tags": []
    },
    {
      "name": "FilterByBlockHash",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FilterByBlockHash extends EventFilter {\n    /**\n     *  The blockhash of the specific block for the filter.\n     */\n    blockHash?: string;\n}",
      "doc": "A **FilterByBlockHash** allows searching a specific block for mathcing\nlogs.",
      "tags": []
    },
    {
      "name": "OrphanFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OrphanFilter = {\n    orphan: \"drop-block\",\n    hash: string,\n    number: number\n} | {\n    orphan: \"drop-transaction\",\n    tx: { hash: string, blockHash: string, blockNumber: number },\n    other?: { hash: string, blockHash: string, blockNumber: number }\n} | {\n    orphan: \"reorder-transact",
      "doc": "An Orphan Filter allows detecting when an orphan block has\nresulted in dropping a block or transaction or has resulted\nin transactions changing order.\n\nNot currently fully supported.",
      "tags": []
    },
    {
      "name": "ProviderEvent",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProviderEvent = string | Array<string | Array<string>> | EventFilter | OrphanFilter;",
      "doc": "A **ProviderEvent** provides the types of events that can be subscribed\nto on a [[Provider]].\n\nEach provider may include additional possible events it supports, but\nthe most commonly supported are:\n\n**``\"block\"``** - calls the listener with the current block number on each\nnew block.\n\n**``\"error\"``** - calls the listener on each async error that occurs during\nthe event loop, with the error.\n\n**``\"debug\"``** - calls the listener on debug events, which can be used to\ntroubleshoot network errors, provider problems, etc.\n\n**``transaction hash``** - calls the listener on each block after the\ntransaction has been mined; generally ``.once`` is more appropriate for\nthis event.\n\n**``Array``** - calls the listener on each log that matches the filter.\n\n[[EventFilter]] - calls the listener with each matching log",
      "tags": []
    },
    {
      "name": "TopicFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type TopicFilter = Array<null | string | Array<string>>;",
      "doc": "A **TopicFilter** provides a struture to define bloom-filter\nqueries.\n\nEach field that is ``null`` matches **any** value, a field that is\na ``string`` must match exactly that value and ``array`` is\neffectively an ``OR``-ed set, where any one of those values must\nmatch.",
      "tags": []
    },
    {
      "name": "Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Provider extends ContractRunner, EventEmitterable<ProviderEvent>, NameResolver {\n\n    /**\n     *  The provider iteself.\n     *\n     *  This is part of the necessary API for executing a contract, as\n     *  it provides a common property on any [[ContractRunner]] that\n     *  can be u",
      "doc": "A **Provider** is the primary method to interact with the read-only\ncontent on Ethereum.\n\nIt allows access to details about accounts, blocks and transactions\nand the ability to query event logs and simulate contract execution.\n\nAccount data includes the [balance](getBalance),\n[transaction count](getTransactionCount), [code](getCode) and\n[state trie storage](getStorage).\n\nSimulating execution can be used to [call](call),\n[estimate gas](estimateGas) and\n[get transaction results](getTransactionResult).\n\nThe [[broadcastTransaction]] is the only method which allows updating\nthe blockchain, but it is usually accessed by a [[Signer]], since a\nprivate key must be used to sign the transaction before it can be\nbroadcast.",
      "tags": []
    },
    {
      "name": "MinedBlock",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinedBlock extends Block {\n    /**\n     *  The block number also known as the block height.\n     */\n    readonly number: number;\n\n    /**\n     *  The block hash.\n     */\n    readonly hash: string;\n\n    /**\n     *  The block timestamp, in seconds from epoch.\n     */\n    readonly time",
      "doc": "An Interface to indicate a [[Block]] has been included in the\nblockchain. This asserts a Type Guard that necessary properties\nare non-null.\n\nBefore a block is included, it is a //pending// block.",
      "tags": []
    },
    {
      "name": "MinedTransactionResponse",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinedTransactionResponse extends TransactionResponse {\n    /**\n     *  The block number this transaction occurred in.\n     */\n    blockNumber: number;\n\n    /**\n     *  The block hash this transaction occurred in.\n     */\n    blockHash: string;\n\n    /**\n     *  The date this transact",
      "doc": "A **MinedTransactionResponse** is an interface representing a\ntransaction which has been mined and allows for a type guard for its\nproperty values being defined.",
      "tags": []
    },
    {
      "name": "BrowserDiscoverOptions",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BrowserDiscoverOptions {\n    /**\n     *  Override provider detection with this provider.\n     */\n    provider?: Eip1193Provider;\n\n    /**\n     *  Duration to wait to detect providers. (default: 300ms)\n     */\n    timeout?: number;\n\n    /**\n     *  Return the first detected provider.",
      "doc": "Specifies how [[link-eip-6963]] discovery should proceed.\n\nSee: [[BrowserProvider-discover]]",
      "tags": []
    },
    {
      "name": "BrowserProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type BrowserProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n\n    providerInfo?: Eip6963ProviderInfo;\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "DebugEventBrowserProvider",
      "kind": "TypeAliasDeclaration",
      "signature": "export type DebugEventBrowserProvider = {\n    action: \"sendEip1193Payload\",\n    payload: { method: string, params: Array<any> }\n} | {\n    action: \"receiveEip1193Result\",\n    result: any\n} | {\n    action: \"receiveEip1193Error\",\n    error: Error\n};",
      "doc": "The possible additional events dispatched when using the ``\"debug\"``\nevent on a [[BrowserProvider]].",
      "tags": []
    },
    {
      "name": "Eip1193Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Eip1193Provider {\n    /**\n     *  See [[link-eip-1193]] for details on this method.\n     */\n    request(request: { method: string, params?: Array<any> | Record<string, any> }): Promise<any>;\n}",
      "doc": "The interface to an [[link-eip-1193]] provider, which is a standard\nused by most injected providers, which the [[BrowserProvider]] accepts\nand exposes the API of.",
      "tags": []
    },
    {
      "name": "Eip6963ProviderInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Eip6963ProviderInfo {\n    uuid: string;\n    name: string;\n    icon: string;\n    rdns: string;\n}",
      "doc": "Provider info provided by the [[link-eip-6963]] discovery mechanism.",
      "tags": []
    },
    {
      "name": "FallbackProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FallbackProviderOptions = {\n    // How many providers must agree on a value before reporting\n    // back the response\n    quorum?: number;\n\n    // How many providers must have reported the same event\n    // for it to be emitted (currently unimplmented)\n    eventQuorum?: number;\n\n    // H",
      "doc": "Additional options to configure a [[FallbackProvider]].",
      "tags": []
    },
    {
      "name": "JsonRpcPayload",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcPayload = {\n    /**\n     *  The JSON-RPC request ID.\n     */\n    id: number;\n\n    /**\n     *  The JSON-RPC request method.\n     */\n    method: string;\n\n    /**\n     *  The JSON-RPC request parameters.\n     */\n    params: Array<any> | Record<string, any>;\n\n    /**\n     *  A require",
      "doc": "A JSON-RPC payload, which are sent to a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcResult",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcResult = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response result.\n     */\n    result: any;\n};",
      "doc": "A JSON-RPC result, which are returned on success from a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcError",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcError = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response error.\n     */\n    error: {\n        code: number;\n        message?: string;\n        data?: any;\n    }\n};",
      "doc": "A JSON-RPC error, which are returned on failure from a JSON-RPC server.",
      "tags": []
    },
    {
      "name": "JsonRpcApiProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcApiProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n    batchStallTime?: number;\n    batchMaxSize?: number;\n    batchMaxCount?: number;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};",
      "doc": "Options for configuring a [[JsonRpcApiProvider]]. Much of this\nis targetted towards sub-classes, which often will not expose\nany of these options to their consumers.\n\n**``polling``** - use the polling strategy is used immediately\nfor events; otherwise, attempt to use filters and fall back onto\npolling (default: ``false``)\n\n**``staticNetwork``** - do not request chain ID on requests to\nvalidate the underlying chain has not changed (default: ``null``)\n\nThis should **ONLY** be used if it is **certain** that the network\ncannot change, such as when using INFURA (since the URL dictates the\nnetwork). If the network is assumed static and it does change, this\ncan have tragic consequences. For example, this **CANNOT** be used\nwith MetaMask, since the user can select a new network from the\ndrop-down at any time.\n\n**``batchStallTime``** - how long (ms) to aggregate requests into a\nsingle batch. ``0`` indicates batching will only encompass the current\nevent loop. If ``batchMaxCount = 1``, this is ignored. (default: ``10``)\n\n**``batchMaxSize``** - target maximum size (bytes) to allow per batch\nrequest (default: 1Mb)\n\n**``batchMaxCount``** - maximum number of requests to allow in a batch.\nIf ``batchMaxCount = 1``, then batching is disabled. (default: ``100``)\n\n**``cacheTimeout``** - passed as [[AbstractProviderOptions]].",
      "tags": []
    },
    {
      "name": "JsonRpcTransactionRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcTransactionRequest {\n     /**\n      *  The sender address to use when signing.\n      */\n     from?: string;\n\n     /**\n      *  The target address.\n      */\n     to?: string;\n\n     /**\n      *  The transaction data.\n      */\n     data?: string;\n\n     /**\n      *  The chain ID ",
      "doc": "A **JsonRpcTransactionRequest** is formatted as needed by the JSON-RPC\nEthereum API specification.",
      "tags": []
    },
    {
      "name": "WebSocketCreator",
      "kind": "TypeAliasDeclaration",
      "signature": "export type WebSocketCreator = () => WebSocketLike;",
      "doc": "A function which can be used to re-create a WebSocket connection\non disconnect.",
      "tags": []
    },
    {
      "name": "WebSocketLike",
      "kind": "InterfaceDeclaration",
      "signature": "export interface WebSocketLike {\n    onopen: null | ((...args: Array<any>) => any);\n    onmessage: null | ((...args: Array<any>) => any);\n    onerror: null | ((...args: Array<any>) => any);\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}",
      "doc": "A generic interface to a Websocket-like object.",
      "tags": []
    },
    {
      "name": "Signer",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Signer extends Addressable, ContractRunner, NameResolver {\n\n    /**\n     *  The [[Provider]] attached to this Signer (if any).\n     */\n    provider: null | Provider;\n\n    /**\n     *  Returns a new instance of this Signer connected to //provider// or detached\n     *  from any Provide",
      "doc": "A Signer represents an account on the Ethereum Blockchain, and is most often\nbacked by a private key represented by a mnemonic or residing on a Hardware Wallet.\n\nThe API remains abstract though, so that it can deal with more advanced exotic\nSigning entities, such as Smart Contract Wallets or Virtual Wallets (where the\nprivate key may not be known).",
      "tags": []
    },
    {
      "name": "BlockParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BlockParams {\n    /**\n     *  The block hash.\n     */\n    hash?: null | string;\n\n    /**\n     *  The block number.\n     */\n    number: number;\n\n    /**\n     *  The timestamp for this block, which is the number of seconds\n     *  since epoch that this block was included.\n     */\n    ",
      "doc": "a **BlockParams** encodes the minimal required properties for a\nformatted block.",
      "tags": []
    },
    {
      "name": "LogParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LogParams {\n    /**\n     *  The transaction hash for the transaxction the log occurred in.\n     */\n    transactionHash: string;\n\n    /**\n     *  The block hash of the block that included the transaction for this\n     *  log.\n     */\n    blockHash: string;\n\n    /**\n     *  The block ",
      "doc": "a **LogParams** encodes the minimal required properties for a\nformatted log.",
      "tags": []
    },
    {
      "name": "TransactionReceiptParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionReceiptParams {\n    /**\n     *  The target of the transaction. If null, the transaction was trying\n     *  to deploy a transaction with the ``data`` as the initi=code.\n     */\n    to: null | string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from: string;",
      "doc": "a **TransactionReceiptParams** encodes the minimal required properties\nfor a formatted transaction receipt.",
      "tags": []
    },
    {
      "name": "TransactionResponseParams",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransactionResponseParams {\n    /**\n     *  The block number of the block that included this transaction.\n     */\n    blockNumber: null | number;\n\n    /**\n     *  The block hash of the block that included this transaction.\n     */\n    blockHash: null | string;\n\n    /**\n     *  The t",
      "doc": "a **TransactionResponseParams** encodes the minimal required properties\nfor a formatted transaction response.",
      "tags": []
    },
    {
      "name": "allowNull",
      "kind": "FunctionDeclaration",
      "signature": "export function allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n    return (function(value: any) {\n        if (value == null) { return nullValue; }\n        return format(value);\n    });\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "arrayOf",
      "kind": "FunctionDeclaration",
      "signature": "export function arrayOf(format: FormatFunc, allowNull?: boolean): FormatFunc {\n    return ((array: any) => {\n        if (allowNull && array == null) { return null; }\n        if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n        return array.map((i) => format(i));\n    });\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "object",
      "kind": "FunctionDeclaration",
      "signature": "export function object(format: Record<string, FormatFunc>, altNames?: Record<string, Array<string>>): FormatFunc {\n    return ((value: any) => {\n        const result: any = { };\n        for (const key in format) {\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey ",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatBoolean",
      "kind": "FunctionDeclaration",
      "signature": "export function formatBoolean(value: any): boolean {\n    switch (value) {\n        case true: case \"true\":\n            return true;\n        case false: case \"false\":\n            return false;\n    }\n    assertArgument(false, `invalid boolean; ${ JSON.stringify(value) }`, \"value\", value);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatData",
      "kind": "FunctionDeclaration",
      "signature": "export function formatData(value: string): string {\n    assertArgument(isHexString(value, true), \"invalid data\", \"value\", value);\n    return value;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatHash",
      "kind": "FunctionDeclaration",
      "signature": "export function formatHash(value: any): string {\n    assertArgument(isHexString(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatUint256",
      "kind": "FunctionDeclaration",
      "signature": "export function formatUint256(value: any): string {\n    if (!isHexString(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return zeroPadValue(value, 32);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatLog",
      "kind": "FunctionDeclaration",
      "signature": "export function formatLog(value: any): LogParams {\n    return _formatLog(value);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatLog.transactionHash",
      "kind": "PropertySignature",
      "signature": "transactionHash: string;",
      "doc": "The transaction hash for the transaxction the log occurred in.",
      "tags": []
    },
    {
      "name": "formatLog.blockHash",
      "kind": "PropertySignature",
      "signature": "blockHash: string;",
      "doc": "The block hash of the block that included the transaction for this\nlog.",
      "tags": []
    },
    {
      "name": "formatLog.blockNumber",
      "kind": "PropertySignature",
      "signature": "blockNumber: number;",
      "doc": "The block number of the block that included the transaction for this\nlog.",
      "tags": []
    },
    {
      "name": "formatLog.removed",
      "kind": "PropertySignature",
      "signature": "removed: boolean;",
      "doc": "Whether this log was removed due to the transaction it was included\nin being removed dur to an orphaned block.",
      "tags": []
    },
    {
      "name": "formatLog.address",
      "kind": "PropertySignature",
      "signature": "address: string;",
      "doc": "The address of the contract that emitted this log.",
      "tags": []
    },
    {
      "name": "formatLog.data",
      "kind": "PropertySignature",
      "signature": "data: string;",
      "doc": "The data emitted with this log.",
      "tags": []
    },
    {
      "name": "formatLog.topics",
      "kind": "PropertySignature",
      "signature": "topics: ReadonlyArray<string>;",
      "doc": "The topics emitted with this log.",
      "tags": []
    },
    {
      "name": "formatLog.index",
      "kind": "PropertySignature",
      "signature": "index: number;",
      "doc": "The index of this log.",
      "tags": []
    },
    {
      "name": "formatLog.transactionIndex",
      "kind": "PropertySignature",
      "signature": "transactionIndex: number;",
      "doc": "The transaction index of this log.",
      "tags": []
    },
    {
      "name": "formatBlock",
      "kind": "FunctionDeclaration",
      "signature": "export function formatBlock(value: any): BlockParams {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx: string | TransactionResponseParams) => {\n        if (typeof(tx) === \"string\") { return tx; }\n        return formatTransactionResponse(tx);\n    });\n    ",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatBlock.hash",
      "kind": "PropertySignature",
      "signature": "hash?: null | string;",
      "doc": "The block hash.",
      "tags": []
    },
    {
      "name": "formatBlock.number",
      "kind": "PropertySignature",
      "signature": "number: number;",
      "doc": "The block number.",
      "tags": []
    },
    {
      "name": "formatBlock.timestamp",
      "kind": "PropertySignature",
      "signature": "timestamp: number;",
      "doc": "The timestamp for this block, which is the number of seconds\nsince epoch that this block was included.",
      "tags": []
    },
    {
      "name": "formatBlock.parentHash",
      "kind": "PropertySignature",
      "signature": "parentHash: string;",
      "doc": "The hash of the previous block in the blockchain. The genesis block\nhas the parentHash of the [[ZeroHash]].",
      "tags": []
    },
    {
      "name": "formatBlock.parentBeaconBlockRoot",
      "kind": "PropertySignature",
      "signature": "parentBeaconBlockRoot?: null | string;",
      "doc": "The hash tree root of the parent beacon block for the given\nexecution block. See [[link-eip-4788]].",
      "tags": []
    },
    {
      "name": "formatBlock.nonce",
      "kind": "PropertySignature",
      "signature": "nonce: string;",
      "doc": "A random sequence provided during the mining process for\nproof-of-work networks.",
      "tags": []
    },
    {
      "name": "formatBlock.difficulty",
      "kind": "PropertySignature",
      "signature": "difficulty: bigint;",
      "doc": "For proof-of-work networks, the difficulty target is used to\nadjust the difficulty in mining to ensure an expected block rate.",
      "tags": []
    },
    {
      "name": "formatBlock.gasLimit",
      "kind": "PropertySignature",
      "signature": "gasLimit: bigint;",
      "doc": "The maximum amount of gas a block can consume.",
      "tags": []
    },
    {
      "name": "formatBlock.gasUsed",
      "kind": "PropertySignature",
      "signature": "gasUsed: bigint;",
      "doc": "The amount of gas a block consumed.",
      "tags": []
    },
    {
      "name": "formatBlock.blobGasUsed",
      "kind": "PropertySignature",
      "signature": "blobGasUsed?: null | bigint;",
      "doc": "The total amount of BLOb gas consumed by transactions within\nthe block. See [[link-eip4844].",
      "tags": []
    },
    {
      "name": "formatBlock.excessBlobGas",
      "kind": "PropertySignature",
      "signature": "excessBlobGas?: null | bigint;",
      "doc": "The running total of BLOb gas consumed in excess of the target\nprior to the block. See [[link-eip-4844]].",
      "tags": []
    },
    {
      "name": "formatBlock.miner",
      "kind": "PropertySignature",
      "signature": "miner: string;",
      "doc": "The miner (or author) of a block.",
      "tags": []
    },
    {
      "name": "formatBlock.prevRandao",
      "kind": "PropertySignature",
      "signature": "prevRandao?: null | string;",
      "doc": "The latest RANDAO mix of the post beacon state of\nthe previous block.",
      "tags": []
    },
    {
      "name": "formatBlock.extraData",
      "kind": "PropertySignature",
      "signature": "extraData: string;",
      "doc": "Additional data the miner choose to include.",
      "tags": []
    },
    {
      "name": "formatBlock.baseFeePerGas",
      "kind": "PropertySignature",
      "signature": "baseFeePerGas: null | bigint;",
      "doc": "The protocol-defined base fee per gas in an [[link-eip-1559]]\nblock.",
      "tags": []
    },
    {
      "name": "formatBlock.stateRoot",
      "kind": "PropertySignature",
      "signature": "stateRoot?: null | string;",
      "doc": "The root hash for the global state after applying changes\nin this block.",
      "tags": []
    },
    {
      "name": "formatBlock.receiptsRoot",
      "kind": "PropertySignature",
      "signature": "receiptsRoot?: null | string;",
      "doc": "The hash of the transaction receipts trie.",
      "tags": []
    },
    {
      "name": "formatBlock.transactions",
      "kind": "PropertySignature",
      "signature": "transactions: ReadonlyArray<string | TransactionResponseParams>;",
      "doc": "The list of transactions in the block.",
      "tags": []
    },
    {
      "name": "formatReceiptLog",
      "kind": "FunctionDeclaration",
      "signature": "export function formatReceiptLog(value: any): LogParams {\n    return _formatReceiptLog(value);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatReceiptLog.transactionHash",
      "kind": "PropertySignature",
      "signature": "transactionHash: string;",
      "doc": "The transaction hash for the transaxction the log occurred in.",
      "tags": []
    },
    {
      "name": "formatReceiptLog.blockHash",
      "kind": "PropertySignature",
      "signature": "blockHash: string;",
      "doc": "The block hash of the block that included the transaction for this\nlog.",
      "tags": []
    },
    {
      "name": "formatReceiptLog.blockNumber",
      "kind": "PropertySignature",
      "signature": "blockNumber: number;",
      "doc": "The block number of the block that included the transaction for this\nlog.",
      "tags": []
    },
    {
      "name": "formatReceiptLog.removed",
      "kind": "PropertySignature",
      "signature": "removed: boolean;",
      "doc": "Whether this log was removed due to the transaction it was included\nin being removed dur to an orphaned block.",
      "tags": []
    },
    {
      "name": "formatReceiptLog.address",
      "kind": "PropertySignature",
      "signature": "address: string;",
      "doc": "The address of the contract that emitted this log.",
      "tags": []
    },
    {
      "name": "formatReceiptLog.data",
      "kind": "PropertySignature",
      "signature": "data: string;",
      "doc": "The data emitted with this log.",
      "tags": []
    },
    {
      "name": "formatReceiptLog.topics",
      "kind": "PropertySignature",
      "signature": "topics: ReadonlyArray<string>;",
      "doc": "The topics emitted with this log.",
      "tags": []
    },
    {
      "name": "formatReceiptLog.index",
      "kind": "PropertySignature",
      "signature": "index: number;",
      "doc": "The index of this log.",
      "tags": []
    },
    {
      "name": "formatReceiptLog.transactionIndex",
      "kind": "PropertySignature",
      "signature": "transactionIndex: number;",
      "doc": "The transaction index of this log.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt",
      "kind": "FunctionDeclaration",
      "signature": "export function formatTransactionReceipt(value: any): TransactionReceiptParams {\n    return _formatTransactionReceipt(value);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.to",
      "kind": "PropertySignature",
      "signature": "to: null | string;",
      "doc": "The target of the transaction. If null, the transaction was trying\nto deploy a transaction with the ``data`` as the initi=code.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.from",
      "kind": "PropertySignature",
      "signature": "from: string;",
      "doc": "The sender of the transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.contractAddress",
      "kind": "PropertySignature",
      "signature": "contractAddress: null | string;",
      "doc": "If the transaction was directly deploying a contract, the [[to]]\nwill be null, the ``data`` will be initcode and if successful, this\nwill be the address of the contract deployed.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.hash",
      "kind": "PropertySignature",
      "signature": "hash: string;",
      "doc": "The transaction hash.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.index",
      "kind": "PropertySignature",
      "signature": "index: number;",
      "doc": "The transaction index.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.blockHash",
      "kind": "PropertySignature",
      "signature": "blockHash: string;",
      "doc": "The block hash of the block that included this transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.blockNumber",
      "kind": "PropertySignature",
      "signature": "blockNumber: number;",
      "doc": "The block number of the block that included this transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.logsBloom",
      "kind": "PropertySignature",
      "signature": "logsBloom: string;",
      "doc": "The bloom filter for the logs emitted during execution of this\ntransaction.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.logs",
      "kind": "PropertySignature",
      "signature": "logs: ReadonlyArray<LogParams>;",
      "doc": "The logs emitted during the execution of this transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.gasUsed",
      "kind": "PropertySignature",
      "signature": "gasUsed: bigint;",
      "doc": "The amount of gas consumed executing this transaciton.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.blobGasUsed",
      "kind": "PropertySignature",
      "signature": "blobGasUsed?: null | bigint;",
      "doc": "The amount of BLOb gas used. See [[link-eip-4844]].",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.cumulativeGasUsed",
      "kind": "PropertySignature",
      "signature": "cumulativeGasUsed: bigint;",
      "doc": "The total amount of gas consumed during the entire block up to\nand including this transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.gasPrice",
      "kind": "PropertySignature",
      "signature": "gasPrice?: null | bigint;",
      "doc": "The actual gas price per gas charged for this transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.blobGasPrice",
      "kind": "PropertySignature",
      "signature": "blobGasPrice?: null | bigint;",
      "doc": "The actual BLOb gas price that was charged. See [[link-eip-4844]].",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.effectiveGasPrice",
      "kind": "PropertySignature",
      "signature": "effectiveGasPrice?: null | bigint;",
      "doc": "The actual gas price per gas charged for this transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.type",
      "kind": "PropertySignature",
      "signature": "type: number;",
      "doc": "The [[link-eip-2718]] envelope type.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.status",
      "kind": "PropertySignature",
      "signature": "status: null | number;",
      "doc": "The status of the transaction execution. If ``1`` then the\nthe transaction returned success, if ``0`` then the transaction\nwas reverted. For pre-byzantium blocks, this is usually null, but\nsome nodes may have backfilled this data.",
      "tags": []
    },
    {
      "name": "formatTransactionReceipt.root",
      "kind": "PropertySignature",
      "signature": "root: null | string;",
      "doc": "The root of this transaction in a pre-bazatium block. In\npost-byzantium blocks this is null.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse",
      "kind": "FunctionDeclaration",
      "signature": "export function formatTransactionResponse(value: any): TransactionResponseParams {\n\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && getBigInt(value.to) === BN_0) {\n        value.to = \"0x000000000000000000",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.blockNumber",
      "kind": "PropertySignature",
      "signature": "blockNumber: null | number;",
      "doc": "The block number of the block that included this transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.blockHash",
      "kind": "PropertySignature",
      "signature": "blockHash: null | string;",
      "doc": "The block hash of the block that included this transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.hash",
      "kind": "PropertySignature",
      "signature": "hash: string;",
      "doc": "The transaction hash.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.index",
      "kind": "PropertySignature",
      "signature": "index: number;",
      "doc": "The transaction index.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.type",
      "kind": "PropertySignature",
      "signature": "type: number;",
      "doc": "The [[link-eip-2718]] transaction type.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.to",
      "kind": "PropertySignature",
      "signature": "to: null | string;",
      "doc": "The target of the transaction. If ``null``, the ``data`` is initcode\nand this transaction is a deployment transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.from",
      "kind": "PropertySignature",
      "signature": "from: string;",
      "doc": "The sender of the transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.nonce",
      "kind": "PropertySignature",
      "signature": "nonce: number;",
      "doc": "The nonce of the transaction, used for replay protection.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.gasLimit",
      "kind": "PropertySignature",
      "signature": "gasLimit: bigint;",
      "doc": "The maximum amount of gas this transaction is authorized to consume.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.gasPrice",
      "kind": "PropertySignature",
      "signature": "gasPrice: bigint;",
      "doc": "For legacy transactions, this is the gas price per gas to pay.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.maxPriorityFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxPriorityFeePerGas: null | bigint;",
      "doc": "For [[link-eip-1559]] transactions, this is the maximum priority\nfee to allow a producer to claim.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.maxFeePerGas",
      "kind": "PropertySignature",
      "signature": "maxFeePerGas: null | bigint;",
      "doc": "For [[link-eip-1559]] transactions, this is the maximum fee that\nwill be paid.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.maxFeePerBlobGas",
      "kind": "PropertySignature",
      "signature": "maxFeePerBlobGas?: null | bigint;",
      "doc": "For [[link-eip-4844]] transactions, this is the maximum fee that\nwill be paid per BLOb.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.data",
      "kind": "PropertySignature",
      "signature": "data: string;",
      "doc": "The transaction data.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.value",
      "kind": "PropertySignature",
      "signature": "value: bigint;",
      "doc": "The transaction value (in wei).",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.chainId",
      "kind": "PropertySignature",
      "signature": "chainId: bigint;",
      "doc": "The chain ID this transaction is valid on.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.signature",
      "kind": "PropertySignature",
      "signature": "signature: Signature;",
      "doc": "The signature of the transaction.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.accessList",
      "kind": "PropertySignature",
      "signature": "accessList: null | AccessList;",
      "doc": "The transaction access list.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.blobVersionedHashes",
      "kind": "PropertySignature",
      "signature": "blobVersionedHashes?: null | Array<string>;",
      "doc": "The [[link-eip-4844]] BLOb versioned hashes.",
      "tags": []
    },
    {
      "name": "formatTransactionResponse.authorizationList",
      "kind": "PropertySignature",
      "signature": "authorizationList: null | Array<Authorization>;",
      "doc": "The [[link-eip-7702]] authorizations (if any).",
      "tags": []
    },
    {
      "name": "FormatFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FormatFunc = (value: any) => any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "AvatarLinkageType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AvatarLinkageType = \"name\" | \"avatar\" | \"!avatar\" | \"url\" | \"data\" | \"ipfs\" |\n    \"erc721\" | \"erc1155\" | \"!erc721-caip\" | \"!erc1155-caip\" |\n    \"!owner\" | \"owner\" | \"!balance\" | \"balance\" |\n    \"metadata-url-base\" | \"metadata-url-expanded\" | \"metadata-url\" | \"!metadata-url\" |\n    \"!metad",
      "doc": "The type of data found during a steip during avatar resolution.",
      "tags": []
    },
    {
      "name": "AvatarLinkage",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AvatarLinkage {\n    /**\n     *  The type of linkage.\n     */\n    type: AvatarLinkageType;\n\n    /**\n     *  The linkage value.\n     */\n    value: string;\n}",
      "doc": "An individual record for each step during avatar resolution.",
      "tags": []
    },
    {
      "name": "AvatarResult",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AvatarResult {\n    /**\n     *  How the [[url]] was arrived at, resolving the many steps required\n     *  for an avatar URL.\n     */\n    linkage: Array<AvatarLinkage>;\n\n    /**\n     *  The avatar URL or null if the avatar was not set, or there was\n     *  an issue during validation (",
      "doc": "When resolving an avatar for an ENS name, there are many\nsteps involved, fetching metadata, validating results, et cetera.\n\nSome applications may wish to analyse this data, or use this data\nto diagnose promblems, so an **AvatarResult** provides details of\neach completed step during avatar resolution.",
      "tags": []
    },
    {
      "name": "MulticoinProviderPlugin",
      "kind": "ClassDeclaration",
      "signature": "export abstract class MulticoinProviderPlugin implements AbstractProviderPlugin {\n    /**\n     *  The name.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name: string) {\n        defineProperties<MulticoinProviderP",
      "doc": "A provider plugin super-class for processing multicoin address types.",
      "tags": []
    },
    {
      "name": "BasicMulticoinProviderPlugin",
      "kind": "ClassDeclaration",
      "signature": "export class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */\n    constructor() {\n        super(BasicMulticoinPluginId);\n    }\n}",
      "doc": "A **BasicMulticoinProviderPlugin** provides service for common\ncoin types, which do not require additional libraries to encode or\ndecode.",
      "tags": []
    },
    {
      "name": "EnsResolver",
      "kind": "ClassDeclaration",
      "signature": "export class EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider!: AbstractProvider;\n\n    /**\n     *  The address of the resolver.\n     */\n    address!: string;\n\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name!: string;\n\n    // For EIP-2544 names,",
      "doc": "A connected object to a resolved ENS name resolver, which can be\nused to query additional details.",
      "tags": []
    },
    {
      "name": "getDefaultProvider",
      "kind": "FunctionDeclaration",
      "signature": "export function getDefaultProvider(network?: string | Networkish | WebSocketLike, options?: any): AbstractProvider {\n    if (options == null) { options = { }; }\n\n    const allowService = (name: string) => {\n        if (options[name] === \"-\") { return false; }\n        if (typeof(options.exclusive) ==",
      "doc": "Returns a default provider for %%network%%.\n\nIf %%network%% is a [[WebSocketLike]] or string that begins with\n``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\nby that WebSocket or URL.\n\nIf %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\na [[JsonRpcProvider]] is returned connected to that URL.\n\nOtherwise, a default provider is created backed by well-known public\nWeb3 backends (such as [[link-infura]]) using community-provided API\nkeys.\n\nThe %%options%% allows specifying custom API keys per backend (setting\nan API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\ncan be set to either a backend name or and array of backend names, which\nwill whitelist **only** those backends.\n\nCurrent backend strings supported are:\n- ``\"alchemy\"``\n- ``\"ankr\"``\n- ``\"cloudflare\"``\n- ``\"chainstack\"``\n- ``\"etherscan\"``\n- ``\"infura\"``\n- ``\"publicPolygon\"``\n- ``\"quicknode\"``",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Connect to a local Geth node\nprovider = getDefaultProvider(\"http://localhost:8545/\");\n\n// Connect to Ethereum mainnet with any current and future\n// third-party services available\nprovider = getDefaultProvider(\"mainnet\");\n\n// Connect to Polygon, but only allow Etherscan and\n// INFURA and use \"MY_API_KEY\" in calls to Etherscan.\nprovider = getDefaultProvider(\"matic\", {\netherscan: \"MY_API_KEY\",\nexclusive: [ \"etherscan\", \"infura\" ]\n});"
        }
      ]
    },
    {
      "name": "getDefaultProvider.#subs",
      "kind": "PropertyDeclaration",
      "signature": "#subs: Map<string, Sub>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#plugins",
      "kind": "PropertyDeclaration",
      "signature": "#plugins: Map<string, AbstractProviderPlugin>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#pausedState",
      "kind": "PropertyDeclaration",
      "signature": "#pausedState: null | boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#destroyed",
      "kind": "PropertyDeclaration",
      "signature": "#destroyed: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#networkPromise",
      "kind": "PropertyDeclaration",
      "signature": "#networkPromise: null | Promise<Network>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#anyNetwork",
      "kind": "PropertyDeclaration",
      "signature": "readonly #anyNetwork: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#performCache",
      "kind": "PropertyDeclaration",
      "signature": "#performCache: Map<string, Promise<any>>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#lastBlockNumber",
      "kind": "PropertyDeclaration",
      "signature": "#lastBlockNumber: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#nextTimer",
      "kind": "PropertyDeclaration",
      "signature": "#nextTimer: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#timers",
      "kind": "PropertyDeclaration",
      "signature": "#timers: Map<number, { timer: null | Timer, func: () => void, time: number }>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#disableCcipRead",
      "kind": "PropertyDeclaration",
      "signature": "#disableCcipRead: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#options",
      "kind": "PropertyDeclaration",
      "signature": "#options: Required<AbstractProviderOptions>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.pollingInterval",
      "kind": "GetAccessor",
      "signature": "get pollingInterval(): number { return this.#options.pollingInterval; }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.provider",
      "kind": "GetAccessor",
      "signature": "get provider(): this { return this; }",
      "doc": "Returns ``this``, to allow an **AbstractProvider** to implement\nthe [[ContractRunner]] interface.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.plugins",
      "kind": "GetAccessor",
      "signature": "get plugins(): Array<AbstractProviderPlugin> {\n        return Array.from(this.#plugins.values());\n    }",
      "doc": "Returns all the registered plug-ins.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.attachPlugin",
      "kind": "MethodDeclaration",
      "signature": "attachPlugin(plugin: AbstractProviderPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name,  plugin.connect(this));\n        return this;\n    }",
      "doc": "Attach a new plug-in.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getPlugin",
      "kind": "MethodDeclaration",
      "signature": "getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }",
      "doc": "Get a plugin by name.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.disableCcipRead",
      "kind": "GetAccessor",
      "signature": "get disableCcipRead(): boolean { return this.#disableCcipRead; }",
      "doc": "Prevent any CCIP-read operation, regardless of whether requested\nin a [[call]] using ``enableCcipRead``.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#perform",
      "kind": "MethodDeclaration",
      "signature": "async #perform<T = any>(req: PerformActionRequest): Promise<T> {\n        const timeout = this.#options.cacheTimeout;\n\n        // Caching disabled\n        if (timeout < 0) { return await this._perform(req); }\n\n        // Create a tag\n        const tag = getTag(req.method, req);\n\n        let perform =",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.ccipReadFetch",
      "kind": "MethodDeclaration",
      "signature": "async ccipReadFetch(tx: PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n     ",
      "doc": "Resolves to the data for executing the CCIP-read operations.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapBlock",
      "kind": "MethodDeclaration",
      "signature": "_wrapBlock(value: BlockParams, network: Network): Block {\n        return new Block(formatBlock(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a block before\nreturning it, to add additional properties or an alternate\nsub-class of [[Block]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapLog",
      "kind": "MethodDeclaration",
      "signature": "_wrapLog(value: LogParams, network: Network): Log {\n        return new Log(formatLog(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a log before\nreturning it, to add additional properties or an alternate\nsub-class of [[Log]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapTransactionReceipt",
      "kind": "MethodDeclaration",
      "signature": "_wrapTransactionReceipt(value: TransactionReceiptParams, network: Network): TransactionReceipt {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a transaction\nreceipt before returning it, to add additional properties or an\nalternate sub-class of [[TransactionReceipt]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._wrapTransactionResponse",
      "kind": "MethodDeclaration",
      "signature": "_wrapTransactionResponse(tx: TransactionResponseParams, network: Network): TransactionResponse {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }",
      "doc": "Provides the opportunity for a sub-class to wrap a transaction\nresponse before returning it, to add additional properties or an\nalternate sub-class of [[TransactionResponse]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider._detectNetwork",
      "kind": "MethodDeclaration",
      "signature": "_detectNetwork(): Promise<Network> {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }",
      "doc": "Resolves to the Network, forcing a network detection using whatever\ntechnique the sub-class requires.\n\nSub-classes **must** override this.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._perform",
      "kind": "MethodDeclaration",
      "signature": "async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        assert(false, `unsupported method: ${ req.method }`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }",
      "doc": "Sub-classes should use this to perform all built-in operations. All\nmethods sanitizes and normalizes the values passed into this.\n\nSub-classes **must** override this.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBlockNumber",
      "kind": "MethodDeclaration",
      "signature": "async getBlockNumber(): Promise<number> {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) { this.#lastBlockNumber = blockNumber; }\n        return blockNumber;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getAddress",
      "kind": "MethodDeclaration",
      "signature": "_getAddress(address: AddressLike): string | Promise<string> {\n        return resolveAddress(address, this);\n    }",
      "doc": "Returns or resolves to the address for %%address%%, resolving ENS\nnames and [[Addressable]] objects and returning if already an\naddress.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getBlockTag",
      "kind": "MethodDeclaration",
      "signature": "_getBlockTag(blockTag?: BlockTag): string | Promise<string> {\n        if (blockTag == null) { return \"latest\"; }\n\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            ca",
      "doc": "Returns or resolves to a valid block tag for %%blockTag%%, resolving\nnegative values and returning if already a valid block tag.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getFilter",
      "kind": "MethodDeclaration",
      "signature": "_getFilter(filter: Filter | FilterByBlockHash): PerformActionFilter | Promise<PerformActionFilter> {\n\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || [ ]).map((t) => {\n            if (t == null) { return null; }\n            if (Array.isArray(t)) {\n",
      "doc": "Returns or resolves to a filter for %%filter%%, resolving any ENS\nnames or [[Addressable]] object and returning if already a valid\nfilter.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getTransactionRequest",
      "kind": "MethodDeclaration",
      "signature": "_getTransactionRequest(_request: TransactionRequest): PerformActionTransaction | Promise<PerformActionTransaction> {\n        const request = <PerformActionTransaction>copyRequest(_request);\n\n        const promises: Array<Promise<void>> = [ ];\n        [ \"to\", \"from\" ].forEach((key) => {\n            i",
      "doc": "Returns or resolves to a transaction for %%request%%, resolving\nany ENS names or [[Addressable]] and returning if already a valid\ntransaction.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getNetwork",
      "kind": "MethodDeclaration",
      "signature": "async getNetwork(): Promise<Network> {\n\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n            ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getFeeData",
      "kind": "MethodDeclaration",
      "signature": "async getFeeData(): Promise<FeeData> {\n        const network = await this.getNetwork();\n\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await resolveProperties({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((a",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.estimateGas",
      "kind": "MethodDeclaration",
      "signature": "async estimateGas(_tx: TransactionRequest): Promise<bigint> {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) { tx = await tx; }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#call",
      "kind": "MethodDeclaration",
      "signature": "async #call(tx: PerformActionTransaction, blockTag: string, attempt: number): Promise<string> {\n        assert (attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n             reason: \"TOO_MANY_REDIRECTS\",\n             transaction: Object.assign({ }, tx, { b",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#checkNetwork",
      "kind": "MethodDeclaration",
      "signature": "async #checkNetwork<T>(promise: Promise<T>): Promise<T> {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.call",
      "kind": "MethodDeclaration",
      "signature": "async call(_tx: TransactionRequest): Promise<string> {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getAccountValue",
      "kind": "MethodDeclaration",
      "signature": "async #getAccountValue(request: _PerformAccountRequest, _address: AddressLike, _blockTag?: BlockTag): Promise<any> {\n        let address: string | Promise<string> = this._getAddress(_address);\n        let blockTag: string | Promise<string> = this._getBlockTag(_blockTag);\n\n        if (typeof(address)",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBalance",
      "kind": "MethodDeclaration",
      "signature": "async getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint> {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionCount",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number> {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getCode",
      "kind": "MethodDeclaration",
      "signature": "async getCode(address: AddressLike, blockTag?: BlockTag): Promise<string> {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getStorage",
      "kind": "MethodDeclaration",
      "signature": "async getStorage(address: AddressLike, _position: BigNumberish, blockTag?: BlockTag): Promise<string> {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.broadcastTransaction",
      "kind": "MethodDeclaration",
      "signature": "async broadcastTransaction(signedTx: string): Promise<TransactionResponse> {\n        const { blockNumber, hash, network } = await resolveProperties({\n             blockNumber: this.getBlockNumber(),\n             hash: this._perform({\n                 method: \"broadcastTransaction\",\n                 ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getBlock",
      "kind": "MethodDeclaration",
      "signature": "async #getBlock(block: BlockTag | string, includeTransactions: boolean): Promise<any> {\n        // @TODO: Add CustomBlockPlugin check\n\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getBlock",
      "kind": "MethodDeclaration",
      "signature": "async getBlock(block: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) { return nul",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransaction",
      "kind": "MethodDeclaration",
      "signature": "async getTransaction(hash: string): Promise<null | TransactionResponse> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) { return null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionReceipt",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionReceipt(hash: string): Promise<null | TransactionReceipt> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) {",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getTransactionResult",
      "kind": "MethodDeclaration",
      "signature": "async getTransactionResult(hash: string): Promise<null | string> {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) { return null; }\n       ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getLogs",
      "kind": "MethodDeclaration",
      "signature": "async getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>> {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) { filter = await filter; }\n\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getProvider",
      "kind": "MethodDeclaration",
      "signature": "_getProvider(chainId: number): AbstractProvider {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getResolver",
      "kind": "MethodDeclaration",
      "signature": "async getResolver(name: string): Promise<null | EnsResolver> {\n        return await EnsResolver.fromName(this, name);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.getAvatar",
      "kind": "MethodDeclaration",
      "signature": "async getAvatar(name: string): Promise<null | string> {\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAvatar(); }\n        return null;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.resolveName",
      "kind": "MethodDeclaration",
      "signature": "async resolveName(name: string): Promise<null | string>{\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAddress(); }\n        return null;\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.lookupAddress",
      "kind": "MethodDeclaration",
      "signature": "async lookupAddress(address: string): Promise<null | string> {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n\n        try {\n\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.waitForTransaction",
      "kind": "MethodDeclaration",
      "signature": "async waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms != null) ? _confirms: 1;\n        if (confirms === 0) { return this.getTransactionReceipt(hash); }\n\n        return new Promise(async (re",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.waitForBlock",
      "kind": "MethodDeclaration",
      "signature": "async waitForBlock(blockTag?: BlockTag): Promise<Block> {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider._clearTimeout",
      "kind": "MethodDeclaration",
      "signature": "_clearTimeout(timerId: number): void {\n        const timer = this.#timers.get(timerId);\n        if (!timer) { return; }\n        if (timer.timer) { clearTimeout(timer.timer); }\n        this.#timers.delete(timerId);\n    }",
      "doc": "Clear a timer created using the [[_setTimeout]] method.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._setTimeout",
      "kind": "MethodDeclaration",
      "signature": "_setTimeout(_func: () => void, timeout?: number): number {\n        if (timeout == null) { timeout = 0; }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n\n        if (this.paused) {\n            this.#tim",
      "doc": "Create a timer that will execute %%func%% after at least %%timeout%%\n(in ms). If %%timeout%% is unspecified, then %%func%% will execute\nin the next event loop.\n\n[Pausing](AbstractProvider-paused) the provider will pause any\nassociated timers.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._forEachSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_forEachSubscriber(func: (s: Subscriber) => void): void {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }",
      "doc": "Perform %%func%% on each subscriber.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._getSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new PollingBlockSubscri",
      "doc": "Sub-classes may override this to customize subscription\nimplementations.",
      "tags": []
    },
    {
      "name": "getDefaultProvider._recoverSubscriber",
      "kind": "MethodDeclaration",
      "signature": "_recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) { sub.subscriber.stop(); }\n                sub.subscriber = newSub;\n                if (sub.started) { new",
      "doc": "If a [[Subscriber]] fails and needs to replace itself, this\nmethod may be used.\n\nFor example, this is used for providers when using the\n``eth_getFilterChanges`` method, which can return null if state\nfilters are not supported by the backend, allowing the Subscriber\nto swap in a [[PollingEventSubscriber]].",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#hasSub",
      "kind": "MethodDeclaration",
      "signature": "async #hasSub(event: ProviderEvent, emitArgs?: Array<any>): Promise<null | Sub> {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.#getSub",
      "kind": "MethodDeclaration",
      "signature": "async #getSub(event: ProviderEvent): Promise<Sub> {\n        const subscription = await getSubscription(event, this);\n\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n          ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.on",
      "kind": "MethodDeclaration",
      "signature": "async on(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.once",
      "kind": "MethodDeclaration",
      "signature": "async once(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.emit",
      "kind": "MethodDeclaration",
      "signature": "async emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean> {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.len",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.listenerCount",
      "kind": "MethodDeclaration",
      "signature": "async listenerCount(event?: ProviderEvent): Promise<number> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        let total = 0;\n        for (const { listeners } of this.#subs.values()",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.listeners",
      "kind": "MethodDeclaration",
      "signature": "async listeners(event?: ProviderEvent): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return  [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result: Array<Listener> = [ ];\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.off",
      "kind": "MethodDeclaration",
      "signature": "async off(event: ProviderEvent, listener?: Listener): Promise<this> {\n        const sub = await this.#hasSub(event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { su",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.removeAllListeners",
      "kind": "MethodDeclaration",
      "signature": "async removeAllListeners(event?: ProviderEvent): Promise<this> {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) { subscriber.stop(); }\n            this.#subs.delete(tag);\n        } else {\n            for (const [ tag, { start",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.addListener",
      "kind": "MethodDeclaration",
      "signature": "async addListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return await this.on(event, listener);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.removeListener",
      "kind": "MethodDeclaration",
      "signature": "async removeListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return this.off(event, listener);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDefaultProvider.destroyed",
      "kind": "GetAccessor",
      "signature": "get destroyed(): boolean {\n        return this.#destroyed;\n    }",
      "doc": "If this provider has been destroyed using the [[destroy]] method.\n\nOnce destroyed, all resources are reclaimed, internal event loops\nand timers are cleaned up and no further requests may be sent to\nthe provider.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.destroy",
      "kind": "MethodDeclaration",
      "signature": "destroy(): void {\n        // Stop all listeners\n        this.removeAllListeners();\n\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n\n        this.#destroyed = true;\n    }",
      "doc": "Sub-classes may use this to shutdown any sockets or release their\nresources and reject any pending requests.\n\nSub-classes **must** call ``super.destroy()``.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.paused",
      "kind": "GetAccessor",
      "signature": "get paused(): boolean { return (this.#pausedState != null); }",
      "doc": "Whether the provider is currently paused.\n\nA paused provider will not emit any events, and generally should\nnot make any requests to the network, but that is up to sub-classes\nto manage.\n\nSetting ``paused = true`` is identical to calling ``.pause(false)``,\nwhich will buffer any events that occur while paused until the\nprovider is unpaused.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.pause",
      "kind": "MethodDeclaration",
      "signature": "pause(dropWhilePaused?: boolean): void {\n        this.#lastBlockNumber = -1;\n\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) { return; }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                op",
      "doc": "Pause the provider. If %%dropWhilePaused%%, any events that occur\nwhile paused are dropped, otherwise all events will be emitted once\nthe provider is unpaused.",
      "tags": []
    },
    {
      "name": "getDefaultProvider.resume",
      "kind": "MethodDeclaration",
      "signature": "resume(): void {\n        if (this.#pausedState == null) { return; }\n\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n    ",
      "doc": "Resume the provider.",
      "tags": []
    },
    {
      "name": "ContractRunner",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractRunner {\n    /**\n     *  The provider used for necessary state querying operations.\n     *\n     *  This can also point to the **ContractRunner** itself, in the\n     *  case of an [[AbstractProvider]].\n     */\n    provider: null | Provider;\n\n    /**\n     *  Required to estima",
      "doc": "A **ContractRunner** is a generic interface which defines an object\ncapable of interacting with a Contract on the network.\n\nThe more operations supported, the more utility it is capable of.\n\nThe most common ContractRunners are [Providers](Provider) which enable\nread-only access and [Signers](Signer) which enable write-access.",
      "tags": []
    },
    {
      "name": "showThrottleMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function showThrottleMessage(service: string): void {\n    if (shown.has(service)) { return; }\n    shown.add(service);\n\n    console.log(\"========= NOTICE =========\")\n    console.log(`Request-Rate Exceeded for ${ service } (this message will not be repeated)`);\n    console.log(\"\");\n    console.",
      "doc": "Displays a warning in the console when the community resource is\nbeing used too heavily by the app, recommending the developer\nacquire their own credentials instead of using the community\ncredentials.\n\nThe notification will only occur once per service.",
      "tags": []
    },
    {
      "name": "CommunityResourcable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CommunityResourcable {\n    /**\n     *  Returns true if the instance is connected using the community\n     *  credentials.\n     */\n    isCommunityResource(): boolean;\n}",
      "doc": "There are many awesome community services that provide Ethereum\nnodes both for developers just starting out and for large-scale\ncommunities.\nProviders which offer community credentials should extend this\nto notify any interested consumers whether community credentials\nare in-use.",
      "tags": [
        {
          "tagName": "_section",
          "text": ": api/providers/thirdparty: Community Providers  [thirdparty]"
        }
      ]
    },
    {
      "name": "AbstractSigner",
      "kind": "ClassDeclaration",
      "signature": "export abstract class AbstractSigner<P extends null | Provider = null | Provider> implements Signer {\n    /**\n     *  The provider this signer is connected to.\n     */\n    readonly provider!: P;\n\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider?: P) {\n",
      "doc": "An **AbstractSigner** includes most of teh functionality required\nto get a [[Signer]] working as expected, but requires a few\nSigner-specific methods be overridden.",
      "tags": []
    },
    {
      "name": "VoidSigner",
      "kind": "ClassDeclaration",
      "signature": "export class VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    readonly address!: string;\n\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address: string, provider?: null | Provider) {\n        ",
      "doc": "A **VoidSigner** is a class deisgned to allow an address to be used\nin any API which accepts a Signer, but for which there are no\ncredentials available to perform any actual signing.\n\nThis for example allow impersonating an account for the purpose of\nstatic calls or estimating gas, but does not allow sending transactions.",
      "tags": []
    },
    {
      "name": "DebugEventAbstractProvider",
      "kind": "TypeAliasDeclaration",
      "signature": "export type DebugEventAbstractProvider = {\n    action: \"sendCcipReadFetchRequest\",\n    request: FetchRequest\n    index: number\n    urls: Array<string>\n} | {\n    action: \"receiveCcipReadFetchResult\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"receiveCcipReadFetchError\",\n    request",
      "doc": "The types of additional event values that can be emitted for the\n``\"debug\"`` event.",
      "tags": []
    },
    {
      "name": "Subscription",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Subscription = {\n    type: \"block\" | \"close\" | \"debug\" | \"error\" | \"finalized\" | \"network\" | \"pending\" | \"safe\",\n    tag: string\n} | {\n    type: \"transaction\",\n    tag: string,\n    hash: string\n} | {\n    type: \"event\",\n    tag: string,\n    filter: EventFilter\n} | {\n    type: \"orphan\",\n  ",
      "doc": "The value passed to the [[AbstractProvider-_getSubscriber]] method.\n\nOnly developers sub-classing [[AbstractProvider[[ will care about this,\nif they are modifying a low-level feature of how subscriptions operate.",
      "tags": []
    },
    {
      "name": "Subscriber",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Subscriber {\n    /**\n     *  Called initially when a subscriber is added the first time.\n     */\n    start(): void;\n\n    /**\n     *  Called when there are no more subscribers to the event.\n     */\n    stop(): void;\n\n    /**\n     *  Called when the subscription should pause.\n     *\n ",
      "doc": "A **Subscriber** manages a subscription.\n\nOnly developers sub-classing [[AbstractProvider[[ will care about this,\nif they are modifying a low-level feature of how subscriptions operate.",
      "tags": []
    },
    {
      "name": "UnmanagedSubscriber",
      "kind": "ClassDeclaration",
      "signature": "export class UnmanagedSubscriber implements Subscriber {\n    /**\n     *  The name fof the event.\n     */\n    name!: string;\n\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name: string) { defineProperties<UnmanagedSubscriber>(this, { name }); }\n\n    start(): ",
      "doc": "An **UnmanagedSubscriber** is useful for events which do not require\nany additional management, such as ``\"debug\"`` which only requires\nemit in synchronous event loop triggered calls.",
      "tags": []
    },
    {
      "name": "AbstractProviderPlugin",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AbstractProviderPlugin {\n    /**\n     *  The reverse domain notation of the plugin.\n     */\n    readonly name: string;\n\n    /**\n     *  Creates a new instance of the plugin, connected to %%provider%%.\n     */\n    connect(provider: AbstractProvider): AbstractProviderPlugin;\n}",
      "doc": "An **AbstractPlugin** is used to provide additional internal services\nto an [[AbstractProvider]] without adding backwards-incompatible changes\nto method signatures or other internal and complex logic.",
      "tags": []
    },
    {
      "name": "PerformActionFilter",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PerformActionFilter = {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n} | {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    blockHash?: string;\n};",
      "doc": "A normalized filter used for [[PerformActionRequest]] objects.",
      "tags": []
    },
    {
      "name": "PerformActionTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PerformActionTransaction extends PreparedTransactionRequest {\n    /**\n     *  The ``to`` address of the transaction.\n     */\n    to?: string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: string;\n}",
      "doc": "A normalized transactions used for [[PerformActionRequest]] objects.",
      "tags": []
    },
    {
      "name": "PerformActionRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PerformActionRequest = {\n    method: \"broadcastTransaction\",\n    signedTransaction: string\n} | {\n    method: \"call\",\n    transaction: PerformActionTransaction, blockTag: BlockTag\n} | {\n    method: \"chainId\"\n} | {\n    method: \"estimateGas\",\n    transaction: PerformActionTransaction\n} | {\n",
      "doc": "The [[AbstractProvider]] methods will normalize all values and pass this\ntype to [[AbstractProvider-_perform]].",
      "tags": []
    },
    {
      "name": "AbstractProviderOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AbstractProviderOptions = {\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};",
      "doc": "Options for configuring some internal aspects of an [[AbstractProvider]].\n\n**``cacheTimeout``** - how long to cache a low-level ``_perform``\nfor, based on input parameters. This reduces the number of calls\nto getChainId and getBlockNumber, but may break test chains which\ncan perform operations (internally) synchronously. Use ``-1`` to\ndisable, ``0`` will only buffer within the same event loop and\nany other value is in ms. (default: ``250``)",
      "tags": []
    },
    {
      "name": "AbstractProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AbstractProvider implements Provider {\n\n    #subs: Map<string, Sub>;\n    #plugins: Map<string, AbstractProviderPlugin>;\n\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState: null | boolean;\n\n    #destroyed: boolean;\n\n    #networkPromise: null | Promise<Netwo",
      "doc": "An **AbstractProvider** provides a base class for other sub-classes to\nimplement the [[Provider]] API by normalizing input arguments and\nformatting output results as well as tracking events for consistent\nbehaviour on an eventually-consistent network.",
      "tags": []
    },
    {
      "name": "verifyTypedData",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}",
      "doc": "Compute the address used to sign the typed data for the %%signature%%.",
      "tags": []
    },
    {
      "name": "TypedDataDomain",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedDataDomain {\n    /**\n     *  The human-readable name of the signing domain.\n     */\n    name?: null | string;\n\n    /**\n     *  The major version of the signing domain.\n     */\n    version?: null | string;\n\n    /**\n     *  The chain ID of the signing domain.\n     */\n    chainId?",
      "doc": "The domain for an [[link-eip-712]] payload.",
      "tags": []
    },
    {
      "name": "TypedDataField",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedDataField {\n    /**\n     *  The field name.\n     */\n    name: string;\n\n    /**\n     *  The type of the field.\n     */\n    type: string;\n}",
      "doc": "A specific field of a structured [[link-eip-712]] type.",
      "tags": []
    },
    {
      "name": "TypedDataEncoder",
      "kind": "ClassDeclaration",
      "signature": "export class TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only rema",
      "doc": "A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\nfor signed typed data.\n\nThis is useful for those that wish to compute various components of a\ntyped data hash, primary types, or sub-components, but generally the\nhigher level [[Signer-signTypedData]] is more useful.",
      "tags": []
    },
    {
      "name": "solidityPacked",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPacked(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, in",
      "doc": "Computes the [[link-solc-packed]] representation of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "solidityPackedKeccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPackedKeccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _keccak256(solidityPacked(types, values));\n}",
      "doc": "Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "solidityPackedSha256",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPackedSha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _sha256(solidityPacked(types, values));\n}",
      "doc": "Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "ensNormalize",
      "kind": "FunctionDeclaration",
      "signature": "export function ensNormalize(name: string): string {\n    try {\n        if (name.length === 0) { throw new Error(\"empty label\"); }\n        return ens_normalize(name);\n    } catch (error: any) {\n        assertArgument(false, `invalid ENS name (${ error.message })`, \"name\", name);\n    }\n}",
      "doc": "Returns the ENS %%name%% normalized.",
      "tags": []
    },
    {
      "name": "isValidName",
      "kind": "FunctionDeclaration",
      "signature": "export function isValidName(name: string): name is string {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns ``true`` if %%name%% is a valid ENS name.",
      "tags": []
    },
    {
      "name": "namehash",
      "kind": "FunctionDeclaration",
      "signature": "export function namehash(name: string): string {\n    assertArgument(typeof(name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n\n    assertArgument(name.length, `invalid ENS name (empty label)`, \"name\", name);\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSp",
      "doc": "Returns the [[link-namehash]] for %%name%%.",
      "tags": []
    },
    {
      "name": "dnsEncode",
      "kind": "FunctionDeclaration",
      "signature": "export function dnsEncode(name: string, _maxLength?: number): string {\n    const length = (_maxLength != null) ? _maxLength: 63;\n\n    assertArgument(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        assertAr",
      "doc": "Returns the DNS encoded %%name%%.\n\nThis is used for various parts of ENS name resolution, such\nas the wildcard resolution.",
      "tags": []
    },
    {
      "name": "hashMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function hashMessage(message: Uint8Array | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(MessagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}",
      "doc": "Computes the [[link-eip-191]] personal-sign message digest to sign.\n\nThis prefixes the message with [[MessagePrefix]] and the decimal length\nof %%message%% and computes the [[keccak256]] digest.\n\nIf %%message%% is a string, it is converted to its UTF-8 bytes\nfirst. To compute the digest of a [[DataHexString]], it must be converted\nto [bytes](getBytes).",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nhashMessage(\"Hello World\")\n//_result:\n\n// Hashes the SIX (6) string characters, i.e.\n// [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\nhashMessage(\"0x4243\")\n//_result:\n\n// Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\nhashMessage(getBytes(\"0x4243\"))\n//_result:\n\n// ...which is equal to using data\nhashMessage(new Uint8Array([ 0x42, 0x43 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "verifyMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyMessage(message: Uint8Array | string, sig: SignatureLike): string {\n    const digest = hashMessage(message);\n    return recoverAddress(digest, sig);\n}",
      "doc": "Return the address of the private key that produced\nthe signature %%sig%% during signing for %%message%%.",
      "tags": []
    },
    {
      "name": "hashAuthorization",
      "kind": "FunctionDeclaration",
      "signature": "export function hashAuthorization(auth: AuthorizationRequest): string {\n    assertArgument(typeof(auth.address) === \"string\", \"invalid address for hashAuthorization\", \"auth.address\", auth);\n    return keccak256(concat([\n        \"0x05\", encodeRlp([\n            (auth.chainId != null) ? toBeArray(auth.",
      "doc": "Computes the [[link-eip-7702]] authorization digest to sign.",
      "tags": []
    },
    {
      "name": "verifyAuthorization",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyAuthorization(auth: AuthorizationRequest, sig: SignatureLike): string {\n    return recoverAddress(hashAuthorization(auth), sig);\n}",
      "doc": "Return the address of the private key that produced\nthe signature %%sig%% during signing for %%message%%.",
      "tags": []
    },
    {
      "name": "id",
      "kind": "FunctionDeclaration",
      "signature": "export function id(value: string): string {\n    return keccak256(toUtf8Bytes(value));\n}",
      "doc": "A simple hashing function which operates on UTF-8 strings to\ncompute an 32-byte identifier.\n\nThis simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\nthe [[keccak256]].",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nid(\"hello world\")\n//_result:"
        }
      ]
    },
    {
      "name": "ensNormalize",
      "kind": "FunctionDeclaration",
      "signature": "export function ensNormalize(name: string): string {\n    try {\n        if (name.length === 0) { throw new Error(\"empty label\"); }\n        return ens_normalize(name);\n    } catch (error: any) {\n        assertArgument(false, `invalid ENS name (${ error.message })`, \"name\", name);\n    }\n}",
      "doc": "Returns the ENS %%name%% normalized.",
      "tags": []
    },
    {
      "name": "isValidName",
      "kind": "FunctionDeclaration",
      "signature": "export function isValidName(name: string): name is string {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns ``true`` if %%name%% is a valid ENS name.",
      "tags": []
    },
    {
      "name": "namehash",
      "kind": "FunctionDeclaration",
      "signature": "export function namehash(name: string): string {\n    assertArgument(typeof(name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n\n    assertArgument(name.length, `invalid ENS name (empty label)`, \"name\", name);\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSp",
      "doc": "Returns the [[link-namehash]] for %%name%%.",
      "tags": []
    },
    {
      "name": "dnsEncode",
      "kind": "FunctionDeclaration",
      "signature": "export function dnsEncode(name: string, _maxLength?: number): string {\n    const length = (_maxLength != null) ? _maxLength: 63;\n\n    assertArgument(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        assertAr",
      "doc": "Returns the DNS encoded %%name%%.\n\nThis is used for various parts of ENS name resolution, such\nas the wildcard resolution.",
      "tags": []
    },
    {
      "name": "hashMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function hashMessage(message: Uint8Array | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(MessagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}",
      "doc": "Computes the [[link-eip-191]] personal-sign message digest to sign.\n\nThis prefixes the message with [[MessagePrefix]] and the decimal length\nof %%message%% and computes the [[keccak256]] digest.\n\nIf %%message%% is a string, it is converted to its UTF-8 bytes\nfirst. To compute the digest of a [[DataHexString]], it must be converted\nto [bytes](getBytes).",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nhashMessage(\"Hello World\")\n//_result:\n\n// Hashes the SIX (6) string characters, i.e.\n// [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\nhashMessage(\"0x4243\")\n//_result:\n\n// Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\nhashMessage(getBytes(\"0x4243\"))\n//_result:\n\n// ...which is equal to using data\nhashMessage(new Uint8Array([ 0x42, 0x43 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "verifyMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyMessage(message: Uint8Array | string, sig: SignatureLike): string {\n    const digest = hashMessage(message);\n    return recoverAddress(digest, sig);\n}",
      "doc": "Return the address of the private key that produced\nthe signature %%sig%% during signing for %%message%%.",
      "tags": []
    },
    {
      "name": "solidityPacked",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPacked(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, in",
      "doc": "Computes the [[link-solc-packed]] representation of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "solidityPackedKeccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPackedKeccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _keccak256(solidityPacked(types, values));\n}",
      "doc": "Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "solidityPackedSha256",
      "kind": "FunctionDeclaration",
      "signature": "export function solidityPackedSha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\n    return _sha256(solidityPacked(types, values));\n}",
      "doc": "Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\nrespectively to their %%types%%.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\nsolidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n//_result:"
        }
      ]
    },
    {
      "name": "TypedDataEncoder",
      "kind": "ClassDeclaration",
      "signature": "export class TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only rema",
      "doc": "A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\nfor signed typed data.\n\nThis is useful for those that wish to compute various components of a\ntyped data hash, primary types, or sub-components, but generally the\nhigher level [[Signer-signTypedData]] is more useful.",
      "tags": []
    },
    {
      "name": "verifyTypedData",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}",
      "doc": "Compute the address used to sign the typed data for the %%signature%%.",
      "tags": []
    },
    {
      "name": "AuthorizationRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AuthorizationRequest {\n    address: string | Addressable;\n    nonce?: Numeric;\n    chainId?: BigNumberish;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "TypedDataDomain",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedDataDomain {\n    /**\n     *  The human-readable name of the signing domain.\n     */\n    name?: null | string;\n\n    /**\n     *  The major version of the signing domain.\n     */\n    version?: null | string;\n\n    /**\n     *  The chain ID of the signing domain.\n     */\n    chainId?",
      "doc": "The domain for an [[link-eip-712]] payload.",
      "tags": []
    },
    {
      "name": "TypedDataField",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedDataField {\n    /**\n     *  The field name.\n     */\n    name: string;\n\n    /**\n     *  The type of the field.\n     */\n    type: string;\n}",
      "doc": "A specific field of a structured [[link-eip-712]] type.",
      "tags": []
    },
    {
      "name": "id",
      "kind": "FunctionDeclaration",
      "signature": "export function id(value: string): string {\n    return keccak256(toUtf8Bytes(value));\n}",
      "doc": "A simple hashing function which operates on UTF-8 strings to\ncompute an 32-byte identifier.\n\nThis simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\nthe [[keccak256]].",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nid(\"hello world\")\n//_result:"
        }
      ]
    },
    {
      "name": "hashAuthorization",
      "kind": "FunctionDeclaration",
      "signature": "export function hashAuthorization(auth: AuthorizationRequest): string {\n    assertArgument(typeof(auth.address) === \"string\", \"invalid address for hashAuthorization\", \"auth.address\", auth);\n    return keccak256(concat([\n        \"0x05\", encodeRlp([\n            (auth.chainId != null) ? toBeArray(auth.",
      "doc": "Computes the [[link-eip-7702]] authorization digest to sign.",
      "tags": []
    },
    {
      "name": "verifyAuthorization",
      "kind": "FunctionDeclaration",
      "signature": "export function verifyAuthorization(auth: AuthorizationRequest, sig: SignatureLike): string {\n    return recoverAddress(hashAuthorization(auth), sig);\n}",
      "doc": "Return the address of the private key that produced\nthe signature %%sig%% during signing for %%message%%.",
      "tags": []
    },
    {
      "name": "AuthorizationRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AuthorizationRequest {\n    address: string | Addressable;\n    nonce?: Numeric;\n    chainId?: BigNumberish;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SigningKey",
      "kind": "ClassDeclaration",
      "signature": "export class SigningKey {\n    #privateKey: string;\n\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey: BytesLike) {\n        assertArgument(dataLength(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = h",
      "doc": "A **SigningKey** provides high-level access to the elliptic curve\ncryptography (ECC) operations and key management.",
      "tags": []
    },
    {
      "name": "SignatureLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type SignatureLike = Signature | string | {\n    r: string;\n    s: string;\n    v: BigNumberish;\n    yParity?: 0 | 1;\n    yParityAndS?: string;\n} | {\n    r: string;\n    yParityAndS: string;\n    yParity?: 0 | 1;\n    s?: string;\n    v?: number;\n} | {\n    r: string;\n    s: string;\n    yParity: 0 |",
      "doc": "A SignatureLike",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Signing"
        }
      ]
    },
    {
      "name": "Signature",
      "kind": "ClassDeclaration",
      "signature": "export class Signature {\n    #r: string;\n    #s: string;\n    #v: 27 | 28;\n    #networkV: null | bigint;\n\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n   ",
      "doc": "A Signature",
      "tags": [
        {
          "tagName": "TODO",
          "text": ""
        },
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Signing"
        }
      ]
    },
    {
      "name": "sha256",
      "kind": "FunctionDeclaration",
      "signature": "export function sha256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha256(data));\n}",
      "doc": "Compute the cryptographic SHA2-256 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nsha256(\"0x\")\n//_result:\n\nsha256(\"0x1337\")\n//_result:\n\nsha256(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "FunctionDeclaration",
      "signature": "export function sha512(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha512(data));\n}",
      "doc": "Compute the cryptographic SHA2-512 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nsha512(\"0x\")\n//_result:\n\nsha512(\"0x1337\")\n//_result:\n\nsha512(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "FunctionDeclaration",
      "signature": "export async function scrypt(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number, progress?: ProgressCallback): Promise<string> {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(await __scryptAsync(passwd, salt, ",
      "doc": "The [[link-wiki-scrypt]] uses a memory and cpu hard method of\nderivation to increase the resource cost to brute-force a password\nfor a given key.\n\nThis means this algorithm is intentionally slow, and can be tuned to\nbecome slower. As computation and memory speed improve over time,\nincreasing the difficulty maintains the cost of an attacker.\n\nFor example, if a target time of 5 seconds is used, a legitimate user\nwhich knows their password requires only 5 seconds to unlock their\naccount. A 6 character password has 68 billion possibilities, which\nwould require an attacker to invest over 10,000 years of CPU time. This\nis of course a crude example (as password generally aren't random),\nbut demonstrates to value of imposing large costs to decryption.\n\nFor this reason, if building a UI which involved decrypting or\nencrypting datsa using scrypt, it is recommended to use a\n[[ProgressCallback]] (as event short periods can seem lik an eternity\nif the UI freezes). Including the phrase //\"decrypting\"// in the UI\ncan also help, assuring the user their waiting is for a good reason.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        },
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the scrypt\nscrypt(passwordBytes, salt, 1024, 8, 1, 16)\n//_result:"
        }
      ]
    },
    {
      "name": "scrypt.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "FunctionDeclaration",
      "signature": "export function scryptSync(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number): string {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(__scryptSync(passwd, salt, N, r, p, dkLen));\n}",
      "doc": "Provides a synchronous variant of [[scrypt]].\n\nThis will completely lock up and freeze the UI in a browser and will\nprevent any event loop from progressing. For this reason, it is\npreferred to use the [async variant](scrypt).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        },
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the scrypt\nscryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n//_result:"
        }
      ]
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProgressCallback",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProgressCallback = (percent: number) => void;",
      "doc": "A callback during long-running operations to update any\nUI or provide programatic access to the progress.\n\nThe %%percent%% is a value between ``0`` and ``1``.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        }
      ]
    },
    {
      "name": "ripemd160",
      "kind": "FunctionDeclaration",
      "signature": "export function ripemd160(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__ripemd160(data));\n}",
      "doc": "Compute the cryptographic RIPEMD-160 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nripemd160(\"0x\")\n//_result:\n\nripemd160(\"0x1337\")\n//_result:\n\nripemd160(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function randomBytes(length: number): Uint8Array {\n    return __randomBytes(length);\n}",
      "doc": "Return %%length%% bytes of cryptographically secure random data.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nrandomBytes(8)\n//_result:"
        }
      ]
    },
    {
      "name": "randomBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "FunctionDeclaration",
      "signature": "export function pbkdf2(_password: BytesLike, _salt: BytesLike, iterations: number, keylen: number, algo: \"sha256\" | \"sha512\"): string {\n    const password = getBytes(_password, \"password\");\n    const salt = getBytes(_salt, \"salt\");\n    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo",
      "doc": "Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\nthe %%salt%% and using %%iterations%% of %%algo%%.\n\nThis PBKDF is outdated and should not be used in new projects, but is\nrequired to decrypt older files.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the PBKDF2\npbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n//_result:"
        }
      ]
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function keccak256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}",
      "doc": "Compute the cryptographic KECCAK256 hash of %%data%%.\n\nThe %%data%% **must** be a data representation, to compute the\nhash of UTF-8 data use the [[id]] function.",
      "tags": [
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nkeccak256(\"0x\")\n//_result:\n\nkeccak256(\"0x1337\")\n//_result:\n\nkeccak256(new Uint8Array([ 0x13, 0x37 ]))\n//_result:\n\n// Strings are assumed to be DataHexString, otherwise it will\n// throw. To hash UTF-8 data, see the note above.\nkeccak256(\"Hello World\")\n//_error:"
        }
      ]
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "FunctionDeclaration",
      "signature": "export function computeHmac(algorithm: \"sha256\" | \"sha512\", _key: BytesLike, _data: BytesLike): string {\n    const key = getBytes(_key, \"key\");\n    const data = getBytes(_data, \"data\");\n    return hexlify(__computeHmac(algorithm, key, data));\n}",
      "doc": "Return the HMAC for %%data%% using the %%key%% key with the underlying\n%%algo%% used for compression.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nkey = id(\"some-secret\")\n\n// Compute the HMAC\ncomputeHmac(\"sha256\", key, \"0x1337\")\n//_result:\n\n// To compute the HMAC of UTF-8 data, the data must be\n// converted to UTF-8 bytes\ncomputeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\n//_result:"
        }
      ]
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function randomBytes(length: number): Uint8Array {\n    return __randomBytes(length);\n}",
      "doc": "Return %%length%% bytes of cryptographically secure random data.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nrandomBytes(8)\n//_result:"
        }
      ]
    },
    {
      "name": "randomBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "Identifier",
      "signature": "randomBytes",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function keccak256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}",
      "doc": "Compute the cryptographic KECCAK256 hash of %%data%%.\n\nThe %%data%% **must** be a data representation, to compute the\nhash of UTF-8 data use the [[id]] function.",
      "tags": [
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nkeccak256(\"0x\")\n//_result:\n\nkeccak256(\"0x1337\")\n//_result:\n\nkeccak256(new Uint8Array([ 0x13, 0x37 ]))\n//_result:\n\n// Strings are assumed to be DataHexString, otherwise it will\n// throw. To hash UTF-8 data, see the note above.\nkeccak256(\"Hello World\")\n//_error:"
        }
      ]
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "Identifier",
      "signature": "keccak256",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "FunctionDeclaration",
      "signature": "export function ripemd160(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__ripemd160(data));\n}",
      "doc": "Compute the cryptographic RIPEMD-160 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nripemd160(\"0x\")\n//_result:\n\nripemd160(\"0x1337\")\n//_result:\n\nripemd160(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "ripemd160",
      "kind": "Identifier",
      "signature": "ripemd160",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "FunctionDeclaration",
      "signature": "export function sha256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha256(data));\n}",
      "doc": "Compute the cryptographic SHA2-256 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nsha256(\"0x\")\n//_result:\n\nsha256(\"0x1337\")\n//_result:\n\nsha256(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha256",
      "kind": "Identifier",
      "signature": "sha256",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "FunctionDeclaration",
      "signature": "export function sha512(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha512(data));\n}",
      "doc": "Compute the cryptographic SHA2-512 hash of %%data%%.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Hash Functions"
        },
        {
          "tagName": "returns",
          "text": "DataHexstring"
        },
        {
          "tagName": "example",
          "text": ":\nsha512(\"0x\")\n//_result:\n\nsha512(\"0x1337\")\n//_result:\n\nsha512(new Uint8Array([ 0x13, 0x37 ]))\n//_result:"
        }
      ]
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "sha512",
      "kind": "Identifier",
      "signature": "sha512",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "FunctionDeclaration",
      "signature": "export function pbkdf2(_password: BytesLike, _salt: BytesLike, iterations: number, keylen: number, algo: \"sha256\" | \"sha512\"): string {\n    const password = getBytes(_password, \"password\");\n    const salt = getBytes(_salt, \"salt\");\n    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo",
      "doc": "Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\nthe %%salt%% and using %%iterations%% of %%algo%%.\n\nThis PBKDF is outdated and should not be used in new projects, but is\nrequired to decrypt older files.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the PBKDF2\npbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n//_result:"
        }
      ]
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2",
      "kind": "Identifier",
      "signature": "pbkdf2",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "FunctionDeclaration",
      "signature": "export async function scrypt(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number, progress?: ProgressCallback): Promise<string> {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(await __scryptAsync(passwd, salt, ",
      "doc": "The [[link-wiki-scrypt]] uses a memory and cpu hard method of\nderivation to increase the resource cost to brute-force a password\nfor a given key.\n\nThis means this algorithm is intentionally slow, and can be tuned to\nbecome slower. As computation and memory speed improve over time,\nincreasing the difficulty maintains the cost of an attacker.\n\nFor example, if a target time of 5 seconds is used, a legitimate user\nwhich knows their password requires only 5 seconds to unlock their\naccount. A 6 character password has 68 billion possibilities, which\nwould require an attacker to invest over 10,000 years of CPU time. This\nis of course a crude example (as password generally aren't random),\nbut demonstrates to value of imposing large costs to decryption.\n\nFor this reason, if building a UI which involved decrypting or\nencrypting datsa using scrypt, it is recommended to use a\n[[ProgressCallback]] (as event short periods can seem lik an eternity\nif the UI freezes). Including the phrase //\"decrypting\"// in the UI\ncan also help, assuring the user their waiting is for a good reason.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        },
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the scrypt\nscrypt(passwordBytes, salt, 1024, 8, 1, 16)\n//_result:"
        }
      ]
    },
    {
      "name": "scrypt.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scrypt",
      "kind": "Identifier",
      "signature": "scrypt",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "FunctionDeclaration",
      "signature": "export function scryptSync(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number): string {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(__scryptSync(passwd, salt, N, r, p, dkLen));\n}",
      "doc": "Provides a synchronous variant of [[scrypt]].\n\nThis will completely lock up and freeze the UI in a browser and will\nprevent any event loop from progressing. For this reason, it is\npreferred to use the [async variant](scrypt).",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        },
        {
          "tagName": "example",
          "text": ":\n// The password must be converted to bytes, and it is generally\n// best practices to ensure the string has been normalized. Many\n// formats explicitly indicate the normalization form to use.\npassword = \"hello\"\npasswordBytes = toUtf8Bytes(password, \"NFKC\")\n\nsalt = id(\"some-salt\")\n\n// Compute the scrypt\nscryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n//_result:"
        }
      ]
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "scryptSync",
      "kind": "Identifier",
      "signature": "scryptSync",
      "doc": "",
      "tags": []
    },
    {
      "name": "SigningKey",
      "kind": "ClassDeclaration",
      "signature": "export class SigningKey {\n    #privateKey: string;\n\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey: BytesLike) {\n        assertArgument(dataLength(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = h",
      "doc": "A **SigningKey** provides high-level access to the elliptic curve\ncryptography (ECC) operations and key management.",
      "tags": []
    },
    {
      "name": "Signature",
      "kind": "ClassDeclaration",
      "signature": "export class Signature {\n    #r: string;\n    #s: string;\n    #v: 27 | 28;\n    #networkV: null | bigint;\n\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n   ",
      "doc": "A Signature",
      "tags": [
        {
          "tagName": "TODO",
          "text": ""
        },
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Signing"
        }
      ]
    },
    {
      "name": "lock",
      "kind": "FunctionDeclaration",
      "signature": "function lock(): void {\n    computeHmac.lock();\n    keccak256.lock();\n    pbkdf2.lock();\n    randomBytes.lock();\n    ripemd160.lock();\n    scrypt.lock();\n    scryptSync.lock();\n    sha256.lock();\n    sha512.lock();\n    randomBytes.lock();\n}",
      "doc": "Once called, prevents any future change to the underlying cryptographic\nprimitives using the ``.register`` feature for hooks.",
      "tags": []
    },
    {
      "name": "ProgressCallback",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProgressCallback = (percent: number) => void;",
      "doc": "A callback during long-running operations to update any\nUI or provide programatic access to the progress.\n\nThe %%percent%% is a value between ``0`` and ``1``.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Passwords"
        }
      ]
    },
    {
      "name": "SignatureLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type SignatureLike = Signature | string | {\n    r: string;\n    s: string;\n    v: BigNumberish;\n    yParity?: 0 | 1;\n    yParityAndS?: string;\n} | {\n    r: string;\n    yParityAndS: string;\n    yParity?: 0 | 1;\n    s?: string;\n    v?: number;\n} | {\n    r: string;\n    s: string;\n    yParity: 0 |",
      "doc": "A SignatureLike",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/crypto:Signing"
        }
      ]
    },
    {
      "name": "computeHmac",
      "kind": "FunctionDeclaration",
      "signature": "export function computeHmac(algorithm: \"sha256\" | \"sha512\", _key: BytesLike, _data: BytesLike): string {\n    const key = getBytes(_key, \"key\");\n    const data = getBytes(_data, \"data\");\n    return hexlify(__computeHmac(algorithm, key, data));\n}",
      "doc": "Return the HMAC for %%data%% using the %%key%% key with the underlying\n%%algo%% used for compression.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\nkey = id(\"some-secret\")\n\n// Compute the HMAC\ncomputeHmac(\"sha256\", key, \"0x1337\")\n//_result:\n\n// To compute the HMAC of UTF-8 data, the data must be\n// converted to UTF-8 bytes\ncomputeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\n//_result:"
        }
      ]
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "computeHmac",
      "kind": "Identifier",
      "signature": "computeHmac",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash",
      "kind": "FunctionDeclaration",
      "signature": "function createHash(algorithm: string, options?: HashOptions): Hash;",
      "doc": "Creates and returns a `Hash` object that can be used to generate hash digests\nusing the given `algorithm`. Optional `options` argument controls stream\nbehavior. For XOF hash functions such as `'shake256'`, the `outputLength` option\ncan be used to specify the desired output length in bytes.\n\nThe `algorithm` is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc.\nOn recent releases of OpenSSL, `openssl list -digest-algorithms` will\ndisplay the available digest algorithms.\n\nExample: generating the sha256 sum of a file\n\n```js\nimport {\n  createReadStream,\n} from 'node:fs';\nimport { argv } from 'node:process';\nconst {\n  createHash,\n} = await import('node:crypto');\n\nconst filename = argv[2];\n\nconst hash = createHash('sha256');\n\nconst input = createReadStream(filename);\ninput.on('readable', () => {\n  // Only one element is going to be produced by the\n  // hash stream.\n  const data = input.read();\n  if (data)\n    hash.update(data);\n  else {\n    console.log(`${hash.digest('hex')} ${filename}`);\n  }\n});\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.92"
        },
        {
          "tagName": "param",
          "text": "`stream.transform` options"
        }
      ]
    },
    {
      "name": "createHash.copy",
      "kind": "MethodDeclaration",
      "signature": "copy(options?: HashOptions): Hash;",
      "doc": "Creates a new `Hash` object that contains a deep copy of the internal state\nof the current `Hash` object.\n\nThe optional `options` argument controls stream behavior. For XOF hash\nfunctions such as `'shake256'`, the `outputLength` option can be used to\nspecify the desired output length in bytes.\n\nAn error is thrown when an attempt is made to copy the `Hash` object after\nits `hash.digest()` method has been called.\n\n```js\n// Calculate a rolling hash.\nconst {\n  createHash,\n} = await import('node:crypto');\n\nconst hash = createHash('sha256');\n\nhash.update('one');\nconsole.log(hash.copy().digest('hex'));\n\nhash.update('two');\nconsole.log(hash.copy().digest('hex'));\n\nhash.update('three');\nconsole.log(hash.copy().digest('hex'));\n\n// Etc.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v13.1.0"
        },
        {
          "tagName": "param",
          "text": "`stream.transform` options"
        }
      ]
    },
    {
      "name": "createHash.update",
      "kind": "MethodDeclaration",
      "signature": "update(data: BinaryLike): Hash;",
      "doc": "Updates the hash content with the given `data`, the encoding of which\nis given in `inputEncoding`.\nIf `encoding` is not provided, and the `data` is a string, an\nencoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.\n\nThis can be called many times with new data as it is streamed.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.92"
        },
        {
          "tagName": "param",
          "text": "The `encoding` of the `data` string."
        }
      ]
    },
    {
      "name": "createHash.digest",
      "kind": "MethodDeclaration",
      "signature": "digest(): Buffer;",
      "doc": "Calculates the digest of all of the data passed to be hashed (using the `hash.update()` method).\nIf `encoding` is provided a string will be returned; otherwise\na `Buffer` is returned.\n\nThe `Hash` object can not be used again after `hash.digest()` method has been\ncalled. Multiple calls will cause an error to be thrown.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.92"
        },
        {
          "tagName": "param",
          "text": "The `encoding` of the return value."
        }
      ]
    },
    {
      "name": "createHash._transform",
      "kind": "MethodDeclaration",
      "signature": "_transform(chunk: any, encoding: BufferEncoding, callback: TransformCallback): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash._flush",
      "kind": "MethodDeclaration",
      "signature": "_flush(callback: TransformCallback): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.writable",
      "kind": "PropertyDeclaration",
      "signature": "readonly writable: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.writableEnded",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableEnded: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.writableFinished",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableFinished: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.writableHighWaterMark",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableHighWaterMark: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.writableLength",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableLength: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.writableObjectMode",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableObjectMode: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.writableCorked",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableCorked: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.writableNeedDrain",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableNeedDrain: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.closed",
      "kind": "PropertyDeclaration",
      "signature": "readonly closed: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.errored",
      "kind": "PropertyDeclaration",
      "signature": "readonly errored: Error | null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.allowHalfOpen",
      "kind": "PropertyDeclaration",
      "signature": "allowHalfOpen: boolean;",
      "doc": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `true`.\n\nThis can be changed manually to change the half-open behavior of an existing\n`Duplex` stream instance, but must be changed before the `'end'` event is emitted.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        }
      ]
    },
    {
      "name": "createHash._write",
      "kind": "MethodDeclaration",
      "signature": "_write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash._writev",
      "kind": "MethodDeclaration",
      "signature": "_writev?(\n                chunks: Array<{\n                    chunk: any;\n                    encoding: BufferEncoding;\n                }>,\n                callback: (error?: Error | null) => void,\n            ): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash._destroy",
      "kind": "MethodDeclaration",
      "signature": "_destroy(error: Error | null, callback: (error?: Error | null) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash._final",
      "kind": "MethodDeclaration",
      "signature": "_final(callback: (error?: Error | null) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.write",
      "kind": "MethodDeclaration",
      "signature": "write(chunk: any, encoding?: BufferEncoding, cb?: (error: Error | null | undefined) => void): boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.setDefaultEncoding",
      "kind": "MethodDeclaration",
      "signature": "setDefaultEncoding(encoding: BufferEncoding): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.end",
      "kind": "MethodDeclaration",
      "signature": "end(cb?: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.cork",
      "kind": "MethodDeclaration",
      "signature": "cork(): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.uncork",
      "kind": "MethodDeclaration",
      "signature": "uncork(): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.addListener",
      "kind": "MethodDeclaration",
      "signature": "addListener(event: \"close\", listener: () => void): this;",
      "doc": "Event emitter\nThe defined events on documents including:\n1.  close\n2.  data\n3.  drain\n4.  end\n5.  error\n6.  finish\n7.  pause\n8.  pipe\n9.  readable\n10. resume\n11. unpipe",
      "tags": []
    },
    {
      "name": "createHash.emit",
      "kind": "MethodDeclaration",
      "signature": "emit(event: \"close\"): boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.on",
      "kind": "MethodDeclaration",
      "signature": "on(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.once",
      "kind": "MethodDeclaration",
      "signature": "once(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.prependListener",
      "kind": "MethodDeclaration",
      "signature": "prependListener(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.prependOnceListener",
      "kind": "MethodDeclaration",
      "signature": "prependOnceListener(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.removeListener",
      "kind": "MethodDeclaration",
      "signature": "removeListener(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.readableAborted",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableAborted: boolean;",
      "doc": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v16.8.0"
        },
        {
          "tagName": "experimental",
          "text": ""
        }
      ]
    },
    {
      "name": "createHash.readable",
      "kind": "PropertyDeclaration",
      "signature": "readable: boolean;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v11.4.0"
        }
      ]
    },
    {
      "name": "createHash.readableDidRead",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableDidRead: boolean;",
      "doc": "Returns whether `'data'` has been emitted.",
      "tags": [
        {
          "tagName": "since",
          "text": "v16.7.0, v14.18.0"
        },
        {
          "tagName": "experimental",
          "text": ""
        }
      ]
    },
    {
      "name": "createHash.readableEncoding",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableEncoding: BufferEncoding | null;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.7.0"
        }
      ]
    },
    {
      "name": "createHash.readableEnded",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableEnded: boolean;",
      "doc": "Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v22.x/api/stream.html#event-end) event is emitted.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.9.0"
        }
      ]
    },
    {
      "name": "createHash.readableFlowing",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableFlowing: boolean | null;",
      "doc": "This property reflects the current state of a `Readable` stream as described\nin the [Three states](https://nodejs.org/docs/latest-v22.x/api/stream.html#three-states) section.",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.4.0"
        }
      ]
    },
    {
      "name": "createHash.readableHighWaterMark",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableHighWaterMark: number;",
      "doc": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.3.0"
        }
      ]
    },
    {
      "name": "createHash.readableLength",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableLength: number;",
      "doc": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.4.0"
        }
      ]
    },
    {
      "name": "createHash.readableObjectMode",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableObjectMode: boolean;",
      "doc": "Getter for the property `objectMode` of a given `Readable` stream.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.3.0"
        }
      ]
    },
    {
      "name": "createHash.destroyed",
      "kind": "PropertyDeclaration",
      "signature": "destroyed: boolean;",
      "doc": "Is `true` after `readable.destroy()` has been called.",
      "tags": [
        {
          "tagName": "since",
          "text": "v8.0.0"
        }
      ]
    },
    {
      "name": "createHash._construct",
      "kind": "MethodDeclaration",
      "signature": "_construct?(callback: (error?: Error | null) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash._read",
      "kind": "MethodDeclaration",
      "signature": "_read(size: number): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.read",
      "kind": "MethodDeclaration",
      "signature": "read(size?: number): any;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        },
        {
          "tagName": "param",
          "text": "Optional argument to specify how much data to read."
        }
      ]
    },
    {
      "name": "createHash.setEncoding",
      "kind": "MethodDeclaration",
      "signature": "setEncoding(encoding: BufferEncoding): this;",
      "doc": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        },
        {
          "tagName": "param",
          "text": "The encoding to use."
        }
      ]
    },
    {
      "name": "createHash.pause",
      "kind": "MethodDeclaration",
      "signature": "pause(): this;",
      "doc": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n```\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        }
      ]
    },
    {
      "name": "createHash.resume",
      "kind": "MethodDeclaration",
      "signature": "resume(): this;",
      "doc": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\n```js\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n```\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        }
      ]
    },
    {
      "name": "createHash.isPaused",
      "kind": "MethodDeclaration",
      "signature": "isPaused(): boolean;",
      "doc": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.14"
        }
      ]
    },
    {
      "name": "createHash.unpipe",
      "kind": "MethodDeclaration",
      "signature": "unpipe(destination?: NodeJS.WritableStream): this;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        },
        {
          "tagName": "param",
          "text": "Optional specific stream to unpipe"
        }
      ]
    },
    {
      "name": "createHash.unshift",
      "kind": "MethodDeclaration",
      "signature": "unshift(chunk: any, encoding?: BufferEncoding): void;",
      "doc": "[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.11"
        },
        {
          "tagName": "param",
          "text": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
        },
        {
          "tagName": "param",
          "text": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
        }
      ]
    },
    {
      "name": "createHash.wrap",
      "kind": "MethodDeclaration",
      "signature": "wrap(stream: NodeJS.ReadableStream): this;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        },
        {
          "tagName": "param",
          "text": "An \"old style\" readable stream"
        }
      ]
    },
    {
      "name": "createHash.push",
      "kind": "MethodDeclaration",
      "signature": "push(chunk: any, encoding?: BufferEncoding): boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.iterator",
      "kind": "MethodDeclaration",
      "signature": "iterator(options?: { destroyOnReturn?: boolean }): AsyncIterableIterator<any>;",
      "doc": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
      "tags": [
        {
          "tagName": "since",
          "text": "v16.3.0"
        },
        {
          "tagName": "param",
          "text": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
        }
      ]
    },
    {
      "name": "createHash.map",
      "kind": "MethodDeclaration",
      "signature": "map(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions): Readable;",
      "doc": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.4.0, v16.14.0"
        },
        {
          "tagName": "param",
          "text": "a function to map over every chunk in the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a stream mapped with the function *fn*."
        }
      ]
    },
    {
      "name": "createHash.filter",
      "kind": "MethodDeclaration",
      "signature": "filter(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Readable;",
      "doc": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.4.0, v16.14.0"
        },
        {
          "tagName": "param",
          "text": "a function to filter chunks from the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a stream filtered with the predicate *fn*."
        }
      ]
    },
    {
      "name": "createHash.forEach",
      "kind": "MethodDeclaration",
      "signature": "forEach(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>,\n            options?: ArrayOptions,\n        ): Promise<void>;",
      "doc": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to call on each chunk of the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a promise for when the stream has finished."
        }
      ]
    },
    {
      "name": "createHash.toArray",
      "kind": "MethodDeclaration",
      "signature": "toArray(options?: Pick<ArrayOptions, \"signal\">): Promise<any[]>;",
      "doc": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "returns",
          "text": "a promise containing an array with the contents of the stream."
        }
      ]
    },
    {
      "name": "createHash.some",
      "kind": "MethodDeclaration",
      "signature": "some(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Promise<boolean>;",
      "doc": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to call on each chunk of the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks."
        }
      ]
    },
    {
      "name": "createHash.find",
      "kind": "MethodDeclaration",
      "signature": "find<T>(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T,\n            options?: ArrayOptions,\n        ): Promise<T | undefined>;",
      "doc": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to call on each chunk of the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found."
        }
      ]
    },
    {
      "name": "createHash.every",
      "kind": "MethodDeclaration",
      "signature": "every(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Promise<boolean>;",
      "doc": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to call on each chunk of the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks."
        }
      ]
    },
    {
      "name": "createHash.flatMap",
      "kind": "MethodDeclaration",
      "signature": "flatMap(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions): Readable;",
      "doc": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
        },
        {
          "tagName": "returns",
          "text": "a stream flat-mapped with the function *fn*."
        }
      ]
    },
    {
      "name": "createHash.drop",
      "kind": "MethodDeclaration",
      "signature": "drop(limit: number, options?: Pick<ArrayOptions, \"signal\">): Readable;",
      "doc": "This method returns a new stream with the first *limit* chunks dropped from the start.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "the number of chunks to drop from the readable."
        },
        {
          "tagName": "returns",
          "text": "a stream with *limit* chunks dropped from the start."
        }
      ]
    },
    {
      "name": "createHash.take",
      "kind": "MethodDeclaration",
      "signature": "take(limit: number, options?: Pick<ArrayOptions, \"signal\">): Readable;",
      "doc": "This method returns a new stream with the first *limit* chunks.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "the number of chunks to take from the readable."
        },
        {
          "tagName": "returns",
          "text": "a stream with *limit* chunks taken."
        }
      ]
    },
    {
      "name": "createHash.asIndexedPairs",
      "kind": "MethodDeclaration",
      "signature": "asIndexedPairs(options?: Pick<ArrayOptions, \"signal\">): Readable;",
      "doc": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "returns",
          "text": "a stream of indexed pairs."
        }
      ]
    },
    {
      "name": "createHash.reduce",
      "kind": "MethodDeclaration",
      "signature": "reduce<T = any>(\n            fn: (previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T,\n            initial?: undefined,\n            options?: Pick<ArrayOptions, \"signal\">,\n        ): Promise<T>;",
      "doc": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a reducer function to call over every chunk in the stream. Async or not."
        },
        {
          "tagName": "param",
          "text": "the initial value to use in the reduction."
        },
        {
          "tagName": "returns",
          "text": "a promise for the final value of the reduction."
        }
      ]
    },
    {
      "name": "createHash.destroy",
      "kind": "MethodDeclaration",
      "signature": "destroy(error?: Error): this;",
      "doc": "Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event (unless `emitClose` is set to `false`). After this call, the readable\nstream will release any internal resources and subsequent calls to `push()` will be ignored.\n\nOnce `destroy()` has been called any further calls will be a no-op and no\nfurther errors except from `_destroy()` may be emitted as `'error'`.\n\nImplementors should not override this method, but instead implement `readable._destroy()`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v8.0.0"
        },
        {
          "tagName": "param",
          "text": "Error which will be passed as payload in `'error'` event"
        }
      ]
    },
    {
      "name": "createHash.__@asyncIterator@1275",
      "kind": "MethodDeclaration",
      "signature": "[Symbol.asyncIterator](): AsyncIterableIterator<any>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.__@asyncDispose@1277",
      "kind": "MethodDeclaration",
      "signature": "[Symbol.asyncDispose](): Promise<void>;",
      "doc": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
      "tags": [
        {
          "tagName": "since",
          "text": "v20.4.0"
        }
      ]
    },
    {
      "name": "createHash.pipe",
      "kind": "MethodDeclaration",
      "signature": "pipe<T extends NodeJS.WritableStream>(\n            destination: T,\n            options?: {\n                end?: boolean | undefined;\n            },\n        ): T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.compose",
      "kind": "MethodDeclaration",
      "signature": "compose<T extends NodeJS.ReadableStream>(\n            stream: T | ComposeFnParam | Iterable<T> | AsyncIterable<T>,\n            options?: { signal: AbortSignal },\n        ): T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.__@captureRejectionSymbol@1308",
      "kind": "MethodDeclaration",
      "signature": "[EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.off",
      "kind": "MethodSignature",
      "signature": "off<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Alias for `emitter.removeListener()`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v10.0.0"
        }
      ]
    },
    {
      "name": "createHash.removeAllListeners",
      "kind": "MethodSignature",
      "signature": "removeAllListeners(eventName?: Key<unknown, T>): this;",
      "doc": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "createHash.setMaxListeners",
      "kind": "MethodSignature",
      "signature": "setMaxListeners(n: number): this;",
      "doc": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.5"
        }
      ]
    },
    {
      "name": "createHash.getMaxListeners",
      "kind": "MethodSignature",
      "signature": "getMaxListeners(): number;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v1.0.0"
        }
      ]
    },
    {
      "name": "createHash.listeners",
      "kind": "MethodSignature",
      "signature": "listeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;",
      "doc": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "createHash.rawListeners",
      "kind": "MethodSignature",
      "signature": "rawListeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;",
      "doc": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.4.0"
        }
      ]
    },
    {
      "name": "createHash.listenerCount",
      "kind": "MethodSignature",
      "signature": "listenerCount<K>(eventName: Key<K, T>, listener?: Listener2<K, T>): number;",
      "doc": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
      "tags": [
        {
          "tagName": "since",
          "text": "v3.2.0"
        },
        {
          "tagName": "param",
          "text": "The name of the event being listened for"
        },
        {
          "tagName": "param",
          "text": "The event handler function"
        }
      ]
    },
    {
      "name": "createHash.eventNames",
      "kind": "MethodSignature",
      "signature": "eventNames(): Array<(string | symbol) & Key2<unknown, T>>;",
      "doc": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        }
      ]
    },
    {
      "name": "createHmac",
      "kind": "FunctionDeclaration",
      "signature": "function createHmac(algorithm: string, key: BinaryLike | KeyObject, options?: stream.TransformOptions): Hmac;",
      "doc": "[object Object],[object Object],[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.94"
        },
        {
          "tagName": "param",
          "text": "`stream.transform` options"
        }
      ]
    },
    {
      "name": "createHmac.update",
      "kind": "MethodDeclaration",
      "signature": "update(data: BinaryLike): Hmac;",
      "doc": "Updates the `Hmac` content with the given `data`, the encoding of which\nis given in `inputEncoding`.\nIf `encoding` is not provided, and the `data` is a string, an\nencoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.\n\nThis can be called many times with new data as it is streamed.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.94"
        },
        {
          "tagName": "param",
          "text": "The `encoding` of the `data` string."
        }
      ]
    },
    {
      "name": "createHmac.digest",
      "kind": "MethodDeclaration",
      "signature": "digest(): Buffer;",
      "doc": "Calculates the HMAC digest of all of the data passed using `hmac.update()`.\nIf `encoding` is\nprovided a string is returned; otherwise a `Buffer` is returned;\n\nThe `Hmac` object can not be used again after `hmac.digest()` has been\ncalled. Multiple calls to `hmac.digest()` will result in an error being thrown.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.94"
        },
        {
          "tagName": "param",
          "text": "The `encoding` of the return value."
        }
      ]
    },
    {
      "name": "createHmac._transform",
      "kind": "MethodDeclaration",
      "signature": "_transform(chunk: any, encoding: BufferEncoding, callback: TransformCallback): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac._flush",
      "kind": "MethodDeclaration",
      "signature": "_flush(callback: TransformCallback): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.writable",
      "kind": "PropertyDeclaration",
      "signature": "readonly writable: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.writableEnded",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableEnded: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.writableFinished",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableFinished: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.writableHighWaterMark",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableHighWaterMark: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.writableLength",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableLength: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.writableObjectMode",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableObjectMode: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.writableCorked",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableCorked: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.writableNeedDrain",
      "kind": "PropertyDeclaration",
      "signature": "readonly writableNeedDrain: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.closed",
      "kind": "PropertyDeclaration",
      "signature": "readonly closed: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.errored",
      "kind": "PropertyDeclaration",
      "signature": "readonly errored: Error | null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.allowHalfOpen",
      "kind": "PropertyDeclaration",
      "signature": "allowHalfOpen: boolean;",
      "doc": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `true`.\n\nThis can be changed manually to change the half-open behavior of an existing\n`Duplex` stream instance, but must be changed before the `'end'` event is emitted.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        }
      ]
    },
    {
      "name": "createHmac._write",
      "kind": "MethodDeclaration",
      "signature": "_write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac._writev",
      "kind": "MethodDeclaration",
      "signature": "_writev?(\n                chunks: Array<{\n                    chunk: any;\n                    encoding: BufferEncoding;\n                }>,\n                callback: (error?: Error | null) => void,\n            ): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac._destroy",
      "kind": "MethodDeclaration",
      "signature": "_destroy(error: Error | null, callback: (error?: Error | null) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac._final",
      "kind": "MethodDeclaration",
      "signature": "_final(callback: (error?: Error | null) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.write",
      "kind": "MethodDeclaration",
      "signature": "write(chunk: any, encoding?: BufferEncoding, cb?: (error: Error | null | undefined) => void): boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.setDefaultEncoding",
      "kind": "MethodDeclaration",
      "signature": "setDefaultEncoding(encoding: BufferEncoding): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.end",
      "kind": "MethodDeclaration",
      "signature": "end(cb?: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.cork",
      "kind": "MethodDeclaration",
      "signature": "cork(): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.uncork",
      "kind": "MethodDeclaration",
      "signature": "uncork(): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.addListener",
      "kind": "MethodDeclaration",
      "signature": "addListener(event: \"close\", listener: () => void): this;",
      "doc": "Event emitter\nThe defined events on documents including:\n1.  close\n2.  data\n3.  drain\n4.  end\n5.  error\n6.  finish\n7.  pause\n8.  pipe\n9.  readable\n10. resume\n11. unpipe",
      "tags": []
    },
    {
      "name": "createHmac.emit",
      "kind": "MethodDeclaration",
      "signature": "emit(event: \"close\"): boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.on",
      "kind": "MethodDeclaration",
      "signature": "on(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.once",
      "kind": "MethodDeclaration",
      "signature": "once(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.prependListener",
      "kind": "MethodDeclaration",
      "signature": "prependListener(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.prependOnceListener",
      "kind": "MethodDeclaration",
      "signature": "prependOnceListener(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.removeListener",
      "kind": "MethodDeclaration",
      "signature": "removeListener(event: \"close\", listener: () => void): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.readableAborted",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableAborted: boolean;",
      "doc": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v16.8.0"
        },
        {
          "tagName": "experimental",
          "text": ""
        }
      ]
    },
    {
      "name": "createHmac.readable",
      "kind": "PropertyDeclaration",
      "signature": "readable: boolean;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v11.4.0"
        }
      ]
    },
    {
      "name": "createHmac.readableDidRead",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableDidRead: boolean;",
      "doc": "Returns whether `'data'` has been emitted.",
      "tags": [
        {
          "tagName": "since",
          "text": "v16.7.0, v14.18.0"
        },
        {
          "tagName": "experimental",
          "text": ""
        }
      ]
    },
    {
      "name": "createHmac.readableEncoding",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableEncoding: BufferEncoding | null;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.7.0"
        }
      ]
    },
    {
      "name": "createHmac.readableEnded",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableEnded: boolean;",
      "doc": "Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v22.x/api/stream.html#event-end) event is emitted.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.9.0"
        }
      ]
    },
    {
      "name": "createHmac.readableFlowing",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableFlowing: boolean | null;",
      "doc": "This property reflects the current state of a `Readable` stream as described\nin the [Three states](https://nodejs.org/docs/latest-v22.x/api/stream.html#three-states) section.",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.4.0"
        }
      ]
    },
    {
      "name": "createHmac.readableHighWaterMark",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableHighWaterMark: number;",
      "doc": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.3.0"
        }
      ]
    },
    {
      "name": "createHmac.readableLength",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableLength: number;",
      "doc": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.4.0"
        }
      ]
    },
    {
      "name": "createHmac.readableObjectMode",
      "kind": "PropertyDeclaration",
      "signature": "readonly readableObjectMode: boolean;",
      "doc": "Getter for the property `objectMode` of a given `Readable` stream.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.3.0"
        }
      ]
    },
    {
      "name": "createHmac.destroyed",
      "kind": "PropertyDeclaration",
      "signature": "destroyed: boolean;",
      "doc": "Is `true` after `readable.destroy()` has been called.",
      "tags": [
        {
          "tagName": "since",
          "text": "v8.0.0"
        }
      ]
    },
    {
      "name": "createHmac._construct",
      "kind": "MethodDeclaration",
      "signature": "_construct?(callback: (error?: Error | null) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac._read",
      "kind": "MethodDeclaration",
      "signature": "_read(size: number): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.read",
      "kind": "MethodDeclaration",
      "signature": "read(size?: number): any;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        },
        {
          "tagName": "param",
          "text": "Optional argument to specify how much data to read."
        }
      ]
    },
    {
      "name": "createHmac.setEncoding",
      "kind": "MethodDeclaration",
      "signature": "setEncoding(encoding: BufferEncoding): this;",
      "doc": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        },
        {
          "tagName": "param",
          "text": "The encoding to use."
        }
      ]
    },
    {
      "name": "createHmac.pause",
      "kind": "MethodDeclaration",
      "signature": "pause(): this;",
      "doc": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n```\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        }
      ]
    },
    {
      "name": "createHmac.resume",
      "kind": "MethodDeclaration",
      "signature": "resume(): this;",
      "doc": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\n```js\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n```\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        }
      ]
    },
    {
      "name": "createHmac.isPaused",
      "kind": "MethodDeclaration",
      "signature": "isPaused(): boolean;",
      "doc": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.14"
        }
      ]
    },
    {
      "name": "createHmac.unpipe",
      "kind": "MethodDeclaration",
      "signature": "unpipe(destination?: NodeJS.WritableStream): this;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        },
        {
          "tagName": "param",
          "text": "Optional specific stream to unpipe"
        }
      ]
    },
    {
      "name": "createHmac.unshift",
      "kind": "MethodDeclaration",
      "signature": "unshift(chunk: any, encoding?: BufferEncoding): void;",
      "doc": "[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.11"
        },
        {
          "tagName": "param",
          "text": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
        },
        {
          "tagName": "param",
          "text": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
        }
      ]
    },
    {
      "name": "createHmac.wrap",
      "kind": "MethodDeclaration",
      "signature": "wrap(stream: NodeJS.ReadableStream): this;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.4"
        },
        {
          "tagName": "param",
          "text": "An \"old style\" readable stream"
        }
      ]
    },
    {
      "name": "createHmac.push",
      "kind": "MethodDeclaration",
      "signature": "push(chunk: any, encoding?: BufferEncoding): boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.iterator",
      "kind": "MethodDeclaration",
      "signature": "iterator(options?: { destroyOnReturn?: boolean }): AsyncIterableIterator<any>;",
      "doc": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
      "tags": [
        {
          "tagName": "since",
          "text": "v16.3.0"
        },
        {
          "tagName": "param",
          "text": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
        }
      ]
    },
    {
      "name": "createHmac.map",
      "kind": "MethodDeclaration",
      "signature": "map(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions): Readable;",
      "doc": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.4.0, v16.14.0"
        },
        {
          "tagName": "param",
          "text": "a function to map over every chunk in the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a stream mapped with the function *fn*."
        }
      ]
    },
    {
      "name": "createHmac.filter",
      "kind": "MethodDeclaration",
      "signature": "filter(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Readable;",
      "doc": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.4.0, v16.14.0"
        },
        {
          "tagName": "param",
          "text": "a function to filter chunks from the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a stream filtered with the predicate *fn*."
        }
      ]
    },
    {
      "name": "createHmac.forEach",
      "kind": "MethodDeclaration",
      "signature": "forEach(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>,\n            options?: ArrayOptions,\n        ): Promise<void>;",
      "doc": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to call on each chunk of the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a promise for when the stream has finished."
        }
      ]
    },
    {
      "name": "createHmac.toArray",
      "kind": "MethodDeclaration",
      "signature": "toArray(options?: Pick<ArrayOptions, \"signal\">): Promise<any[]>;",
      "doc": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "returns",
          "text": "a promise containing an array with the contents of the stream."
        }
      ]
    },
    {
      "name": "createHmac.some",
      "kind": "MethodDeclaration",
      "signature": "some(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Promise<boolean>;",
      "doc": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to call on each chunk of the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks."
        }
      ]
    },
    {
      "name": "createHmac.find",
      "kind": "MethodDeclaration",
      "signature": "find<T>(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T,\n            options?: ArrayOptions,\n        ): Promise<T | undefined>;",
      "doc": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to call on each chunk of the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found."
        }
      ]
    },
    {
      "name": "createHmac.every",
      "kind": "MethodDeclaration",
      "signature": "every(\n            fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Promise<boolean>;",
      "doc": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to call on each chunk of the stream. Async or not."
        },
        {
          "tagName": "returns",
          "text": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks."
        }
      ]
    },
    {
      "name": "createHmac.flatMap",
      "kind": "MethodDeclaration",
      "signature": "flatMap(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions): Readable;",
      "doc": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
        },
        {
          "tagName": "returns",
          "text": "a stream flat-mapped with the function *fn*."
        }
      ]
    },
    {
      "name": "createHmac.drop",
      "kind": "MethodDeclaration",
      "signature": "drop(limit: number, options?: Pick<ArrayOptions, \"signal\">): Readable;",
      "doc": "This method returns a new stream with the first *limit* chunks dropped from the start.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "the number of chunks to drop from the readable."
        },
        {
          "tagName": "returns",
          "text": "a stream with *limit* chunks dropped from the start."
        }
      ]
    },
    {
      "name": "createHmac.take",
      "kind": "MethodDeclaration",
      "signature": "take(limit: number, options?: Pick<ArrayOptions, \"signal\">): Readable;",
      "doc": "This method returns a new stream with the first *limit* chunks.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "the number of chunks to take from the readable."
        },
        {
          "tagName": "returns",
          "text": "a stream with *limit* chunks taken."
        }
      ]
    },
    {
      "name": "createHmac.asIndexedPairs",
      "kind": "MethodDeclaration",
      "signature": "asIndexedPairs(options?: Pick<ArrayOptions, \"signal\">): Readable;",
      "doc": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "returns",
          "text": "a stream of indexed pairs."
        }
      ]
    },
    {
      "name": "createHmac.reduce",
      "kind": "MethodDeclaration",
      "signature": "reduce<T = any>(\n            fn: (previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T,\n            initial?: undefined,\n            options?: Pick<ArrayOptions, \"signal\">,\n        ): Promise<T>;",
      "doc": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
      "tags": [
        {
          "tagName": "since",
          "text": "v17.5.0"
        },
        {
          "tagName": "param",
          "text": "a reducer function to call over every chunk in the stream. Async or not."
        },
        {
          "tagName": "param",
          "text": "the initial value to use in the reduction."
        },
        {
          "tagName": "returns",
          "text": "a promise for the final value of the reduction."
        }
      ]
    },
    {
      "name": "createHmac.destroy",
      "kind": "MethodDeclaration",
      "signature": "destroy(error?: Error): this;",
      "doc": "Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event (unless `emitClose` is set to `false`). After this call, the readable\nstream will release any internal resources and subsequent calls to `push()` will be ignored.\n\nOnce `destroy()` has been called any further calls will be a no-op and no\nfurther errors except from `_destroy()` may be emitted as `'error'`.\n\nImplementors should not override this method, but instead implement `readable._destroy()`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v8.0.0"
        },
        {
          "tagName": "param",
          "text": "Error which will be passed as payload in `'error'` event"
        }
      ]
    },
    {
      "name": "createHmac.__@asyncIterator@1275",
      "kind": "MethodDeclaration",
      "signature": "[Symbol.asyncIterator](): AsyncIterableIterator<any>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.__@asyncDispose@1277",
      "kind": "MethodDeclaration",
      "signature": "[Symbol.asyncDispose](): Promise<void>;",
      "doc": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
      "tags": [
        {
          "tagName": "since",
          "text": "v20.4.0"
        }
      ]
    },
    {
      "name": "createHmac.pipe",
      "kind": "MethodDeclaration",
      "signature": "pipe<T extends NodeJS.WritableStream>(\n            destination: T,\n            options?: {\n                end?: boolean | undefined;\n            },\n        ): T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.compose",
      "kind": "MethodDeclaration",
      "signature": "compose<T extends NodeJS.ReadableStream>(\n            stream: T | ComposeFnParam | Iterable<T> | AsyncIterable<T>,\n            options?: { signal: AbortSignal },\n        ): T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.__@captureRejectionSymbol@1308",
      "kind": "MethodDeclaration",
      "signature": "[EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.off",
      "kind": "MethodSignature",
      "signature": "off<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Alias for `emitter.removeListener()`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v10.0.0"
        }
      ]
    },
    {
      "name": "createHmac.removeAllListeners",
      "kind": "MethodSignature",
      "signature": "removeAllListeners(eventName?: Key<unknown, T>): this;",
      "doc": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "createHmac.setMaxListeners",
      "kind": "MethodSignature",
      "signature": "setMaxListeners(n: number): this;",
      "doc": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.5"
        }
      ]
    },
    {
      "name": "createHmac.getMaxListeners",
      "kind": "MethodSignature",
      "signature": "getMaxListeners(): number;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v1.0.0"
        }
      ]
    },
    {
      "name": "createHmac.listeners",
      "kind": "MethodSignature",
      "signature": "listeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;",
      "doc": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "createHmac.rawListeners",
      "kind": "MethodSignature",
      "signature": "rawListeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;",
      "doc": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.4.0"
        }
      ]
    },
    {
      "name": "createHmac.listenerCount",
      "kind": "MethodSignature",
      "signature": "listenerCount<K>(eventName: Key<K, T>, listener?: Listener2<K, T>): number;",
      "doc": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
      "tags": [
        {
          "tagName": "since",
          "text": "v3.2.0"
        },
        {
          "tagName": "param",
          "text": "The name of the event being listened for"
        },
        {
          "tagName": "param",
          "text": "The event handler function"
        }
      ]
    },
    {
      "name": "createHmac.eventNames",
      "kind": "MethodSignature",
      "signature": "eventNames(): Array<(string | symbol) & Key2<unknown, T>>;",
      "doc": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync",
      "kind": "FunctionDeclaration",
      "signature": "function pbkdf2Sync(\n        password: BinaryLike,\n        salt: BinaryLike,\n        iterations: number,\n        keylen: number,\n        digest: string,\n    ): Buffer;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.3"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?: number, end?: number): Buffer<ArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nThis method is not compatible with the `Uint8Array.prototype.slice()`,\nwhich is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconst copiedBuf = Uint8Array.prototype.slice.call(buf);\ncopiedBuf[0]++;\nconsole.log(copiedBuf.toString());\n// Prints: cuffer\n\nconsole.log(buf.toString());\n// Prints: buffer\n\n// With buf.slice(), the original buffer is modified.\nconst notReallyCopiedBuf = buf.slice();\nnotReallyCopiedBuf[0]++;\nconsole.log(notReallyCopiedBuf.toString());\n// Prints: cuffer\nconsole.log(buf.toString());\n// Also prints: cuffer (!)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.0"
        },
        {
          "tagName": "deprecated",
          "text": "Use `subarray` instead."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(start?: number, end?: number): Buffer<TArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nSpecifying `end` greater than `buf.length` will return the same result as\nthat of `end` equal to `buf.length`.\n\nThis method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).\n\nModifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.subarray(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: !bc\n```\n\nSpecifying negative indexes causes the slice to be generated relative to the\nend of `buf` rather than the beginning.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.subarray(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.subarray(0, 5).)\n\nconsole.log(buf.subarray(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.subarray(0, 4).)\n\nconsole.log(buf.subarray(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.subarray(1, 4).)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v3.0.0"
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.write",
      "kind": "MethodSignature",
      "signature": "write(string: string, encoding?: BufferEncoding): number;",
      "doc": "Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did\nnot contain enough space to fit the entire string, only part of `string` will be\nwritten. However, partially encoded characters will not be written.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(256);\n\nconst len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n\nconsole.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n// Prints: 12 bytes: ½ + ¼ = ¾\n\nconst buffer = Buffer.alloc(10);\n\nconst length = buffer.write('abcd', 8);\n\nconsole.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);\n// Prints: 2 bytes : ab\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "String to write to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write `string`."
        },
        {
          "tagName": "param",
          "text": "Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`)."
        },
        {
          "tagName": "param",
          "text": "The character encoding of `string`."
        },
        {
          "tagName": "return",
          "text": "Number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.toString",
      "kind": "MethodSignature",
      "signature": "toString(encoding?: BufferEncoding, start?: number, end?: number): string;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "The character encoding to use."
        },
        {
          "tagName": "param",
          "text": "The byte offset to start decoding at."
        },
        {
          "tagName": "param",
          "text": "The byte offset to stop decoding at (not inclusive)."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.toJSON",
      "kind": "MethodSignature",
      "signature": "toJSON(): {\n                type: \"Buffer\";\n                data: number[];\n            };",
      "doc": "Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls\nthis function when stringifying a `Buffer` instance.\n\n`Buffer.from()` accepts objects in the format returned from this method.\nIn particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value &#x26;&#x26; value.type === 'Buffer' ?\n    Buffer.from(value) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: <Buffer 01 02 03 04 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.2"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.equals",
      "kind": "MethodSignature",
      "signature": "equals(otherBuffer: Uint8Array): boolean;",
      "doc": "Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.compare",
      "kind": "MethodSignature",
      "signature": "compare(\n                target: Uint8Array,\n                targetStart?: number,\n                targetEnd?: number,\n                sourceStart?: number,\n                sourceEnd?: number,\n            ): -1 | 0 | 1;",
      "doc": "Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.\nComparison is based on the actual sequence of bytes in each `Buffer`.\n\n* `0` is returned if `target` is the same as `buf`\n* `1` is returned if `target` should come _before_`buf` when sorted.\n* `-1` is returned if `target` should come _after_`buf` when sorted.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]\n// (This result is equal to: [buf1, buf3, buf2].)\n```\n\nThe optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used to limit the comparison to specific ranges within `target` and `buf` respectively.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n```\n\n`ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`, `targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to end comparison (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to end comparison (not inclusive)."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.copy",
      "kind": "MethodSignature",
      "signature": "copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;",
      "doc": "Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.\n\n[`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available\nfor all TypedArrays, including Node.js `Buffer`s, although it takes\ndifferent function arguments.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.\nbuf1.copy(buf2, 8, 16, 20);\n// This is equivalent to:\n// buf2.set(buf1.subarray(16, 20), 8);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n```\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} to copy into."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin writing."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` from which to begin copying."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to stop copying (not inclusive)."
        },
        {
          "tagName": "return",
          "text": "The number of bytes copied."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeBigInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64BE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeBigInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64LE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\nThis function is also available under the `writeBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64BE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de ca fa fe ca ce fa de>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeBigUint64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64BE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64LE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de fa ce ca fe fa ca de>\n```\n\nThis function is also available under the `writeBigUint64LE` alias.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeBigUint64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64LE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUIntLE",
      "kind": "MethodSignature",
      "signature": "writeUIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUintLE",
      "kind": "MethodSignature",
      "signature": "writeUintLE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUIntBE",
      "kind": "MethodSignature",
      "signature": "writeUIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUintBE",
      "kind": "MethodSignature",
      "signature": "writeUintBE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeIntLE",
      "kind": "MethodSignature",
      "signature": "writeIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than a signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeIntBE",
      "kind": "MethodSignature",
      "signature": "writeIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a\nsigned integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64BE(offset?: number): bigint;",
      "doc": "Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64BE(0));\n// Prints: 4294967295n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readBigUint64BE",
      "kind": "MethodSignature",
      "signature": "readBigUint64BE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64LE(offset?: number): bigint;",
      "doc": "Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64LE(0));\n// Prints: 18446744069414584320n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readBigUint64LE",
      "kind": "MethodSignature",
      "signature": "readBigUint64LE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readBigInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigInt64BE(offset?: number): bigint;",
      "doc": "Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readBigInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigInt64LE(offset?: number): bigint;",
      "doc": "Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUIntLE",
      "kind": "MethodSignature",
      "signature": "readUIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned, little-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUintLE",
      "kind": "MethodSignature",
      "signature": "readUintLE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUIntBE",
      "kind": "MethodSignature",
      "signature": "readUIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned big-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUintBE",
      "kind": "MethodSignature",
      "signature": "readUintBE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readIntLE",
      "kind": "MethodSignature",
      "signature": "readIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a little-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readIntBE",
      "kind": "MethodSignature",
      "signature": "readIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a big-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUInt8",
      "kind": "MethodSignature",
      "signature": "readUInt8(offset?: number): number;",
      "doc": "Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUint8",
      "kind": "MethodSignature",
      "signature": "readUint8(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUInt16LE",
      "kind": "MethodSignature",
      "signature": "readUInt16LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 16-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUint16LE",
      "kind": "MethodSignature",
      "signature": "readUint16LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUInt16BE",
      "kind": "MethodSignature",
      "signature": "readUInt16BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUint16BE",
      "kind": "MethodSignature",
      "signature": "readUint16BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUInt32LE",
      "kind": "MethodSignature",
      "signature": "readUInt32LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUint32LE",
      "kind": "MethodSignature",
      "signature": "readUint32LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUInt32BE",
      "kind": "MethodSignature",
      "signature": "readUInt32BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readUint32BE",
      "kind": "MethodSignature",
      "signature": "readUint32BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readInt8",
      "kind": "MethodSignature",
      "signature": "readInt8(offset?: number): number;",
      "doc": "Reads a signed 8-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readInt16LE",
      "kind": "MethodSignature",
      "signature": "readInt16LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readInt16BE",
      "kind": "MethodSignature",
      "signature": "readInt16BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readInt32LE",
      "kind": "MethodSignature",
      "signature": "readInt32LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readInt32BE",
      "kind": "MethodSignature",
      "signature": "readInt32BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readFloatLE",
      "kind": "MethodSignature",
      "signature": "readFloatLE(offset?: number): number;",
      "doc": "Reads a 32-bit, little-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readFloatBE",
      "kind": "MethodSignature",
      "signature": "readFloatBE(offset?: number): number;",
      "doc": "Reads a 32-bit, big-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readDoubleLE",
      "kind": "MethodSignature",
      "signature": "readDoubleLE(offset?: number): number;",
      "doc": "Reads a 64-bit, little-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.readDoubleBE",
      "kind": "MethodSignature",
      "signature": "readDoubleBE(offset?: number): number;",
      "doc": "Reads a 64-bit, big-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.reverse",
      "kind": "MethodSignature",
      "signature": "reverse(): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.swap16",
      "kind": "MethodSignature",
      "signature": "swap16(): this;",
      "doc": "Interprets `buf` as an array of unsigned 16-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: <Buffer 02 01 04 03 06 05 08 07>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```\n\nOne convenient use of `buf.swap16()` is to perform a fast in-place conversion\nbetween UTF-16 little-endian and UTF-16 big-endian:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\nbuf.swap16(); // Convert to big-endian UTF-16 text.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.swap32",
      "kind": "MethodSignature",
      "signature": "swap32(): this;",
      "doc": "Interprets `buf` as an array of unsigned 32-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: <Buffer 04 03 02 01 08 07 06 05>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.swap64",
      "kind": "MethodSignature",
      "signature": "swap64(): this;",
      "doc": "Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.\nThrows `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.3.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUInt8",
      "kind": "MethodSignature",
      "signature": "writeUInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a\nvalid unsigned 8-bit integer. Behavior is undefined when `value` is anything\nother than an unsigned 8-bit integer.\n\nThis function is also available under the `writeUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: <Buffer 03 04 23 42>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUint8",
      "kind": "MethodSignature",
      "signature": "writeUint8(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUInt16LE",
      "kind": "MethodSignature",
      "signature": "writeUInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 16-bit integer.\n\nThis function is also available under the `writeUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer ad de ef be>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUint16LE",
      "kind": "MethodSignature",
      "signature": "writeUint16LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUInt16BE",
      "kind": "MethodSignature",
      "signature": "writeUInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 16-bit integer.\n\nThis function is also available under the `writeUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer de ad be ef>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUint16BE",
      "kind": "MethodSignature",
      "signature": "writeUint16BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUInt32LE",
      "kind": "MethodSignature",
      "signature": "writeUInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 32-bit integer.\n\nThis function is also available under the `writeUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer ce fa ed fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUint32LE",
      "kind": "MethodSignature",
      "signature": "writeUint32LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUInt32BE",
      "kind": "MethodSignature",
      "signature": "writeUInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 32-bit integer.\n\nThis function is also available under the `writeUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer fe ed fa ce>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeUint32BE",
      "kind": "MethodSignature",
      "signature": "writeUint32BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeInt8",
      "kind": "MethodSignature",
      "signature": "writeInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a valid\nsigned 8-bit integer. Behavior is undefined when `value` is anything other than\na signed 8-bit integer.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: <Buffer 02 fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeInt16LE",
      "kind": "MethodSignature",
      "signature": "writeInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16LE(0x0304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 04 03>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeInt16BE",
      "kind": "MethodSignature",
      "signature": "writeInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16BE(0x0102, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeInt32LE",
      "kind": "MethodSignature",
      "signature": "writeInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32LE(0x05060708, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeInt32BE",
      "kind": "MethodSignature",
      "signature": "writeInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32BE(0x01020304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeFloatLE",
      "kind": "MethodSignature",
      "signature": "writeFloatLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer bb fe 4a 4f>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeFloatBE",
      "kind": "MethodSignature",
      "signature": "writeFloatBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 4f 4a fe bb>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeDoubleLE",
      "kind": "MethodSignature",
      "signature": "writeDoubleLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.writeDoubleBE",
      "kind": "MethodSignature",
      "signature": "writeDoubleBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 40 5e dd 2f 1a 9f be 77>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.fill",
      "kind": "MethodSignature",
      "signature": "fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;",
      "doc": "Fills `buf` with the specified `value`. If the `offset` and `end` are not given,\nthe entire `buf` will be filled:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with the ASCII character 'h'.\n\nconst b = Buffer.allocUnsafe(50).fill('h');\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n\n// Fill a buffer with empty string\nconst c = Buffer.allocUnsafe(5).fill('');\n\nconsole.log(c.fill(''));\n// Prints: <Buffer 00 00 00 00 00>\n```\n\n`value` is coerced to a `uint32` value if it is not a string, `Buffer`, or\ninteger. If the resulting integer is greater than `255` (decimal), `buf` will be\nfilled with `value &#x26; 255`.\n\nIf the final write of a `fill()` operation falls on a multi-byte character,\nthen only the bytes of that character that fit into `buf` are written:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with character that takes up two bytes in UTF-8.\n\nconsole.log(Buffer.allocUnsafe(5).fill('\\u0222'));\n// Prints: <Buffer c8 a2 c8 a2 c8>\n```\n\nIf `value` contains invalid characters, it is truncated; if no valid\nfill data remains, an exception is thrown:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill('a'));\n// Prints: <Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Throws an exception.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to fill `buf`."
        },
        {
          "tagName": "param",
          "text": "Where to stop filling `buf` (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The encoding for `value` if `value` is a string."
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "If `value` is:\n\n* a string, `value` is interpreted according to the character encoding in `encoding`.\n* a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.\nTo compare a partial `Buffer`, use `buf.subarray`.\n* a number, `value` will be interpreted as an unsigned 8-bit integer\nvalue between `0` and `255`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.indexOf('this'));\n// Prints: 0\nconsole.log(buf.indexOf('is'));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from('a buffer')));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.indexOf(Buffer.from('a buffer example')));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n// Prints: 6\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. If the result\nof coercion is `NaN` or `0`, then the entire buffer will be searched. This\nbehavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer` and `byteOffset` is less\nthan `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v1.5.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "Identical to `buf.indexOf()`, except the last occurrence of `value` is found\nrather than the first occurrence.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this buffer is a buffer');\n\nconsole.log(buf.lastIndexOf('this'));\n// Prints: 0\nconsole.log(buf.lastIndexOf('buffer'));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from('buffer')));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.lastIndexOf(Buffer.from('yolo')));\n// Prints: -1\nconsole.log(buf.lastIndexOf('buffer', 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf('buffer', 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n// Prints: 4\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. Any arguments\nthat coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.\nThis behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n\n// Passing a byteOffset that coerces to 0.\n// Prints: -1, equivalent to passing 0.\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.includes",
      "kind": "MethodSignature",
      "signature": "includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;",
      "doc": "Equivalent to `buf.indexOf() !== -1`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.includes('this'));\n// Prints: true\nconsole.log(buf.includes('is'));\n// Prints: true\nconsole.log(buf.includes(Buffer.from('a buffer')));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for 'a')\nconsole.log(buf.includes(Buffer.from('a buffer example')));\n// Prints: false\nconsole.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes('this', 4));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.3.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is its encoding."
        },
        {
          "tagName": "return",
          "text": "`true` if `value` was found in `buf`, `false` otherwise."
        }
      ]
    },
    {
      "name": "pbkdf2Sync.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "FunctionDeclaration",
      "signature": "function randomBytes(size: number): Buffer;",
      "doc": "Generates cryptographically strong pseudorandom data. The `size` argument\nis a number indicating the number of bytes to generate.\n\nIf a `callback` function is provided, the bytes are generated asynchronously\nand the `callback` function is invoked with two arguments: `err` and `buf`.\nIf an error occurs, `err` will be an `Error` object; otherwise it is `null`. The `buf` argument is a `Buffer` containing the generated bytes.\n\n```js\n// Asynchronous\nconst {\n  randomBytes,\n} = await import('node:crypto');\n\nrandomBytes(256, (err, buf) => {\n  if (err) throw err;\n  console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`);\n});\n```\n\nIf the `callback` function is not provided, the random bytes are generated\nsynchronously and returned as a `Buffer`. An error will be thrown if\nthere is a problem generating the bytes.\n\n```js\n// Synchronous\nconst {\n  randomBytes,\n} = await import('node:crypto');\n\nconst buf = randomBytes(256);\nconsole.log(\n  `${buf.length} bytes of random data: ${buf.toString('hex')}`);\n```\n\nThe `crypto.randomBytes()` method will not complete until there is\nsufficient entropy available.\nThis should normally never take longer than a few milliseconds. The only time\nwhen generating the random bytes may conceivably block for a longer period of\ntime is right after boot, when the whole system is still low on entropy.\n\nThis API uses libuv's threadpool, which can have surprising and\nnegative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.\n\nThe asynchronous version of `crypto.randomBytes()` is carried out in a single\nthreadpool request. To minimize threadpool task length variation, partition\nlarge `randomBytes` requests when doing so as part of fulfilling a client\nrequest.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.8"
        },
        {
          "tagName": "param",
          "text": "The number of bytes to generate. The `size` must not be larger than `2**31 - 1`."
        },
        {
          "tagName": "return",
          "text": "if the `callback` function is not provided."
        }
      ]
    },
    {
      "name": "randomBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?: number, end?: number): Buffer<ArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nThis method is not compatible with the `Uint8Array.prototype.slice()`,\nwhich is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconst copiedBuf = Uint8Array.prototype.slice.call(buf);\ncopiedBuf[0]++;\nconsole.log(copiedBuf.toString());\n// Prints: cuffer\n\nconsole.log(buf.toString());\n// Prints: buffer\n\n// With buf.slice(), the original buffer is modified.\nconst notReallyCopiedBuf = buf.slice();\nnotReallyCopiedBuf[0]++;\nconsole.log(notReallyCopiedBuf.toString());\n// Prints: cuffer\nconsole.log(buf.toString());\n// Also prints: cuffer (!)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.0"
        },
        {
          "tagName": "deprecated",
          "text": "Use `subarray` instead."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "randomBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(start?: number, end?: number): Buffer<TArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nSpecifying `end` greater than `buf.length` will return the same result as\nthat of `end` equal to `buf.length`.\n\nThis method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).\n\nModifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.subarray(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: !bc\n```\n\nSpecifying negative indexes causes the slice to be generated relative to the\nend of `buf` rather than the beginning.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.subarray(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.subarray(0, 5).)\n\nconsole.log(buf.subarray(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.subarray(0, 4).)\n\nconsole.log(buf.subarray(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.subarray(1, 4).)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v3.0.0"
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "randomBytes.write",
      "kind": "MethodSignature",
      "signature": "write(string: string, encoding?: BufferEncoding): number;",
      "doc": "Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did\nnot contain enough space to fit the entire string, only part of `string` will be\nwritten. However, partially encoded characters will not be written.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(256);\n\nconst len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n\nconsole.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n// Prints: 12 bytes: ½ + ¼ = ¾\n\nconst buffer = Buffer.alloc(10);\n\nconst length = buffer.write('abcd', 8);\n\nconsole.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);\n// Prints: 2 bytes : ab\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "String to write to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write `string`."
        },
        {
          "tagName": "param",
          "text": "Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`)."
        },
        {
          "tagName": "param",
          "text": "The character encoding of `string`."
        },
        {
          "tagName": "return",
          "text": "Number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString(encoding?: BufferEncoding, start?: number, end?: number): string;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "The character encoding to use."
        },
        {
          "tagName": "param",
          "text": "The byte offset to start decoding at."
        },
        {
          "tagName": "param",
          "text": "The byte offset to stop decoding at (not inclusive)."
        }
      ]
    },
    {
      "name": "randomBytes.toJSON",
      "kind": "MethodSignature",
      "signature": "toJSON(): {\n                type: \"Buffer\";\n                data: number[];\n            };",
      "doc": "Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls\nthis function when stringifying a `Buffer` instance.\n\n`Buffer.from()` accepts objects in the format returned from this method.\nIn particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value &#x26;&#x26; value.type === 'Buffer' ?\n    Buffer.from(value) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: <Buffer 01 02 03 04 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.2"
        }
      ]
    },
    {
      "name": "randomBytes.equals",
      "kind": "MethodSignature",
      "signature": "equals(otherBuffer: Uint8Array): boolean;",
      "doc": "Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        }
      ]
    },
    {
      "name": "randomBytes.compare",
      "kind": "MethodSignature",
      "signature": "compare(\n                target: Uint8Array,\n                targetStart?: number,\n                targetEnd?: number,\n                sourceStart?: number,\n                sourceEnd?: number,\n            ): -1 | 0 | 1;",
      "doc": "Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.\nComparison is based on the actual sequence of bytes in each `Buffer`.\n\n* `0` is returned if `target` is the same as `buf`\n* `1` is returned if `target` should come _before_`buf` when sorted.\n* `-1` is returned if `target` should come _after_`buf` when sorted.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]\n// (This result is equal to: [buf1, buf3, buf2].)\n```\n\nThe optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used to limit the comparison to specific ranges within `target` and `buf` respectively.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n```\n\n`ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`, `targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to end comparison (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to end comparison (not inclusive)."
        }
      ]
    },
    {
      "name": "randomBytes.copy",
      "kind": "MethodSignature",
      "signature": "copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;",
      "doc": "Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.\n\n[`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available\nfor all TypedArrays, including Node.js `Buffer`s, although it takes\ndifferent function arguments.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.\nbuf1.copy(buf2, 8, 16, 20);\n// This is equivalent to:\n// buf2.set(buf1.subarray(16, 20), 8);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n```\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} to copy into."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin writing."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` from which to begin copying."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to stop copying (not inclusive)."
        },
        {
          "tagName": "return",
          "text": "The number of bytes copied."
        }
      ]
    },
    {
      "name": "randomBytes.writeBigInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64BE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeBigInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64LE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\nThis function is also available under the `writeBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64BE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de ca fa fe ca ce fa de>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeBigUint64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64BE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64LE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de fa ce ca fe fa ca de>\n```\n\nThis function is also available under the `writeBigUint64LE` alias.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeBigUint64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64LE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeUIntLE",
      "kind": "MethodSignature",
      "signature": "writeUIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeUintLE",
      "kind": "MethodSignature",
      "signature": "writeUintLE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeUIntBE",
      "kind": "MethodSignature",
      "signature": "writeUIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeUintBE",
      "kind": "MethodSignature",
      "signature": "writeUintBE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeIntLE",
      "kind": "MethodSignature",
      "signature": "writeIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than a signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeIntBE",
      "kind": "MethodSignature",
      "signature": "writeIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a\nsigned integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.readBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64BE(offset?: number): bigint;",
      "doc": "Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64BE(0));\n// Prints: 4294967295n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "randomBytes.readBigUint64BE",
      "kind": "MethodSignature",
      "signature": "readBigUint64BE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64LE(offset?: number): bigint;",
      "doc": "Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64LE(0));\n// Prints: 18446744069414584320n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "randomBytes.readBigUint64LE",
      "kind": "MethodSignature",
      "signature": "readBigUint64LE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readBigInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigInt64BE(offset?: number): bigint;",
      "doc": "Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "randomBytes.readBigInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigInt64LE(offset?: number): bigint;",
      "doc": "Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "randomBytes.readUIntLE",
      "kind": "MethodSignature",
      "signature": "readUIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned, little-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "randomBytes.readUintLE",
      "kind": "MethodSignature",
      "signature": "readUintLE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readUIntBE",
      "kind": "MethodSignature",
      "signature": "readUIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned big-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "randomBytes.readUintBE",
      "kind": "MethodSignature",
      "signature": "readUintBE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readIntLE",
      "kind": "MethodSignature",
      "signature": "readIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a little-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "randomBytes.readIntBE",
      "kind": "MethodSignature",
      "signature": "readIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a big-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "randomBytes.readUInt8",
      "kind": "MethodSignature",
      "signature": "readUInt8(offset?: number): number;",
      "doc": "Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "randomBytes.readUint8",
      "kind": "MethodSignature",
      "signature": "readUint8(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readUInt16LE",
      "kind": "MethodSignature",
      "signature": "readUInt16LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 16-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "randomBytes.readUint16LE",
      "kind": "MethodSignature",
      "signature": "readUint16LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readUInt16BE",
      "kind": "MethodSignature",
      "signature": "readUInt16BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "randomBytes.readUint16BE",
      "kind": "MethodSignature",
      "signature": "readUint16BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readUInt32LE",
      "kind": "MethodSignature",
      "signature": "readUInt32LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "randomBytes.readUint32LE",
      "kind": "MethodSignature",
      "signature": "readUint32LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readUInt32BE",
      "kind": "MethodSignature",
      "signature": "readUInt32BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "randomBytes.readUint32BE",
      "kind": "MethodSignature",
      "signature": "readUint32BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.readInt8",
      "kind": "MethodSignature",
      "signature": "readInt8(offset?: number): number;",
      "doc": "Reads a signed 8-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "randomBytes.readInt16LE",
      "kind": "MethodSignature",
      "signature": "readInt16LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "randomBytes.readInt16BE",
      "kind": "MethodSignature",
      "signature": "readInt16BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "randomBytes.readInt32LE",
      "kind": "MethodSignature",
      "signature": "readInt32LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "randomBytes.readInt32BE",
      "kind": "MethodSignature",
      "signature": "readInt32BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "randomBytes.readFloatLE",
      "kind": "MethodSignature",
      "signature": "readFloatLE(offset?: number): number;",
      "doc": "Reads a 32-bit, little-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "randomBytes.readFloatBE",
      "kind": "MethodSignature",
      "signature": "readFloatBE(offset?: number): number;",
      "doc": "Reads a 32-bit, big-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "randomBytes.readDoubleLE",
      "kind": "MethodSignature",
      "signature": "readDoubleLE(offset?: number): number;",
      "doc": "Reads a 64-bit, little-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "randomBytes.readDoubleBE",
      "kind": "MethodSignature",
      "signature": "readDoubleBE(offset?: number): number;",
      "doc": "Reads a 64-bit, big-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "randomBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse(): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.swap16",
      "kind": "MethodSignature",
      "signature": "swap16(): this;",
      "doc": "Interprets `buf` as an array of unsigned 16-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: <Buffer 02 01 04 03 06 05 08 07>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```\n\nOne convenient use of `buf.swap16()` is to perform a fast in-place conversion\nbetween UTF-16 little-endian and UTF-16 big-endian:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\nbuf.swap16(); // Convert to big-endian UTF-16 text.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "randomBytes.swap32",
      "kind": "MethodSignature",
      "signature": "swap32(): this;",
      "doc": "Interprets `buf` as an array of unsigned 32-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: <Buffer 04 03 02 01 08 07 06 05>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "randomBytes.swap64",
      "kind": "MethodSignature",
      "signature": "swap64(): this;",
      "doc": "Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.\nThrows `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.3.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "randomBytes.writeUInt8",
      "kind": "MethodSignature",
      "signature": "writeUInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a\nvalid unsigned 8-bit integer. Behavior is undefined when `value` is anything\nother than an unsigned 8-bit integer.\n\nThis function is also available under the `writeUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: <Buffer 03 04 23 42>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeUint8",
      "kind": "MethodSignature",
      "signature": "writeUint8(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeUInt16LE",
      "kind": "MethodSignature",
      "signature": "writeUInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 16-bit integer.\n\nThis function is also available under the `writeUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer ad de ef be>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeUint16LE",
      "kind": "MethodSignature",
      "signature": "writeUint16LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeUInt16BE",
      "kind": "MethodSignature",
      "signature": "writeUInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 16-bit integer.\n\nThis function is also available under the `writeUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer de ad be ef>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeUint16BE",
      "kind": "MethodSignature",
      "signature": "writeUint16BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeUInt32LE",
      "kind": "MethodSignature",
      "signature": "writeUInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 32-bit integer.\n\nThis function is also available under the `writeUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer ce fa ed fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeUint32LE",
      "kind": "MethodSignature",
      "signature": "writeUint32LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeUInt32BE",
      "kind": "MethodSignature",
      "signature": "writeUInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 32-bit integer.\n\nThis function is also available under the `writeUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer fe ed fa ce>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeUint32BE",
      "kind": "MethodSignature",
      "signature": "writeUint32BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "randomBytes.writeInt8",
      "kind": "MethodSignature",
      "signature": "writeInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a valid\nsigned 8-bit integer. Behavior is undefined when `value` is anything other than\na signed 8-bit integer.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: <Buffer 02 fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeInt16LE",
      "kind": "MethodSignature",
      "signature": "writeInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16LE(0x0304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 04 03>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeInt16BE",
      "kind": "MethodSignature",
      "signature": "writeInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16BE(0x0102, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeInt32LE",
      "kind": "MethodSignature",
      "signature": "writeInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32LE(0x05060708, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeInt32BE",
      "kind": "MethodSignature",
      "signature": "writeInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32BE(0x01020304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeFloatLE",
      "kind": "MethodSignature",
      "signature": "writeFloatLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer bb fe 4a 4f>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeFloatBE",
      "kind": "MethodSignature",
      "signature": "writeFloatBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 4f 4a fe bb>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeDoubleLE",
      "kind": "MethodSignature",
      "signature": "writeDoubleLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.writeDoubleBE",
      "kind": "MethodSignature",
      "signature": "writeDoubleBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 40 5e dd 2f 1a 9f be 77>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "randomBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;",
      "doc": "Fills `buf` with the specified `value`. If the `offset` and `end` are not given,\nthe entire `buf` will be filled:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with the ASCII character 'h'.\n\nconst b = Buffer.allocUnsafe(50).fill('h');\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n\n// Fill a buffer with empty string\nconst c = Buffer.allocUnsafe(5).fill('');\n\nconsole.log(c.fill(''));\n// Prints: <Buffer 00 00 00 00 00>\n```\n\n`value` is coerced to a `uint32` value if it is not a string, `Buffer`, or\ninteger. If the resulting integer is greater than `255` (decimal), `buf` will be\nfilled with `value &#x26; 255`.\n\nIf the final write of a `fill()` operation falls on a multi-byte character,\nthen only the bytes of that character that fit into `buf` are written:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with character that takes up two bytes in UTF-8.\n\nconsole.log(Buffer.allocUnsafe(5).fill('\\u0222'));\n// Prints: <Buffer c8 a2 c8 a2 c8>\n```\n\nIf `value` contains invalid characters, it is truncated; if no valid\nfill data remains, an exception is thrown:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill('a'));\n// Prints: <Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Throws an exception.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to fill `buf`."
        },
        {
          "tagName": "param",
          "text": "Where to stop filling `buf` (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The encoding for `value` if `value` is a string."
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "randomBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "If `value` is:\n\n* a string, `value` is interpreted according to the character encoding in `encoding`.\n* a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.\nTo compare a partial `Buffer`, use `buf.subarray`.\n* a number, `value` will be interpreted as an unsigned 8-bit integer\nvalue between `0` and `255`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.indexOf('this'));\n// Prints: 0\nconsole.log(buf.indexOf('is'));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from('a buffer')));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.indexOf(Buffer.from('a buffer example')));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n// Prints: 6\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. If the result\nof coercion is `NaN` or `0`, then the entire buffer will be searched. This\nbehavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer` and `byteOffset` is less\nthan `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v1.5.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "randomBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "Identical to `buf.indexOf()`, except the last occurrence of `value` is found\nrather than the first occurrence.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this buffer is a buffer');\n\nconsole.log(buf.lastIndexOf('this'));\n// Prints: 0\nconsole.log(buf.lastIndexOf('buffer'));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from('buffer')));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.lastIndexOf(Buffer.from('yolo')));\n// Prints: -1\nconsole.log(buf.lastIndexOf('buffer', 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf('buffer', 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n// Prints: 4\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. Any arguments\nthat coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.\nThis behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n\n// Passing a byteOffset that coerces to 0.\n// Prints: -1, equivalent to passing 0.\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "randomBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;",
      "doc": "Equivalent to `buf.indexOf() !== -1`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.includes('this'));\n// Prints: true\nconsole.log(buf.includes('is'));\n// Prints: true\nconsole.log(buf.includes(Buffer.from('a buffer')));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for 'a')\nconsole.log(buf.includes(Buffer.from('a buffer example')));\n// Prints: false\nconsole.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes('this', 4));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.3.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is its encoding."
        },
        {
          "tagName": "return",
          "text": "`true` if `value` was found in `buf`, `false` otherwise."
        }
      ]
    },
    {
      "name": "randomBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "FunctionDeclaration",
      "signature": "function randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash",
      "kind": "FunctionDeclaration",
      "signature": "export function createHash(algo: string): CryptoHasher {\n    switch (algo) {\n        case \"sha256\": return sha256.create();\n        case \"sha512\": return sha512.create();\n    }\n    assertArgument(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.update",
      "kind": "MethodSignature",
      "signature": "update(data: Uint8Array): CryptoHasher;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHash.digest",
      "kind": "MethodSignature",
      "signature": "digest(): Uint8Array;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac",
      "kind": "FunctionDeclaration",
      "signature": "export function createHmac(_algo: string, key: Uint8Array): CryptoHasher {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n    return hmac.create(algo, key);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.update",
      "kind": "MethodSignature",
      "signature": "update(data: Uint8Array): CryptoHasher;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHmac.digest",
      "kind": "MethodSignature",
      "signature": "digest(): Uint8Array;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync",
      "kind": "FunctionDeclaration",
      "signature": "export function pbkdf2Sync(password: Uint8Array, salt: Uint8Array, iterations: number, keylen: number, _algo: \"sha256\" | \"sha512\"): Uint8Array {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n    return pbkdf2(algo, pas",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "pbkdf2Sync.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "randomBytes",
      "kind": "FunctionDeclaration",
      "signature": "export function randomBytes(length: number): Uint8Array {\n    assert(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"randomBytes\" });\n\n    assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"len",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomBytes.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "CryptoHasher",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CryptoHasher {\n    update(data: Uint8Array): CryptoHasher;\n    digest(): Uint8Array;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EventLog",
      "kind": "ClassDeclaration",
      "signature": "export class EventLog extends Log {\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The matching event.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    readonly args",
      "doc": "An **EventLog** contains additional properties parsed from the [[Log]].",
      "tags": []
    },
    {
      "name": "UndecodedEventLog",
      "kind": "ClassDeclaration",
      "signature": "export class UndecodedEventLog extends Log {\n\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    readonly error!: Error;\n\n    /**\n     * @_ignore:\n     */\n    constructor(log: Log, error: Error) {\n        super(log, log.provider);\n        defineProperties<UndecodedEventLo",
      "doc": "An **EventLog** contains additional properties parsed from the [[Log]].",
      "tags": []
    },
    {
      "name": "ContractTransactionReceipt",
      "kind": "ClassDeclaration",
      "signature": "export class ContractTransactionReceipt extends TransactionReceipt {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionReceipt) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  The",
      "doc": "A **ContractTransactionReceipt** includes the parsed logs from a\n[[TransactionReceipt]].",
      "tags": []
    },
    {
      "name": "ContractTransactionResponse",
      "kind": "ClassDeclaration",
      "signature": "export class ContractTransactionResponse extends TransactionResponse {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionResponse) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  ",
      "doc": "A **ContractTransactionResponse** will return a\n[[ContractTransactionReceipt]] when waited on.",
      "tags": []
    },
    {
      "name": "ContractUnknownEventPayload",
      "kind": "ClassDeclaration",
      "signature": "export  class ContractUnknownEventPayload extends EventPayload<ContractEventName> {\n    /**\n     *  The log with no matching events.\n     */\n    readonly log!: Log;\n\n    /**\n     *  @_event:\n     */\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, log: Lo",
      "doc": "A **ContractUnknownEventPayload** is included as the last parameter to\nContract Events when the event does not match any events in the ABI.",
      "tags": []
    },
    {
      "name": "ContractEventPayload",
      "kind": "ClassDeclaration",
      "signature": "export class ContractEventPayload extends ContractUnknownEventPayload {\n\n    /**\n     *  The matching event.\n     */\n    declare readonly fragment: EventFragment;\n\n    /**\n     *  The log, with parsed properties.\n     */\n    declare readonly log: EventLog;\n\n    /**\n     *  The parsed arguments passe",
      "doc": "A **ContractEventPayload** is included as the last parameter to\nContract Events when the event is known.",
      "tags": []
    },
    {
      "name": "ContractEventName",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractEventName = string | ContractEvent | TopicFilter | DeferredTopicFilter;",
      "doc": "The name for an event used for subscribing to Contract events.\n\n**``string``** - An event by name. The event must be non-ambiguous.\nThe parameters will be dereferenced when passed into the listener.\n\n[[ContractEvent]] - A filter from the ``contract.filters``, which will\npass only the EventPayload as a single parameter, which includes a\n``.signature`` property that can be used to further filter the event.\n\n[[TopicFilter]] - A filter defined using the standard Ethereum API\nwhich provides the specific topic hash or topic hashes to watch for along\nwith any additional values to filter by. This will only pass a single\nparameter to the listener, the EventPayload which will include additional\ndetails to refine by, such as the event name and signature.\n\n[[DeferredTopicFilter]] - A filter created by calling a [[ContractEvent]]\nwith parameters, which will create a filter for a specific event\nsignature and dereference each parameter when calling the listener.",
      "tags": []
    },
    {
      "name": "ContractInterface",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractInterface {\n    [ name: string ]: BaseContractMethod;\n}",
      "doc": "A Contract with no method constraints.",
      "tags": []
    },
    {
      "name": "DeferredTopicFilter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DeferredTopicFilter {\n    getTopicFilter(): Promise<TopicFilter>;\n    fragment: EventFragment;\n}",
      "doc": "When creating a filter using the ``contract.filters``, this is returned.",
      "tags": []
    },
    {
      "name": "ContractTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractTransaction extends PreparedTransactionRequest {\n    /**\n     *  The target address.\n     */\n    to: string;\n\n    /**\n     *  The transaction data.\n     */\n    data: string;\n\n    /**\n     *  The from address, if any.\n     */\n    from?: string;\n}",
      "doc": "When populating a transaction this type is returned.",
      "tags": []
    },
    {
      "name": "ContractDeployTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractDeployTransaction extends Omit<ContractTransaction, \"to\"> { }",
      "doc": "A deployment transaction for a contract.",
      "tags": []
    },
    {
      "name": "Overrides",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Overrides extends Omit<TransactionRequest, \"to\" | \"data\"> { }",
      "doc": "The overrides for a contract transaction.",
      "tags": []
    },
    {
      "name": "PostfixOverrides",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PostfixOverrides<A extends Array<any>> = A | [ ...A, Overrides ];",
      "doc": "Arguments to a Contract method can always include an additional and\noptional overrides parameter.",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractMethodArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractMethodArgs<A extends Array<any>> = PostfixOverrides<{ [ I in keyof A ]-?: A[I] | Typed }>;",
      "doc": "Arguments to a Contract method can always include an additional and\noptional overrides parameter, and each parameter can optionally be\n[[Typed]].",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "BaseContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BaseContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {\n    (...args: ContractMethodArgs<A>): Promise<D>;\n\n    /**\n     *  The name of the Contract method.\n     */\n    name: string;\n\n    /**\n     *",
      "doc": "A Contract method can be called directly, or used in various ways.",
      "tags": []
    },
    {
      "name": "ContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractMethod<\n    A extends Array<any> = Array<any>,\n    R = any,\n    D extends R | ContractTransactionResponse = R | ContractTransactionResponse\n> extends BaseContractMethod<A, R, D> { }",
      "doc": "A contract method on a Contract.",
      "tags": []
    },
    {
      "name": "ConstantContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConstantContractMethod<\n    A extends Array<any>,\n    R = any\n> extends ContractMethod<A, R, R> { }",
      "doc": "A pure of view method on a Contract.",
      "tags": []
    },
    {
      "name": "ContractEventArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractEventArgs<A extends Array<any>> = { [ I in keyof A ]?: A[I] | Typed | null };",
      "doc": "Each argument of an event is nullable (to indicate matching //any//.",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractEvent",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractEvent<A extends Array<any> = Array<any>> {\n    (...args: ContractEventArgs<A>): DeferredTopicFilter;\n\n    /**\n     *  The name of the Contract event.\n     */\n    name: string;\n\n    /**\n     *  The fragment of the Contract event. This will throw on ambiguous\n     *  method na",
      "doc": "",
      "tags": []
    },
    {
      "name": "WrappedFallback",
      "kind": "InterfaceDeclaration",
      "signature": "export interface WrappedFallback {\n    (overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse>;\n\n    /**\n     *  Returns a populated transaction that can be used to perform the\n     *  fallback method.\n     *\n     *  For non-receive fallback, ``data`` may be overridden.\n  ",
      "doc": "A Fallback or Receive function on a Contract.",
      "tags": []
    },
    {
      "name": "BaseContract",
      "kind": "ClassDeclaration",
      "signature": "export class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  meth",
      "doc": "",
      "tags": []
    },
    {
      "name": "Contract",
      "kind": "ClassDeclaration",
      "signature": "export class Contract extends _ContractBase() { }",
      "doc": "A [[BaseContract]] with no type guards on its methods or events.",
      "tags": []
    },
    {
      "name": "ContractFactory",
      "kind": "ClassDeclaration",
      "signature": "export class ContractFactory<A extends Array<any> = Array<any>, I = BaseContract> {\n\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    readonly bytecode!: string;\n\n    /**\n    ",
      "doc": "A **ContractFactory** is used to deploy a Contract to the blockchain.",
      "tags": []
    },
    {
      "name": "ContractEventPayload",
      "kind": "ClassDeclaration",
      "signature": "export class ContractEventPayload extends ContractUnknownEventPayload {\n\n    /**\n     *  The matching event.\n     */\n    declare readonly fragment: EventFragment;\n\n    /**\n     *  The log, with parsed properties.\n     */\n    declare readonly log: EventLog;\n\n    /**\n     *  The parsed arguments passe",
      "doc": "A **ContractEventPayload** is included as the last parameter to\nContract Events when the event is known.",
      "tags": []
    },
    {
      "name": "ContractUnknownEventPayload",
      "kind": "ClassDeclaration",
      "signature": "export  class ContractUnknownEventPayload extends EventPayload<ContractEventName> {\n    /**\n     *  The log with no matching events.\n     */\n    readonly log!: Log;\n\n    /**\n     *  @_event:\n     */\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, log: Lo",
      "doc": "A **ContractUnknownEventPayload** is included as the last parameter to\nContract Events when the event does not match any events in the ABI.",
      "tags": []
    },
    {
      "name": "ContractTransactionReceipt",
      "kind": "ClassDeclaration",
      "signature": "export class ContractTransactionReceipt extends TransactionReceipt {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionReceipt) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  The",
      "doc": "A **ContractTransactionReceipt** includes the parsed logs from a\n[[TransactionReceipt]].",
      "tags": []
    },
    {
      "name": "ContractTransactionResponse",
      "kind": "ClassDeclaration",
      "signature": "export class ContractTransactionResponse extends TransactionResponse {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionResponse) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  ",
      "doc": "A **ContractTransactionResponse** will return a\n[[ContractTransactionReceipt]] when waited on.",
      "tags": []
    },
    {
      "name": "EventLog",
      "kind": "ClassDeclaration",
      "signature": "export class EventLog extends Log {\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The matching event.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    readonly args",
      "doc": "An **EventLog** contains additional properties parsed from the [[Log]].",
      "tags": []
    },
    {
      "name": "UndecodedEventLog",
      "kind": "ClassDeclaration",
      "signature": "export class UndecodedEventLog extends Log {\n\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    readonly error!: Error;\n\n    /**\n     * @_ignore:\n     */\n    constructor(log: Log, error: Error) {\n        super(log, log.provider);\n        defineProperties<UndecodedEventLo",
      "doc": "An **EventLog** contains additional properties parsed from the [[Log]].",
      "tags": []
    },
    {
      "name": "BaseContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BaseContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {\n    (...args: ContractMethodArgs<A>): Promise<D>;\n\n    /**\n     *  The name of the Contract method.\n     */\n    name: string;\n\n    /**\n     *",
      "doc": "A Contract method can be called directly, or used in various ways.",
      "tags": []
    },
    {
      "name": "ConstantContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConstantContractMethod<\n    A extends Array<any>,\n    R = any\n> extends ContractMethod<A, R, R> { }",
      "doc": "A pure of view method on a Contract.",
      "tags": []
    },
    {
      "name": "PostfixOverrides",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PostfixOverrides<A extends Array<any>> = A | [ ...A, Overrides ];",
      "doc": "Arguments to a Contract method can always include an additional and\noptional overrides parameter.",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractEvent",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractEvent<A extends Array<any> = Array<any>> {\n    (...args: ContractEventArgs<A>): DeferredTopicFilter;\n\n    /**\n     *  The name of the Contract event.\n     */\n    name: string;\n\n    /**\n     *  The fragment of the Contract event. This will throw on ambiguous\n     *  method na",
      "doc": "",
      "tags": []
    },
    {
      "name": "ContractEventArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractEventArgs<A extends Array<any>> = { [ I in keyof A ]?: A[I] | Typed | null };",
      "doc": "Each argument of an event is nullable (to indicate matching //any//.",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractEventName",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractEventName = string | ContractEvent | TopicFilter | DeferredTopicFilter;",
      "doc": "The name for an event used for subscribing to Contract events.\n\n**``string``** - An event by name. The event must be non-ambiguous.\nThe parameters will be dereferenced when passed into the listener.\n\n[[ContractEvent]] - A filter from the ``contract.filters``, which will\npass only the EventPayload as a single parameter, which includes a\n``.signature`` property that can be used to further filter the event.\n\n[[TopicFilter]] - A filter defined using the standard Ethereum API\nwhich provides the specific topic hash or topic hashes to watch for along\nwith any additional values to filter by. This will only pass a single\nparameter to the listener, the EventPayload which will include additional\ndetails to refine by, such as the event name and signature.\n\n[[DeferredTopicFilter]] - A filter created by calling a [[ContractEvent]]\nwith parameters, which will create a filter for a specific event\nsignature and dereference each parameter when calling the listener.",
      "tags": []
    },
    {
      "name": "ContractDeployTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractDeployTransaction extends Omit<ContractTransaction, \"to\"> { }",
      "doc": "A deployment transaction for a contract.",
      "tags": []
    },
    {
      "name": "ContractInterface",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractInterface {\n    [ name: string ]: BaseContractMethod;\n}",
      "doc": "A Contract with no method constraints.",
      "tags": []
    },
    {
      "name": "ContractMethod",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractMethod<\n    A extends Array<any> = Array<any>,\n    R = any,\n    D extends R | ContractTransactionResponse = R | ContractTransactionResponse\n> extends BaseContractMethod<A, R, D> { }",
      "doc": "A contract method on a Contract.",
      "tags": []
    },
    {
      "name": "ContractMethodArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ContractMethodArgs<A extends Array<any>> = PostfixOverrides<{ [ I in keyof A ]-?: A[I] | Typed }>;",
      "doc": "Arguments to a Contract method can always include an additional and\noptional overrides parameter, and each parameter can optionally be\n[[Typed]].",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "ContractTransaction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractTransaction extends PreparedTransactionRequest {\n    /**\n     *  The target address.\n     */\n    to: string;\n\n    /**\n     *  The transaction data.\n     */\n    data: string;\n\n    /**\n     *  The from address, if any.\n     */\n    from?: string;\n}",
      "doc": "When populating a transaction this type is returned.",
      "tags": []
    },
    {
      "name": "DeferredTopicFilter",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DeferredTopicFilter {\n    getTopicFilter(): Promise<TopicFilter>;\n    fragment: EventFragment;\n}",
      "doc": "When creating a filter using the ``contract.filters``, this is returned.",
      "tags": []
    },
    {
      "name": "Overrides",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Overrides extends Omit<TransactionRequest, \"to\" | \"data\"> { }",
      "doc": "The overrides for a contract transaction.",
      "tags": []
    },
    {
      "name": "WrappedFallback",
      "kind": "InterfaceDeclaration",
      "signature": "export interface WrappedFallback {\n    (overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse>;\n\n    /**\n     *  Returns a populated transaction that can be used to perform the\n     *  fallback method.\n     *\n     *  For non-receive fallback, ``data`` may be overridden.\n  ",
      "doc": "A Fallback or Receive function on a Contract.",
      "tags": []
    },
    {
      "name": "ContractFactory",
      "kind": "ClassDeclaration",
      "signature": "export class ContractFactory<A extends Array<any> = Array<any>, I = BaseContract> {\n\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    readonly bytecode!: string;\n\n    /**\n    ",
      "doc": "A **ContractFactory** is used to deploy a Contract to the blockchain.",
      "tags": []
    },
    {
      "name": "copyOverrides",
      "kind": "FunctionDeclaration",
      "signature": "export async function copyOverrides<O extends string = \"data\" | \"to\">(arg: any, allowed?: Array<string>): Promise<Omit<ContractTransaction, O>> {\n\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = Typed.dereference(arg, \"overrides\");\n    assertArgument(type",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "copyOverrides.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "copyOverrides.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "copyOverrides.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "copyOverrides.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveArgs",
      "kind": "FunctionDeclaration",
      "signature": "export async function resolveArgs(_runner: null | ContractRunner, inputs: ReadonlyArray<ParamType>, args: Array<any>): Promise<Array<any>> {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? ",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "resolveArgs.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveArgs.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveArgs.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveArgs.__@toStringTag@1008",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "BaseContract",
      "kind": "ClassDeclaration",
      "signature": "export class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  meth",
      "doc": "",
      "tags": []
    },
    {
      "name": "Contract",
      "kind": "ClassDeclaration",
      "signature": "export class Contract extends _ContractBase() { }",
      "doc": "A [[BaseContract]] with no type guards on its methods or events.",
      "tags": []
    },
    {
      "name": "EtherSymbol",
      "kind": "VariableDeclaration",
      "signature": "EtherSymbol: string = \"\\u039e\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "MessagePrefix",
      "kind": "VariableDeclaration",
      "signature": "MessagePrefix: string = \"\\x19Ethereum Signed Message:\\n\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "N",
      "kind": "VariableDeclaration",
      "signature": "N: bigint = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "WeiPerEther",
      "kind": "VariableDeclaration",
      "signature": "WeiPerEther: bigint = BigInt(\"1000000000000000000\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "MaxUint256",
      "kind": "VariableDeclaration",
      "signature": "MaxUint256: bigint = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinInt256",
      "kind": "VariableDeclaration",
      "signature": "MinInt256: bigint = BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\") * BigInt(-1)",
      "doc": "",
      "tags": []
    },
    {
      "name": "MaxInt256",
      "kind": "VariableDeclaration",
      "signature": "MaxInt256: bigint = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "ZeroAddress",
      "kind": "VariableDeclaration",
      "signature": "ZeroAddress: string = \"0x0000000000000000000000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "ZeroHash",
      "kind": "VariableDeclaration",
      "signature": "ZeroHash: string = \"0x0000000000000000000000000000000000000000000000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "N",
      "kind": "VariableDeclaration",
      "signature": "N: bigint = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "WeiPerEther",
      "kind": "VariableDeclaration",
      "signature": "WeiPerEther: bigint = BigInt(\"1000000000000000000\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "MaxUint256",
      "kind": "VariableDeclaration",
      "signature": "MaxUint256: bigint = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinInt256",
      "kind": "VariableDeclaration",
      "signature": "MinInt256: bigint = BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\") * BigInt(-1)",
      "doc": "",
      "tags": []
    },
    {
      "name": "MaxInt256",
      "kind": "VariableDeclaration",
      "signature": "MaxInt256: bigint = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")",
      "doc": "",
      "tags": []
    },
    {
      "name": "EtherSymbol",
      "kind": "VariableDeclaration",
      "signature": "EtherSymbol: string = \"\\u039e\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "MessagePrefix",
      "kind": "VariableDeclaration",
      "signature": "MessagePrefix: string = \"\\x19Ethereum Signed Message:\\n\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "ZeroHash",
      "kind": "VariableDeclaration",
      "signature": "ZeroHash: string = \"0x0000000000000000000000000000000000000000000000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "ZeroAddress",
      "kind": "VariableDeclaration",
      "signature": "ZeroAddress: string = \"0x0000000000000000000000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Addressable",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Addressable {\n    /**\n     *  Get the object address.\n     */\n    getAddress(): Promise<string>;\n}",
      "doc": "An interface for objects which have an address, and can\nresolve it asyncronously.\n\nThis allows objects such as [[Signer]] or [[Contract]] to\nbe used most places an address can be, for example getting\nthe [balance](Provider-getBalance).",
      "tags": []
    },
    {
      "name": "AddressLike",
      "kind": "TypeAliasDeclaration",
      "signature": "export type AddressLike = string | Promise<string> | Addressable;",
      "doc": "Anything that can be used to return or resolve an address.",
      "tags": []
    },
    {
      "name": "NameResolver",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NameResolver {\n    /**\n     *  Resolve to the address for the ENS %%name%%.\n     *\n     *  Resolves to ``null`` if the name is unconfigued. Use\n     *  [[resolveAddress]] (passing this object as %%resolver%%) to\n     *  throw for names that are unconfigured.\n     */\n    resolveName(",
      "doc": "An interface for any object which can resolve an ENS name.",
      "tags": []
    },
    {
      "name": "getAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getAddress(address: string): string {\n\n    assertArgument(typeof(address) === \"string\", \"invalid address\", \"address\", address);\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) { address = \"0x\" + address; }\n\n",
      "doc": "Returns a normalized and checksumed address for %%address%%.\nThis accepts non-checksum addresses, checksum addresses and\n[[getIcapAddress]] formats.\n\nThe checksum in Ethereum uses the capitalization (upper-case\nvs lower-case) of the characters within an address to encode\nits checksum, which offers, on average, a checksum of 15-bits.\n\nIf %%address%% contains both upper-case and lower-case, it is\nassumed to already be a checksum address and its checksum is\nvalidated, and if the address fails its expected checksum an\nerror is thrown.\n\nIf you wish the checksum of %%address%% to be ignore, it should\nbe converted to lower-case (i.e. ``.toLowercase()``) before\nbeing passed in. This should be a very rare situation though,\nthat you wish to bypass the safegaurds in place to protect\nagainst an address that has been incorrectly copied from another\nsource.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Adds the checksum (via upper-casing specific letters)\ngetAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n//_result:\n\n// Converts ICAP address and adds checksum\ngetAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n//_result:\n\n// Throws an error if an address contains mixed case,\n// but the checksum fails\ngetAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_error:"
        }
      ]
    },
    {
      "name": "getIcapAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getIcapAddress(address: string): string {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(",
      "doc": "The [ICAP Address format](link-icap) format is an early checksum\nformat which attempts to be compatible with the banking\nindustry [IBAN format](link-wiki-iban) for bank accounts.\n\nIt is no longer common or a recommended format.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\ngetIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n//_result:\n\ngetIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n//_result:\n\n// Throws an error if the ICAP checksum is wrong\ngetIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n//_error:"
        }
      ]
    },
    {
      "name": "getCreateAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getCreateAddress(tx: { from: string, nonce: BigNumberish }): string {\n    const from = getAddress(tx.from);\n    const nonce = getBigInt(tx.nonce, \"tx.nonce\");\n\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length %",
      "doc": "Returns the address that would result from a ``CREATE`` for %%tx%%.\n\nThis can be used to compute the address a contract will be\ndeployed to by an EOA when sending a deployment transaction (i.e.\nwhen the ``to`` address is ``null``).\n\nThis can also be used to compute the address a contract will be\ndeployed to by a contract, by using the contract's address as the\n``to`` and the contract's nonce.",
      "tags": [
        {
          "tagName": "example",
          "text": "  from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n  nonce = 5;\n\n  getCreateAddress({ from, nonce });\n  //_result:"
        }
      ]
    },
    {
      "name": "getCreate2Address",
      "kind": "FunctionDeclaration",
      "signature": "export function getCreate2Address(_from: string, _salt: BytesLike, _initCodeHash: BytesLike): string {\n    const from = getAddress(_from);\n    const salt = getBytes(_salt, \"salt\");\n    const initCodeHash = getBytes(_initCodeHash, \"initCodeHash\");\n\n    assertArgument(salt.length === 32, \"salt must be",
      "doc": "Returns the address that would result from a ``CREATE2`` operation\nwith the given %%from%%, %%salt%% and %%initCodeHash%%.\n\nTo compute the %%initCodeHash%% from a contract's init code, use\nthe [[keccak256]] function.\n\nFor a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].",
      "tags": [
        {
          "tagName": "example",
          "text": "  // The address of the contract\n  from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n\n  // The salt\n  salt = id(\"HelloWorld\")\n\n  // The hash of the initCode\n  initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n  initCodeHash = keccak256(initCode)\n\n  getCreate2Address(from, salt, initCodeHash)\n  //_result:"
        }
      ]
    },
    {
      "name": "isAddressable",
      "kind": "FunctionDeclaration",
      "signature": "export function isAddressable(value: any): value is Addressable {\n    return (value && typeof(value.getAddress) === \"function\");\n}",
      "doc": "Returns true if %%value%% is an object which implements the\n[[Addressable]] interface.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Wallets and AbstractSigner sub-classes\nisAddressable(Wallet.createRandom())\n//_result:\n\n// Contracts\ncontract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\nisAddressable(contract)\n//_result:"
        }
      ]
    },
    {
      "name": "isAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function isAddress(value: any): value is string {\n    try {\n        getAddress(value);\n        return true;\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%value%% is a valid address.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Valid address\nisAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_result:\n\n// Valid ICAP address\nisAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n//_result:\n\n// Invalid checksum\nisAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n//_result:\n\n// Invalid ICAP checksum\nisAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_result:\n\n// Not an address (an ENS name requires a provided and an\n// asynchronous API to access)\nisAddress(\"ricmoo.eth\")\n//_result:"
        }
      ]
    },
    {
      "name": "resolveAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function resolveAddress(target: AddressLike, resolver?: null | NameResolver): string | Promise<string> {\n\n    if (typeof(target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) { return getAddress(target); }\n\n        assert(resolver != null, \"ENS resolution requires a provider\"",
      "doc": "Resolves to an address for the %%target%%, which may be any\nsupported address type, an [[Addressable]] or a Promise which\nresolves to an address.\n\nIf an ENS name is provided, but that name has not been correctly\nconfigured a [[UnconfiguredNameError]] is thrown.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n\n// Addresses are return synchronously\nresolveAddress(addr, provider)\n//_result:\n\n// Address promises are resolved asynchronously\nresolveAddress(Promise.resolve(addr))\n//_result:\n\n// ENS names are resolved asynchronously\nresolveAddress(\"dai.tokens.ethers.eth\", provider)\n//_result:\n\n// Addressable objects are resolved asynchronously\ncontract = new Contract(addr, [ ])\nresolveAddress(contract, provider)\n//_result:\n\n// Unconfigured ENS names reject\nresolveAddress(\"nothing-here.ricmoo.eth\", provider)\n//_error:\n\n// ENS names require a NameResolver object passed in\n// (notice the provider was omitted)\nresolveAddress(\"nothing-here.ricmoo.eth\")\n//_error:"
        }
      ]
    },
    {
      "name": "getCreateAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getCreateAddress(tx: { from: string, nonce: BigNumberish }): string {\n    const from = getAddress(tx.from);\n    const nonce = getBigInt(tx.nonce, \"tx.nonce\");\n\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length %",
      "doc": "Returns the address that would result from a ``CREATE`` for %%tx%%.\n\nThis can be used to compute the address a contract will be\ndeployed to by an EOA when sending a deployment transaction (i.e.\nwhen the ``to`` address is ``null``).\n\nThis can also be used to compute the address a contract will be\ndeployed to by a contract, by using the contract's address as the\n``to`` and the contract's nonce.",
      "tags": [
        {
          "tagName": "example",
          "text": "  from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n  nonce = 5;\n\n  getCreateAddress({ from, nonce });\n  //_result:"
        }
      ]
    },
    {
      "name": "getCreate2Address",
      "kind": "FunctionDeclaration",
      "signature": "export function getCreate2Address(_from: string, _salt: BytesLike, _initCodeHash: BytesLike): string {\n    const from = getAddress(_from);\n    const salt = getBytes(_salt, \"salt\");\n    const initCodeHash = getBytes(_initCodeHash, \"initCodeHash\");\n\n    assertArgument(salt.length === 32, \"salt must be",
      "doc": "Returns the address that would result from a ``CREATE2`` operation\nwith the given %%from%%, %%salt%% and %%initCodeHash%%.\n\nTo compute the %%initCodeHash%% from a contract's init code, use\nthe [[keccak256]] function.\n\nFor a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].",
      "tags": [
        {
          "tagName": "example",
          "text": "  // The address of the contract\n  from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n\n  // The salt\n  salt = id(\"HelloWorld\")\n\n  // The hash of the initCode\n  initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n  initCodeHash = keccak256(initCode)\n\n  getCreate2Address(from, salt, initCodeHash)\n  //_result:"
        }
      ]
    },
    {
      "name": "isAddressable",
      "kind": "FunctionDeclaration",
      "signature": "export function isAddressable(value: any): value is Addressable {\n    return (value && typeof(value.getAddress) === \"function\");\n}",
      "doc": "Returns true if %%value%% is an object which implements the\n[[Addressable]] interface.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Wallets and AbstractSigner sub-classes\nisAddressable(Wallet.createRandom())\n//_result:\n\n// Contracts\ncontract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\nisAddressable(contract)\n//_result:"
        }
      ]
    },
    {
      "name": "isAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function isAddress(value: any): value is string {\n    try {\n        getAddress(value);\n        return true;\n    } catch (error) { }\n    return false;\n}",
      "doc": "Returns true if %%value%% is a valid address.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Valid address\nisAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_result:\n\n// Valid ICAP address\nisAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n//_result:\n\n// Invalid checksum\nisAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n//_result:\n\n// Invalid ICAP checksum\nisAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_result:\n\n// Not an address (an ENS name requires a provided and an\n// asynchronous API to access)\nisAddress(\"ricmoo.eth\")\n//_result:"
        }
      ]
    },
    {
      "name": "resolveAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function resolveAddress(target: AddressLike, resolver?: null | NameResolver): string | Promise<string> {\n\n    if (typeof(target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) { return getAddress(target); }\n\n        assert(resolver != null, \"ENS resolution requires a provider\"",
      "doc": "Resolves to an address for the %%target%%, which may be any\nsupported address type, an [[Addressable]] or a Promise which\nresolves to an address.\n\nIf an ENS name is provided, but that name has not been correctly\nconfigured a [[UnconfiguredNameError]] is thrown.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\naddr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n\n// Addresses are return synchronously\nresolveAddress(addr, provider)\n//_result:\n\n// Address promises are resolved asynchronously\nresolveAddress(Promise.resolve(addr))\n//_result:\n\n// ENS names are resolved asynchronously\nresolveAddress(\"dai.tokens.ethers.eth\", provider)\n//_result:\n\n// Addressable objects are resolved asynchronously\ncontract = new Contract(addr, [ ])\nresolveAddress(contract, provider)\n//_result:\n\n// Unconfigured ENS names reject\nresolveAddress(\"nothing-here.ricmoo.eth\", provider)\n//_error:\n\n// ENS names require a NameResolver object passed in\n// (notice the provider was omitted)\nresolveAddress(\"nothing-here.ricmoo.eth\")\n//_error:"
        }
      ]
    },
    {
      "name": "getAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getAddress(address: string): string {\n\n    assertArgument(typeof(address) === \"string\", \"invalid address\", \"address\", address);\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) { address = \"0x\" + address; }\n\n",
      "doc": "Returns a normalized and checksumed address for %%address%%.\nThis accepts non-checksum addresses, checksum addresses and\n[[getIcapAddress]] formats.\n\nThe checksum in Ethereum uses the capitalization (upper-case\nvs lower-case) of the characters within an address to encode\nits checksum, which offers, on average, a checksum of 15-bits.\n\nIf %%address%% contains both upper-case and lower-case, it is\nassumed to already be a checksum address and its checksum is\nvalidated, and if the address fails its expected checksum an\nerror is thrown.\n\nIf you wish the checksum of %%address%% to be ignore, it should\nbe converted to lower-case (i.e. ``.toLowercase()``) before\nbeing passed in. This should be a very rare situation though,\nthat you wish to bypass the safegaurds in place to protect\nagainst an address that has been incorrectly copied from another\nsource.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\n// Adds the checksum (via upper-casing specific letters)\ngetAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n//_result:\n\n// Converts ICAP address and adds checksum\ngetAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n//_result:\n\n// Throws an error if an address contains mixed case,\n// but the checksum fails\ngetAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n//_error:"
        }
      ]
    },
    {
      "name": "getIcapAddress",
      "kind": "FunctionDeclaration",
      "signature": "export function getIcapAddress(address: string): string {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(",
      "doc": "The [ICAP Address format](link-icap) format is an early checksum\nformat which attempts to be compatible with the banking\nindustry [IBAN format](link-wiki-iban) for bank accounts.\n\nIt is no longer common or a recommended format.",
      "tags": [
        {
          "tagName": "example",
          "text": ":\ngetIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n//_result:\n\ngetIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n//_result:\n\n// Throws an error if the ICAP checksum is wrong\ngetIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n//_error:"
        }
      ]
    },
    {
      "name": "TypedNumber",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedNumber extends Typed {\n    value: number;\n    defaultValue(): number;\n    minValue(): number;\n    maxValue(): number;\n}",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ":"
        }
      ]
    },
    {
      "name": "TypedBigInt",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedBigInt extends Typed {\n    /**\n     *  The value.\n     */\n    value: bigint;\n\n    /**\n     *  The default value for all numeric types is ``0``.\n     */\n    defaultValue(): bigint;\n\n    /**\n     *  The minimum value for this type, accounting for bit-width and signed-ness.\n     *",
      "doc": "A **Typed** that represents a numeric value.",
      "tags": []
    },
    {
      "name": "TypedData",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedData extends Typed {\n    /**\n     *  The value.\n     */\n    value: string;\n\n    /**\n     *  The default value for this type.\n     */\n    defaultValue(): string;\n}",
      "doc": "A **Typed** that represents a binary sequence of data as bytes.",
      "tags": []
    },
    {
      "name": "TypedString",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TypedString extends Typed {\n    /**\n     *  The value.\n     */\n    value: string;\n\n    /**\n     *  The default value for the string type is the empty string (i.e. ``\"\"``).\n     */\n    defaultValue(): string;\n}",
      "doc": "A **Typed** that represents a UTF-8 sequence of bytes.",
      "tags": []
    },
    {
      "name": "Typed",
      "kind": "ClassDeclaration",
      "signature": "export class Typed {\n\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    readonly type!: string;\n\n    /**\n     *  The actual value.\n     */\n    readonly value!: any;\n\n    readonly #options: any;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _typedSymbol!: Symbol;\n\n    /**\n     * ",
      "doc": "The **Typed** class to wrap values providing explicit type information.",
      "tags": []
    },
    {
      "name": "checkResultErrors",
      "kind": "FunctionDeclaration",
      "signature": "export function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any):",
      "doc": "Returns all errors found in a [[Result]].\n\nSince certain errors encountered when creating a [[Result]] do\nnot impact the ability to continue parsing data, they are\ndeferred until they are actually accessed. Hence a faulty string\nin an Event that is never used does not impact the program flow.\n\nHowever, sometimes it may be useful to access, identify or\nvalidate correctness of a [[Result]].",
      "tags": [
        {
          "tagName": "_docloc",
          "text": "api/abi"
        }
      ]
    },
    {
      "name": "checkResultErrors.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "Result",
      "kind": "ClassDeclaration",
      "signature": "export class Result extends Array<any> {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @privat",
      "doc": "A [[Result]] is a sub-class of Array, which allows accessing any\nof its values either positionally by its index or, if keys are\nprovided by its name.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/abi"
        }
      ]
    },
    {
      "name": "LogDescription",
      "kind": "ClassDeclaration",
      "signature": "export class LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The name of the Event.\n     */\n    readonly name!: string;\n\n    /**\n     *  The full Event signature.\n     */\n    readonly signature!: string;\n\n    ",
      "doc": "When using the [[Interface-parseLog]] to automatically match a Log to its event\nfor parsing, a **LogDescription** is returned.",
      "tags": []
    },
    {
      "name": "TransactionDescription",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    readonly fragment!: FunctionFragment;\n\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments pas",
      "doc": "When using the [[Interface-parseTransaction]] to automatically match\na transaction data to its function for parsing,\na **TransactionDescription** is returned.",
      "tags": []
    },
    {
      "name": "ErrorDescription",
      "kind": "ClassDeclaration",
      "signature": "export class ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    readonly fragment!: ErrorFragment;\n\n    /**\n     *  The name of the Error.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    readonly args!: Result;\n\n ",
      "doc": "When using the [[Interface-parseError]] to automatically match an\nerror for a call result for parsing, an **ErrorDescription** is returned.",
      "tags": []
    },
    {
      "name": "Indexed",
      "kind": "ClassDeclaration",
      "signature": "export class Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _isIndexed!: boolean;\n\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard f",
      "doc": "An **Indexed** is used as a value when a value that does not\nfit within a topic (i.e. not a fixed-length, 32-byte type). It\nis the ``keccak256`` of the value, and used for types such as\narrays, tuples, bytes and strings.",
      "tags": []
    },
    {
      "name": "InterfaceAbi",
      "kind": "TypeAliasDeclaration",
      "signature": "export type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;",
      "doc": "An **InterfaceAbi** may be any supported ABI format.\n\nA string is expected to be a JSON string, which will be parsed\nusing ``JSON.parse``. This means that the value **must** be a valid\nJSON string, with no stray commas, etc.\n\nAn array may contain any combination of:\n- Human-Readable fragments\n- Parsed JSON fragment\n- [[Fragment]] instances\n\nA **Human-Readable Fragment** is a string which resembles a Solidity\nsignature and is introduced in [this blog entry](link-ricmoo-humanreadableabi).\nFor example, ``function balanceOf(address) view returns (uint)``.\n\nA **Parsed JSON Fragment** is a JavaScript Object desribed in the\n[Solidity documentation](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "Interface",
      "kind": "ClassDeclaration",
      "signature": "export class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if",
      "doc": "An Interface abstracts many of the low-level details for\nencoding and decoding the data on the blockchain.\n\nAn ABI provides information on how to encode data to send to\na Contract, how to decode the results and events and how to\ninterpret revert errors.\n\nThe ABI can be specified by [any supported format](InterfaceAbi).",
      "tags": []
    },
    {
      "name": "AbiCoder",
      "kind": "ClassDeclaration",
      "signature": "export class AbiCoder {\n\n    #getCoder(param: ParamType): Coder {\n        if (param.isArray()) {\n            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n\n        if (param.isTuple()) {\n            return new TupleCoder(param.components.map((c)",
      "doc": "The **AbiCoder** is a low-level class responsible for encoding JavaScript\nvalues into binary data and decoding binary data into JavaScript values.",
      "tags": []
    },
    {
      "name": "decodeBytes32String",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBytes32String(_bytes: BytesLike): string {\n    const data = getBytes(_bytes, \"bytes\");\n\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) { throw new Error(\"invalid bytes32 - not 32 bytes long\"); }\n    if (data[31] !== 0) { throw new Error(\"invalid byt",
      "doc": "Encodes the Bytes32-encoded %%bytes%% into a string.",
      "tags": []
    },
    {
      "name": "encodeBytes32String",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBytes32String(text: string): string {\n\n    // Get the bytes\n    const bytes = toUtf8Bytes(text);\n\n    // Check we have room for null-termination\n    if (bytes.length > 31) { throw new Error(\"bytes32 string must be less than 32 bytes\"); }\n\n    // Zero-pad (implicitly null-termin",
      "doc": "Encodes %%text%% as a Bytes32 string.",
      "tags": []
    },
    {
      "name": "ConstructorFragment",
      "kind": "ClassDeclaration",
      "signature": "export class ConstructorFragment extends Fragment {\n\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n  ",
      "doc": "A Fragment which represents a constructor.",
      "tags": []
    },
    {
      "name": "ErrorFragment",
      "kind": "ClassDeclaration",
      "signature": "export class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n\n    /",
      "doc": "A Fragment which represents a //Custom Error//.",
      "tags": []
    },
    {
      "name": "EventFragment",
      "kind": "ClassDeclaration",
      "signature": "export class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    readonly anonymous!: boolean;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>, anonymous: boolean) {\n        super(guard, \"even",
      "doc": "A Fragment which represents an Event.",
      "tags": []
    },
    {
      "name": "FallbackFragment",
      "kind": "ClassDeclaration",
      "signature": "export class FallbackFragment extends Fragment {\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean) {\n        super(guard, \"fallback\", inputs);\n        Object.d",
      "doc": "A Fragment which represents a method.",
      "tags": []
    },
    {
      "name": "Fragment",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    readonly type!: FragmentType;\n\n    /**\n     *  The inputs for the fragment.\n     */\n    readonly inputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType,",
      "doc": "An abstract class to represent An individual fragment from a parse ABI.",
      "tags": []
    },
    {
      "name": "FunctionFragment",
      "kind": "ClassDeclaration",
      "signature": "export class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    readonly constant!: boolean;\n\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    readonly outputs!: ReadonlyArray<",
      "doc": "A Fragment which represents a method.",
      "tags": []
    },
    {
      "name": "NamedFragment",
      "kind": "ClassDeclaration",
      "signature": "export abstract class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    readonly name!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, type, inputs);",
      "doc": "An abstract class to represent An individual fragment\nwhich has a name from a parse ABI.",
      "tags": []
    },
    {
      "name": "ParamType",
      "kind": "ClassDeclaration",
      "signature": "export class ParamType {\n\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    readonly name!: string;\n\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    readonly type!: string;\n\n    /**\n     *  T",
      "doc": "Each input and output of a [[Fragment]] is an Array of **ParamType**.",
      "tags": []
    },
    {
      "name": "StructFragment",
      "kind": "ClassDeclaration",
      "signature": "export class StructFragment extends NamedFragment {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n\n ",
      "doc": "A Fragment which represents a structure.",
      "tags": []
    },
    {
      "name": "checkResultErrors",
      "kind": "FunctionDeclaration",
      "signature": "export function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any):",
      "doc": "Returns all errors found in a [[Result]].\n\nSince certain errors encountered when creating a [[Result]] do\nnot impact the ability to continue parsing data, they are\ndeferred until they are actually accessed. Hence a faulty string\nin an Event that is never used does not impact the program flow.\n\nHowever, sometimes it may be useful to access, identify or\nvalidate correctness of a [[Result]].",
      "tags": [
        {
          "tagName": "_docloc",
          "text": "api/abi"
        }
      ]
    },
    {
      "name": "checkResultErrors.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "Indexed",
      "kind": "ClassDeclaration",
      "signature": "export class Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _isIndexed!: boolean;\n\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard f",
      "doc": "An **Indexed** is used as a value when a value that does not\nfit within a topic (i.e. not a fixed-length, 32-byte type). It\nis the ``keccak256`` of the value, and used for types such as\narrays, tuples, bytes and strings.",
      "tags": []
    },
    {
      "name": "Interface",
      "kind": "ClassDeclaration",
      "signature": "export class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if",
      "doc": "An Interface abstracts many of the low-level details for\nencoding and decoding the data on the blockchain.\n\nAn ABI provides information on how to encode data to send to\na Contract, how to decode the results and events and how to\ninterpret revert errors.\n\nThe ABI can be specified by [any supported format](InterfaceAbi).",
      "tags": []
    },
    {
      "name": "ErrorDescription",
      "kind": "ClassDeclaration",
      "signature": "export class ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    readonly fragment!: ErrorFragment;\n\n    /**\n     *  The name of the Error.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    readonly args!: Result;\n\n ",
      "doc": "When using the [[Interface-parseError]] to automatically match an\nerror for a call result for parsing, an **ErrorDescription** is returned.",
      "tags": []
    },
    {
      "name": "LogDescription",
      "kind": "ClassDeclaration",
      "signature": "export class LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The name of the Event.\n     */\n    readonly name!: string;\n\n    /**\n     *  The full Event signature.\n     */\n    readonly signature!: string;\n\n    ",
      "doc": "When using the [[Interface-parseLog]] to automatically match a Log to its event\nfor parsing, a **LogDescription** is returned.",
      "tags": []
    },
    {
      "name": "TransactionDescription",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    readonly fragment!: FunctionFragment;\n\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments pas",
      "doc": "When using the [[Interface-parseTransaction]] to automatically match\na transaction data to its function for parsing,\na **TransactionDescription** is returned.",
      "tags": []
    },
    {
      "name": "Result",
      "kind": "ClassDeclaration",
      "signature": "export class Result extends Array<any> {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @privat",
      "doc": "A [[Result]] is a sub-class of Array, which allows accessing any\nof its values either positionally by its index or, if keys are\nprovided by its name.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/abi"
        }
      ]
    },
    {
      "name": "Typed",
      "kind": "ClassDeclaration",
      "signature": "export class Typed {\n\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    readonly type!: string;\n\n    /**\n     *  The actual value.\n     */\n    readonly value!: any;\n\n    readonly #options: any;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _typedSymbol!: Symbol;\n\n    /**\n     * ",
      "doc": "The **Typed** class to wrap values providing explicit type information.",
      "tags": []
    },
    {
      "name": "JsonFragment",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonFragment {\n    /**\n     *  The name of the error, event, function, etc.\n     */\n    readonly name?: string;\n\n    /**\n     *  The type of the fragment (e.g. ``event``, ``\"function\"``, etc.)\n     */\n    readonly type?: string;\n\n    /**\n     *  If the event is anonymous.\n     */\n  ",
      "doc": "A fragment for a method, event or error in a [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "JsonFragmentType",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonFragmentType {\n    /**\n     *  The parameter name.\n     */\n    readonly name?: string;\n\n    /**\n     *  If the parameter is indexed.\n     */\n    readonly indexed?: boolean;\n\n    /**\n     *  The type of the parameter.\n     */\n    readonly type?: string;\n\n    /**\n     *  The inter",
      "doc": "A Type description in a [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "FormatType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FormatType = \"sighash\" | \"minimal\" | \"full\" | \"json\";",
      "doc": "The format to serialize the output as.\n\n**``\"sighash\"``** - the bare formatting, used to compute the selector\nor topic hash; this format cannot be reversed (as it discards ``indexed``)\nso cannot by used to export an [[Interface]].\n\n**``\"minimal\"``** - Human-Readable ABI with minimal spacing and without\nnames, so it is compact, but will result in Result objects that cannot\nbe accessed by name.\n\n**``\"full\"``** - Full Human-Readable ABI, with readable spacing and names\nintact; this is generally the recommended format.\n\n**``\"json\"``** - The [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "FragmentType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FragmentType = \"constructor\" | \"error\" | \"event\" | \"fallback\" | \"function\" | \"struct\";",
      "doc": "The type of a [[Fragment]].",
      "tags": []
    },
    {
      "name": "ParamTypeWalkAsyncFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ParamTypeWalkAsyncFunc = (type: string, value: any) => any | Promise<any>;",
      "doc": "When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],\nthis is called on each component.",
      "tags": []
    },
    {
      "name": "ParamTypeWalkFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ParamTypeWalkFunc = (type: string, value: any) => any;",
      "doc": "When [walking](ParamType-walk) a [[ParamType]], this is called\non each component.",
      "tags": []
    },
    {
      "name": "InterfaceAbi",
      "kind": "TypeAliasDeclaration",
      "signature": "export type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;",
      "doc": "An **InterfaceAbi** may be any supported ABI format.\n\nA string is expected to be a JSON string, which will be parsed\nusing ``JSON.parse``. This means that the value **must** be a valid\nJSON string, with no stray commas, etc.\n\nAn array may contain any combination of:\n- Human-Readable fragments\n- Parsed JSON fragment\n- [[Fragment]] instances\n\nA **Human-Readable Fragment** is a string which resembles a Solidity\nsignature and is introduced in [this blog entry](link-ricmoo-humanreadableabi).\nFor example, ``function balanceOf(address) view returns (uint)``.\n\nA **Parsed JSON Fragment** is a JavaScript Object desribed in the\n[Solidity documentation](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "JsonFragmentType",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonFragmentType {\n    /**\n     *  The parameter name.\n     */\n    readonly name?: string;\n\n    /**\n     *  If the parameter is indexed.\n     */\n    readonly indexed?: boolean;\n\n    /**\n     *  The type of the parameter.\n     */\n    readonly type?: string;\n\n    /**\n     *  The inter",
      "doc": "A Type description in a [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "JsonFragment",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonFragment {\n    /**\n     *  The name of the error, event, function, etc.\n     */\n    readonly name?: string;\n\n    /**\n     *  The type of the fragment (e.g. ``event``, ``\"function\"``, etc.)\n     */\n    readonly type?: string;\n\n    /**\n     *  If the event is anonymous.\n     */\n  ",
      "doc": "A fragment for a method, event or error in a [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "FormatType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FormatType = \"sighash\" | \"minimal\" | \"full\" | \"json\";",
      "doc": "The format to serialize the output as.\n\n**``\"sighash\"``** - the bare formatting, used to compute the selector\nor topic hash; this format cannot be reversed (as it discards ``indexed``)\nso cannot by used to export an [[Interface]].\n\n**``\"minimal\"``** - Human-Readable ABI with minimal spacing and without\nnames, so it is compact, but will result in Result objects that cannot\nbe accessed by name.\n\n**``\"full\"``** - Full Human-Readable ABI, with readable spacing and names\nintact; this is generally the recommended format.\n\n**``\"json\"``** - The [JSON ABI format](link-solc-jsonabi).",
      "tags": []
    },
    {
      "name": "ParamTypeWalkFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ParamTypeWalkFunc = (type: string, value: any) => any;",
      "doc": "When [walking](ParamType-walk) a [[ParamType]], this is called\non each component.",
      "tags": []
    },
    {
      "name": "ParamTypeWalkAsyncFunc",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ParamTypeWalkAsyncFunc = (type: string, value: any) => any | Promise<any>;",
      "doc": "When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],\nthis is called on each component.",
      "tags": []
    },
    {
      "name": "ParamType",
      "kind": "ClassDeclaration",
      "signature": "export class ParamType {\n\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    readonly name!: string;\n\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    readonly type!: string;\n\n    /**\n     *  T",
      "doc": "Each input and output of a [[Fragment]] is an Array of **ParamType**.",
      "tags": []
    },
    {
      "name": "FragmentType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type FragmentType = \"constructor\" | \"error\" | \"event\" | \"fallback\" | \"function\" | \"struct\";",
      "doc": "The type of a [[Fragment]].",
      "tags": []
    },
    {
      "name": "Fragment",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    readonly type!: FragmentType;\n\n    /**\n     *  The inputs for the fragment.\n     */\n    readonly inputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType,",
      "doc": "An abstract class to represent An individual fragment from a parse ABI.",
      "tags": []
    },
    {
      "name": "NamedFragment",
      "kind": "ClassDeclaration",
      "signature": "export abstract class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    readonly name!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, type, inputs);",
      "doc": "An abstract class to represent An individual fragment\nwhich has a name from a parse ABI.",
      "tags": []
    },
    {
      "name": "ErrorFragment",
      "kind": "ClassDeclaration",
      "signature": "export class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n\n    /",
      "doc": "A Fragment which represents a //Custom Error//.",
      "tags": []
    },
    {
      "name": "EventFragment",
      "kind": "ClassDeclaration",
      "signature": "export class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    readonly anonymous!: boolean;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>, anonymous: boolean) {\n        super(guard, \"even",
      "doc": "A Fragment which represents an Event.",
      "tags": []
    },
    {
      "name": "ConstructorFragment",
      "kind": "ClassDeclaration",
      "signature": "export class ConstructorFragment extends Fragment {\n\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n  ",
      "doc": "A Fragment which represents a constructor.",
      "tags": []
    },
    {
      "name": "FallbackFragment",
      "kind": "ClassDeclaration",
      "signature": "export class FallbackFragment extends Fragment {\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean) {\n        super(guard, \"fallback\", inputs);\n        Object.d",
      "doc": "A Fragment which represents a method.",
      "tags": []
    },
    {
      "name": "FunctionFragment",
      "kind": "ClassDeclaration",
      "signature": "export class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    readonly constant!: boolean;\n\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    readonly outputs!: ReadonlyArray<",
      "doc": "A Fragment which represents a method.",
      "tags": []
    },
    {
      "name": "StructFragment",
      "kind": "ClassDeclaration",
      "signature": "export class StructFragment extends NamedFragment {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n\n ",
      "doc": "A Fragment which represents a structure.",
      "tags": []
    },
    {
      "name": "encodeBytes32String",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeBytes32String(text: string): string {\n\n    // Get the bytes\n    const bytes = toUtf8Bytes(text);\n\n    // Check we have room for null-termination\n    if (bytes.length > 31) { throw new Error(\"bytes32 string must be less than 32 bytes\"); }\n\n    // Zero-pad (implicitly null-termin",
      "doc": "Encodes %%text%% as a Bytes32 string.",
      "tags": []
    },
    {
      "name": "decodeBytes32String",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeBytes32String(_bytes: BytesLike): string {\n    const data = getBytes(_bytes, \"bytes\");\n\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) { throw new Error(\"invalid bytes32 - not 32 bytes long\"); }\n    if (data[31] !== 0) { throw new Error(\"invalid byt",
      "doc": "Encodes the Bytes32-encoded %%bytes%% into a string.",
      "tags": []
    },
    {
      "name": "AbiCoder",
      "kind": "ClassDeclaration",
      "signature": "export class AbiCoder {\n\n    #getCoder(param: ParamType): Coder {\n        if (param.isArray()) {\n            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n\n        if (param.isTuple()) {\n            return new TupleCoder(param.components.map((c)",
      "doc": "The **AbiCoder** is a low-level class responsible for encoding JavaScript\nvalues into binary data and decoding binary data into JavaScript values.",
      "tags": []
    },
    {
      "name": "TupleCoder",
      "kind": "ClassDeclaration",
      "signature": "export class TupleCoder extends Coder {\n    readonly coders!: ReadonlyArray<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "StringCoder",
      "kind": "ClassDeclaration",
      "signature": "export class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, _value: string | Typed): number {\n        return super.encode(writer, toUtf8Bytes(Ty",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "NumberCoder",
      "kind": "ClassDeclaration",
      "signature": "export class NumberCoder extends Coder {\n    readonly size!: number;\n    readonly signed!: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        definePropertie",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "NullCoder",
      "kind": "ClassDeclaration",
      "signature": "export class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "FixedBytesCoder",
      "kind": "ClassDeclaration",
      "signature": "export class FixedBytesCoder extends Coder {\n    readonly size!: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        defineProperties<FixedBytesCoder>(this, { size }, { size: \"number\" });\n    }\n\n ",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "DynamicBytesCoder",
      "kind": "ClassDeclaration",
      "signature": "export class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = getBytesCopy(value);\n        l",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "BytesCoder",
      "kind": "ClassDeclaration",
      "signature": "export class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return hexlify(super.decode(reader));\n    }\n}",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "BooleanCoder",
      "kind": "ClassDeclaration",
      "signature": "export class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, _value: boolean | Typed): number {\n        const value = Typed.dereference(_va",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "pack",
      "kind": "FunctionDeclaration",
      "signature": "export function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = [ ];\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let uniq",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "unpack",
      "kind": "FunctionDeclaration",
      "signature": "export function unpack(reader: Reader, coders: ReadonlyArray<Coder>): Result {\n    let values: Array<any> = [];\n    let keys: Array<null | string> = [ ];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "unpack.#names",
      "kind": "PropertyDeclaration",
      "signature": "readonly #names: ReadonlyArray<null | string>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.toArray",
      "kind": "MethodDeclaration",
      "signature": "toArray(deep?: boolean): Array<any> {\n        const result: Array<any> = [ ];\n        this.forEach((item, index) => {\n            if (item instanceof Error) { throwError(`index ${ index }`, item); }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n        ",
      "doc": "Returns the Result as a normal Array. If %%deep%%, any children\nwhich are Result objects are also converted to a normal Array.\n\nThis will throw if there are any outstanding deferred\nerrors.",
      "tags": []
    },
    {
      "name": "unpack.toObject",
      "kind": "MethodDeclaration",
      "signature": "toObject(deep?: boolean): Record<string, any> {\n        const names = getNames(this);\n        return names.reduce((accum, name, index) => {\n\n            assert(name != null, `value at index ${ index } unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n\n     ",
      "doc": "Returns the Result as an Object with each name-value pair. If\n%%deep%%, any children which are Result objects are also\nconverted to an Object.\n\nThis will throw if any value is unnamed, or if there are\nany outstanding deferred errors.",
      "tags": []
    },
    {
      "name": "unpack.slice",
      "kind": "MethodDeclaration",
      "signature": "slice(start?: number | undefined, end?: number | undefined): Result {\n        if (start == null) { start = 0; }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) { start = 0; }\n        }\n\n        if (end == null) { end = this.length; }\n        if (end < 0) {\n     ",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "unpack.filter",
      "kind": "MethodDeclaration",
      "signature": "filter(callback: (el: any, index: number, array: Result) => boolean, thisArg?: any): Result {\n        const _names = getNames(this);\n\n        const result: Array<any> = [ ], names: Array<null | string> = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n         ",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "unpack.map",
      "kind": "MethodDeclaration",
      "signature": "map<T extends any = any>(callback: (el: any, index: number, array: Result) => T, thisArg?: any): Array<T> {\n        const result: Array<T> = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`ind",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "unpack.getValue",
      "kind": "MethodDeclaration",
      "signature": "getValue(name: string): any {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) { return undefined; }\n\n        const value = this[index];\n\n        if (value instanceof Error) {\n            throwError(`property ${ JSON.stringify(name) }`, (<any>value).error);\n        }\n\n  ",
      "doc": "Returns the value for %%name%%.\n\nSince it is possible to have a key whose name conflicts with\na method on a [[Result]] or its superclass Array, or any\nJavaScript keyword, this ensures all named values are still\naccessible by name.",
      "tags": []
    },
    {
      "name": "unpack.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "unpack.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "ArrayCoder",
      "kind": "ClassDeclaration",
      "signature": "export class ArrayCoder extends Coder {\n    readonly coder!: Coder;\n    readonly length!: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "AnonymousCoder",
      "kind": "ClassDeclaration",
      "signature": "export class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, v",
      "doc": "Clones the functionality of an existing Coder, but without a localName",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "AddressCoder",
      "kind": "ClassDeclaration",
      "signature": "export class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, _value: string | Typed): number {\n",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "checkResultErrors",
      "kind": "FunctionDeclaration",
      "signature": "export function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any):",
      "doc": "Returns all errors found in a [[Result]].\n\nSince certain errors encountered when creating a [[Result]] do\nnot impact the ability to continue parsing data, they are\ndeferred until they are actually accessed. Hence a faulty string\nin an Event that is never used does not impact the program flow.\n\nHowever, sometimes it may be useful to access, identify or\nvalidate correctness of a [[Result]].",
      "tags": [
        {
          "tagName": "_docloc",
          "text": "api/abi"
        }
      ]
    },
    {
      "name": "checkResultErrors.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@iterator@967",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.__@unscopables@969",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "checkResultErrors.at",
      "kind": "MethodSignature",
      "signature": "at(index: number): T | undefined;",
      "doc": "Takes an integer value and returns the item at that index,\nallowing for positive and negative integers.\nNegative integers count back from the last item in the array.",
      "tags": []
    },
    {
      "name": "WordSize",
      "kind": "VariableDeclaration",
      "signature": "WordSize: number = 32",
      "doc": "",
      "tags": []
    },
    {
      "name": "Result",
      "kind": "ClassDeclaration",
      "signature": "export class Result extends Array<any> {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @privat",
      "doc": "A [[Result]] is a sub-class of Array, which allows accessing any\nof its values either positionally by its index or, if keys are\nprovided by its name.",
      "tags": [
        {
          "tagName": "_docloc",
          "text": ": api/abi"
        }
      ]
    },
    {
      "name": "Coder",
      "kind": "ClassDeclaration",
      "signature": "export abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name!: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type!: string;\n\n    // ",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "Writer",
      "kind": "ClassDeclaration",
      "signature": "export class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data: Array<Uint8Array>;\n    #dataLength: number;\n\n    constructor() {\n        this.#data = [ ];\n        this.#dataLength = 0;\n    }\n\n    get data(): string {\n        return concat(this.#data);\n    }\n    get len",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    },
    {
      "name": "Reader",
      "kind": "ClassDeclaration",
      "signature": "export class Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    readonly all",
      "doc": "",
      "tags": [
        {
          "tagName": "_ignore",
          "text": ""
        }
      ]
    }
  ]
}
