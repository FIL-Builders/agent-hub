{
  "exports": [
    {
      "name": "adhocProfile",
      "kind": "FunctionDeclaration",
      "signature": "export async function adhocProfile<T>(\n  name: string,\n  f: () => Promise<T>\n): Promise<T> {\n  const globalAsAny = global as any;\n  assertHardhatInvariant(\n    \"adhocProfile\" in globalAsAny,\n    \"adhocProfile is missing. Are you running with --flamegraph?\"\n  );\n  return globalAsAny.adhocProfile(name",
      "doc": "Utility to create ad-hoc profiles when computing flamegraphs. You can think\nof these as virtual tasks that execute the function `f`.\n\nThis is an **unstable** feature, only meant for development. DO NOT use in\nproduction code nor plugins.",
      "tags": [
        {
          "tagName": "param",
          "text": "The name of the profile. Think of it as a virtual task name."
        },
        {
          "tagName": "param",
          "text": "The function you want to profile."
        }
      ]
    },
    {
      "name": "adhocProfile.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "adhocProfile.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "adhocProfile.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "adhocProfile.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "adhocProfileSync",
      "kind": "FunctionDeclaration",
      "signature": "export function adhocProfileSync<T>(name: string, f: () => T): T {\n  const globalAsAny = global as any;\n  assertHardhatInvariant(\n    \"adhocProfileSync\" in globalAsAny,\n    \"adhocProfileSync is missing. Are you running with --flamegraph?\"\n  );\n  return globalAsAny.adhocProfileSync(name, f);\n}",
      "doc": "Sync version of adhocProfile",
      "tags": [
        {
          "tagName": "see",
          "text": ""
        }
      ]
    },
    {
      "name": "ProviderWrapper",
      "kind": "ClassDeclaration",
      "signature": "export abstract class ProviderWrapper\n  extends EventEmitterWrapper\n  implements EIP1193Provider\n{\n  constructor(protected readonly _wrappedProvider: EIP1193Provider) {\n    super(_wrappedProvider);\n  }\n\n  public abstract request(args: RequestArguments): Promise<unknown>;\n\n  /**\n   * Extract the para",
      "doc": "A wrapper class that makes it easy to implement the EIP1193 (Javascript Ethereum Provider) standard.\nIt comes baked in with all EventEmitter methods needed,\nwhich will be added to the provider supplied in the constructor.\nIt also provides the interface for the standard .request() method as an abstract method.",
      "tags": []
    },
    {
      "name": "HardhatPluginError",
      "kind": "ClassDeclaration",
      "signature": "export class HardhatPluginError extends CustomError {\n  public static isHardhatPluginError(other: any): other is HardhatPluginError {\n    return (\n      other !== undefined &&\n      other !== null &&\n      other._isHardhatPluginError === true\n    );\n  }\n\n  public readonly pluginName: string;\n\n  priv",
      "doc": "This class is used to throw errors from hardhat plugins made by third parties.",
      "tags": []
    },
    {
      "name": "NomicLabsHardhatPluginError",
      "kind": "ClassDeclaration",
      "signature": "export class NomicLabsHardhatPluginError extends HardhatPluginError {\n  public static isNomicLabsHardhatPluginError(\n    other: any\n  ): other is NomicLabsHardhatPluginError {\n    return (\n      other !== undefined &&\n      other !== null &&\n      other._isNomicLabsHardhatPluginError === true\n    );",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyObject",
      "kind": "FunctionDeclaration",
      "signature": "export function lazyObject<T extends object>(objectCreator: () => T): T {\n  return createLazyProxy(\n    objectCreator,\n    (getRealTarget) => ({\n      [inspect](\n        depth: number,\n        options: InspectOptions,\n        inspectFn: (\n          object: any,\n          options: InspectOptions\n    ",
      "doc": "This module provides function to implement proxy-based object, functions, and\nclasses (they are functions). They receive an initializer function that it's\nnot used until someone interacts with the lazy element.\n\nThis functions can also be used like a lazy `require`, creating a proxy that\ndoesn't require the module until needed.\n\nThe disadvantage of using this technique is that the type information is\nlost wrt `import`, as `require` returns an `any. If done with enough care,\nthis can be manually fixed.\n\nTypeScript doesn't emit `require` calls for modules that are imported only\nbecause of their types. So if one uses lazyObject or lazyFunction along with\na normal ESM import you can pass the module's type to this function.\n\nAn example of this can be:\n\n   import findUpT from \"find-up\";\n   export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n\nYou can also use it with named exports:\n\n   import { EthT } from \"web3x/eth\";\n   const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);",
      "tags": []
    },
    {
      "name": "lazyFunction",
      "kind": "FunctionDeclaration",
      "signature": "export function lazyFunction<T extends Function>(functionCreator: () => T): T {\n  return createLazyProxy(\n    functionCreator,\n    (getRealTarget) => {\n      function dummyTarget() {}\n\n      (dummyTarget as any)[inspect] = function (\n        depth: number,\n        options: InspectOptions,\n        in",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.apply",
      "kind": "MethodSignature",
      "signature": "apply(this:Function,thisArg:any,argArray?:any):any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.call",
      "kind": "MethodSignature",
      "signature": "call(this:Function,thisArg:any,...argArray:any[]):any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.bind",
      "kind": "MethodSignature",
      "signature": "bind(this:Function,thisArg:any,...argArray:any[]):any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.prototype",
      "kind": "PropertySignature",
      "signature": "prototype:any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.arguments",
      "kind": "PropertySignature",
      "signature": "arguments:any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.caller",
      "kind": "PropertySignature",
      "signature": "caller:Function;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.name",
      "kind": "PropertySignature",
      "signature": "readonly name:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.__@hasInstance@38",
      "kind": "MethodSignature",
      "signature": "[Symbol.hasInstance](value:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.__@metadata@40",
      "kind": "PropertySignature",
      "signature": "[Symbol.metadata]:DecoratorMetadata|null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_NAME",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_NAME = \"hardhat\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "resetHardhatContext",
      "kind": "FunctionDeclaration",
      "signature": "export function resetHardhatContext() {\n  if (HardhatContext.isCreated()) {\n    const ctx = HardhatContext.getHardhatContext();\n\n    if (ctx.environment !== undefined) {\n      const globalAsAny = global as any;\n      for (const key of Object.keys(ctx.environment)) {\n        globalAsAny.hre = undefin",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatUserConfig {\n  defaultNetwork?: string;\n  paths?: ProjectPathsUserConfig;\n  networks?: NetworksUserConfig;\n  solidity?: SolidityUserConfig;\n  mocha?: Mocha.MochaOptions;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "task",
      "kind": "FunctionDeclaration",
      "signature": "export function task<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  description?: string,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;",
      "doc": "Creates a task, overriding any previous task with the same name.",
      "tags": [
        {
          "tagName": "remarks",
          "text": "The action must await every async call made within it."
        },
        {
          "tagName": "param",
          "text": "The task's name."
        },
        {
          "tagName": "param",
          "text": "The task's description."
        },
        {
          "tagName": "param",
          "text": "The task's action."
        },
        {
          "tagName": "returns",
          "text": "A task definition."
        }
      ]
    },
    {
      "name": "task.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task",
      "kind": "FunctionDeclaration",
      "signature": "export function task<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  action: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;",
      "doc": "Creates a task without description, overriding any previous task\nwith the same name.",
      "tags": [
        {
          "tagName": "remarks",
          "text": "The action must await every async call made within it."
        },
        {
          "tagName": "param",
          "text": "The task's name."
        },
        {
          "tagName": "param",
          "text": "The task's action."
        },
        {
          "tagName": "returns",
          "text": "A task definition."
        }
      ]
    },
    {
      "name": "task.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task",
      "kind": "FunctionDeclaration",
      "signature": "export function task<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition {\n  const ctx = HardhatContext.getHardhatContext();\n  const dsl = ctx.tasksDSL;\n\n  if (descript",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask",
      "kind": "FunctionDeclaration",
      "signature": "export function subtask<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  description?: string,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;",
      "doc": "Creates a subtask, overriding any previous task with the same name.",
      "tags": [
        {
          "tagName": "remarks",
          "text": "The subtasks won't be displayed in the CLI help messages."
        },
        {
          "tagName": "remarks",
          "text": "The action must await every async call made within it."
        },
        {
          "tagName": "param",
          "text": "The task's name."
        },
        {
          "tagName": "param",
          "text": "The task's description."
        },
        {
          "tagName": "param",
          "text": "The task's action."
        },
        {
          "tagName": "returns",
          "text": "A task definition."
        }
      ]
    },
    {
      "name": "subtask.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask",
      "kind": "FunctionDeclaration",
      "signature": "export function subtask<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  action: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;",
      "doc": "Creates a subtask without description, overriding any previous\ntask with the same name.",
      "tags": [
        {
          "tagName": "remarks",
          "text": "The subtasks won't be displayed in the CLI help messages."
        },
        {
          "tagName": "remarks",
          "text": "The action must await every async call made within it."
        },
        {
          "tagName": "param",
          "text": "The task's name."
        },
        {
          "tagName": "param",
          "text": "The task's action."
        },
        {
          "tagName": "returns",
          "text": "A task definition."
        }
      ]
    },
    {
      "name": "subtask.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask",
      "kind": "FunctionDeclaration",
      "signature": "export function subtask<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition {\n  const ctx = HardhatContext.getHardhatContext();\n  const dsl = ctx.tasksDSL;\n\n  if (descr",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scope",
      "kind": "FunctionDeclaration",
      "signature": "export function scope(\n  name: string,\n  description?: string\n): ConfigurableScopeDefinition {\n  const ctx = HardhatContext.getHardhatContext();\n  const dsl = ctx.tasksDSL;\n\n  return dsl.scope(name, description);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "scope.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scope.task",
      "kind": "PropertySignature",
      "signature": "task: AddConfigurableTaskFunction;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scope.subtask",
      "kind": "PropertySignature",
      "signature": "subtask: AddConfigurableTaskFunction;",
      "doc": "",
      "tags": []
    },
    {
      "name": "extendEnvironment",
      "kind": "FunctionDeclaration",
      "signature": "export function extendEnvironment(extender: EnvironmentExtender) {\n  const ctx = HardhatContext.getHardhatContext();\n  ctx.environmentExtenders.push(extender);\n}",
      "doc": "Register an environment extender what will be run after the\nHardhat Runtime Environment is initialized.",
      "tags": [
        {
          "tagName": "param",
          "text": "A function that receives the Hardhat Runtime\nEnvironment."
        }
      ]
    },
    {
      "name": "extendConfig",
      "kind": "FunctionDeclaration",
      "signature": "export function extendConfig(extender: ConfigExtender) {\n  const ctx = HardhatContext.getHardhatContext();\n  ctx.configExtenders.push(extender);\n}",
      "doc": "Register a config extender what will be run after the\nHardhat Runtime Environment is initialized.",
      "tags": [
        {
          "tagName": "param",
          "text": "A function that receives the resolved config\nto be modified and the config provided by the user"
        }
      ]
    },
    {
      "name": "extendProvider",
      "kind": "FunctionDeclaration",
      "signature": "export function extendProvider(extender: ProviderExtender) {\n  const ctx = HardhatContext.getHardhatContext();\n  ctx.providerExtenders.push(extender);\n}",
      "doc": "Register a provider extender what will be run after the\nHardhat Runtime Environment is initialized.",
      "tags": [
        {
          "tagName": "param",
          "text": "A function that receives the current provider\nand returns a new one."
        }
      ]
    },
    {
      "name": "internalTask",
      "kind": "VariableDeclaration",
      "signature": "internalTask = subtask",
      "doc": "",
      "tags": []
    },
    {
      "name": "types",
      "kind": "VariableDeclaration",
      "signature": "types = argumentTypes",
      "doc": "",
      "tags": []
    },
    {
      "name": "vars",
      "kind": "VariableDeclaration",
      "signature": "vars = {\n  has: hasVar,\n  get: getVar,\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "validateSourceNameFormat",
      "kind": "FunctionDeclaration",
      "signature": "export function validateSourceNameFormat(sourceName: string) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    ",
      "doc": "This function validates the source name's format.\n\nIt throws if the format is invalid.\nIf it doesn't throw all you know is that the format is valid.",
      "tags": []
    },
    {
      "name": "isLocalSourceName",
      "kind": "FunctionDeclaration",
      "signature": "export async function isLocalSourceName(\n  projectRoot: string,\n  sourceName: string\n): Promise<boolean> {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.l",
      "doc": "This function returns true if the sourceName is, potentially, from a local\nfile. It doesn't validate that the file actually exists.\n\nThe source name must be in a valid format.",
      "tags": []
    },
    {
      "name": "isLocalSourceName.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isLocalSourceName.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isLocalSourceName.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isLocalSourceName.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "validateSourceNameExistenceAndCasing",
      "kind": "FunctionDeclaration",
      "signature": "export async function validateSourceNameExistenceAndCasing(\n  fromDir: string,\n  sourceName: string\n) {\n  const trueCaseSourceName = await getSourceNameTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      inco",
      "doc": "Validates that a source name exists, starting from `fromDir`, and has the\nright casing.\n\nThe source name must be in a valid format.",
      "tags": []
    },
    {
      "name": "validateSourceNameExistenceAndCasing.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "validateSourceNameExistenceAndCasing.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "validateSourceNameExistenceAndCasing.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "validateSourceNameExistenceAndCasing.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "localPathToSourceName",
      "kind": "FunctionDeclaration",
      "signature": "export async function localPathToSourceName(\n  projectRoot: string,\n  localFileAbsolutePath: string\n): Promise<string> {\n  const relativePath = path.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw n",
      "doc": "Returns the source name of an existing local file's absolute path.\n\nThrows is the file doesn't exist, it's not inside the project, or belongs\nto a library.",
      "tags": []
    },
    {
      "name": "localPathToSourceName.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "localPathToSourceName.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "localPathToSourceName.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "localPathToSourceName.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "localSourceNameToPath",
      "kind": "FunctionDeclaration",
      "signature": "export function localSourceNameToPath(\n  projectRoot: string,\n  sourceName: string\n): string {\n  return path.join(projectRoot, sourceName);\n}",
      "doc": "This function takes a valid local source name and returns its path. The\nsource name doesn't need to point to an existing file.",
      "tags": []
    },
    {
      "name": "normalizeSourceName",
      "kind": "FunctionDeclaration",
      "signature": "export function normalizeSourceName(sourceName: string): string {\n  return replaceBackslashes(path.normalize(sourceName));\n}",
      "doc": "Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n\nThe sourceName param doesn't have to be a valid source name. It can,\nfor example, be denormalized.",
      "tags": []
    },
    {
      "name": "isAbsolutePathSourceName",
      "kind": "FunctionDeclaration",
      "signature": "export function isAbsolutePathSourceName(sourceName: string): boolean {\n  return path.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}",
      "doc": "This function returns true if the sourceName is a unix absolute path or a\nplatform-dependent one.\n\nThis function is used instead of just `path.isAbsolute` to ensure that\nsource names never start with `/`, even on Windows.",
      "tags": []
    },
    {
      "name": "replaceBackslashes",
      "kind": "FunctionDeclaration",
      "signature": "export function replaceBackslashes(str: string): string {\n  // Based in the npm module slash\n  const isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n  const hasNonAscii = /[^\\u0000-\\u0080]+/.test(str);\n\n  if (isExtendedLengthPath || hasNonAscii) {\n    return str;\n  }\n\n  return str.replace(/\\\\/g, \"/\");",
      "doc": "This function replaces backslashes (\\\\) with slashes (/).\n\nNote that a source name must not contain backslashes.",
      "tags": []
    },
    {
      "name": "includesOwnPackageName",
      "kind": "FunctionDeclaration",
      "signature": "export async function includesOwnPackageName(\n  sourceName: string\n): Promise<boolean> {\n  const packageName = await getPackageName(sourceName);\n  if (packageName !== \"\") {\n    return sourceName.startsWith(`${packageName}/`);\n  }\n  return false;\n}",
      "doc": "This function returns true if the sourceName contains the current package's name\nas a substring",
      "tags": []
    },
    {
      "name": "includesOwnPackageName.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "includesOwnPackageName.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "includesOwnPackageName.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "includesOwnPackageName.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "applyRemappings",
      "kind": "FunctionDeclaration",
      "signature": "export function applyRemappings(\n  remappings: Record<string, string>,\n  sourceName: string\n): string {\n  const selectedRemapping = { from: \"\", to: \"\" };\n\n  for (const [from, to] of Object.entries(remappings)) {\n    if (\n      sourceName.startsWith(from) &&\n      from.length >= selectedRemapping.fro",
      "doc": "",
      "tags": []
    },
    {
      "name": "getFullyQualifiedName",
      "kind": "FunctionDeclaration",
      "signature": "export function getFullyQualifiedName(\n  sourceName: string,\n  contractName: string\n): string {\n  return `${sourceName}:${contractName}`;\n}",
      "doc": "Returns a fully qualified name from a sourceName and contractName.",
      "tags": []
    },
    {
      "name": "isFullyQualifiedName",
      "kind": "FunctionDeclaration",
      "signature": "export function isFullyQualifiedName(name: string): boolean {\n  return name.includes(\":\");\n}",
      "doc": "Returns true if a name is fully qualified, and not just a bare contract name.",
      "tags": []
    },
    {
      "name": "parseFullyQualifiedName",
      "kind": "FunctionDeclaration",
      "signature": "export function parseFullyQualifiedName(fullyQualifiedName: string): {\n  sourceName: string;\n  contractName: string;\n} {\n  const { sourceName, contractName } = parseName(fullyQualifiedName);\n\n  if (sourceName === undefined) {\n    throw new HardhatError(ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_N",
      "doc": "Parses a fully qualified name.",
      "tags": [
        {
          "tagName": "param",
          "text": "It MUST be a fully qualified name."
        },
        {
          "tagName": "throws",
          "text": "If the name is not fully qualified."
        }
      ]
    },
    {
      "name": "parseName",
      "kind": "FunctionDeclaration",
      "signature": "export function parseName(name: string): {\n  sourceName?: string;\n  contractName: string;\n} {\n  const parts = name.split(\":\");\n\n  if (parts.length === 1) {\n    return { contractName: parts[0] };\n  }\n\n  const contractName = parts[parts.length - 1];\n  const sourceName = parts.slice(0, parts.length - 1",
      "doc": "Parses a name, which can be a bare contract name, or a fully qualified name.",
      "tags": []
    },
    {
      "name": "findDistance",
      "kind": "FunctionDeclaration",
      "signature": "export function findDistance(a: string, b: string): number {\n  function _min(\n    _d0: number,\n    _d1: number,\n    _d2: number,\n    _bx: number,\n    _ay: number\n  ): number {\n    return _d0 < _d1 || _d2 < _d1\n      ? _d0 > _d2\n        ? _d2 + 1\n        : _d0 + 1\n      : _bx === _ay\n      ? _d1\n    ",
      "doc": "Returns the edit-distance between two given strings using Levenshtein distance.",
      "tags": [
        {
          "tagName": "param",
          "text": "First string being compared"
        },
        {
          "tagName": "param",
          "text": "Second string being compared"
        },
        {
          "tagName": "returns",
          "text": "distance between the two strings (lower number == more similar)"
        },
        {
          "tagName": "see",
          "text": "://github.com/gustf/js-levenshtein"
        },
        {
          "tagName": "license",
          "text": "MIT - https://github.com/gustf/js-levenshtein/blob/master/LICENSE"
        }
      ]
    },
    {
      "name": "ArgumentType",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ArgumentType<T> {\n  /**\n   * The type's name.\n   */\n  name: string;\n\n  /**\n   * Check if argument value is of type <T>.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param argumentValue - value to be validated\n   *\n   * @throws HH301 if",
      "doc": "This class is used to dynamically validate task's argument types.",
      "tags": []
    },
    {
      "name": "CLIArgumentType",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CLIArgumentType<T> extends ArgumentType<T> {\n  /**\n   * Parses strValue into T. This function MUST throw HH301 if it\n   * can parse the given value.\n   *\n   * @param argName argument's name - used for context in case of error.\n   * @param strValue argument's string value to be parse",
      "doc": "This is a special case of ArgumentType.\n\nThese types must have a human-friendly string representation, so that they\ncan be used as command line arguments.",
      "tags": []
    },
    {
      "name": "ConfigurableTaskDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConfigurableTaskDefinition {\n  setDescription(description: string): this;\n\n  setAction(action: ActionType<TaskArguments>): this;\n\n  addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;\n\n  addOp",
      "doc": "",
      "tags": []
    },
    {
      "name": "ConfigurableScopeDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConfigurableScopeDefinition {\n  setDescription(description: string): this;\n\n  task: AddConfigurableTaskFunction;\n  subtask: AddConfigurableTaskFunction;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ParamDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ParamDefinition<T> {\n  name: string;\n  defaultValue?: T;\n  type: ArgumentType<T>;\n  description?: string;\n  isOptional: boolean;\n  isFlag: boolean;\n  isVariadic: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "OptionalParamDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface OptionalParamDefinition<T> extends ParamDefinition<T> {\n  defaultValue: T;\n  isOptional: true;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CLIOptionalParamDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CLIOptionalParamDefinition<T>\n  extends OptionalParamDefinition<T> {\n  type: CLIArgumentType<T>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ParamDefinitionsMap",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ParamDefinitionsMap {\n  [paramName: string]: ParamDefinition<any>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "TaskDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TaskDefinition extends ConfigurableTaskDefinition {\n  readonly scope?: string;\n  readonly name: string;\n  readonly description?: string;\n  readonly action: ActionType<TaskArguments>;\n  readonly isSubtask: boolean;\n\n  // TODO: Rename this to something better. It doesn't include the p",
      "doc": "",
      "tags": []
    },
    {
      "name": "ScopeDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ScopeDefinition extends ConfigurableScopeDefinition {\n  readonly name: string;\n  readonly description?: string;\n  readonly tasks: TasksMap;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "TaskIdentifier",
      "kind": "TypeAliasDeclaration",
      "signature": "export type TaskIdentifier = string | { scope?: string; task: string };",
      "doc": "",
      "tags": []
    },
    {
      "name": "TaskArguments",
      "kind": "TypeAliasDeclaration",
      "signature": "export type TaskArguments = any;",
      "doc": "",
      "tags": [
        {
          "tagName": "type",
          "text": "{object-like} - the input arguments for a task.\n\nTaskArguments type is set to 'any' because it's interface is dynamic.\nIt's impossible in TypeScript to statically specify a variadic\nnumber of fields and at the same time define specific types for\\\nthe argument values.\n\nFor example, we could define:\ntype TaskArguments = Record<string, any>;\n\n...but then, we couldn't narrow the actual argument value's type in compile time,\nthus we have no other option than forcing it to be just 'any'."
        }
      ]
    },
    {
      "name": "SubtaskArguments",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SubtaskArguments {\n  [subtaskName: string]: TaskArguments;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RunSuperFunction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RunSuperFunction<TaskArgumentsT extends TaskArguments> {\n  (\n    taskArguments?: TaskArgumentsT,\n    subtaskArguments?: SubtaskArguments\n  ): Promise<any>;\n  isDefined: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ActionType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ActionType<TaskArgumentsT extends TaskArguments> = (\n  taskArgs: TaskArgumentsT,\n  env: HardhatRuntimeEnvironment,\n  runSuper: RunSuperFunction<TaskArgumentsT>\n) => Promise<any>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatArguments",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatArguments {\n  network?: string;\n  showStackTraces: boolean;\n  version: boolean;\n  help: boolean;\n  emoji: boolean;\n  config?: string;\n  verbose: boolean;\n  maxMemory?: number;\n  tsconfig?: string;\n  flamegraph?: boolean;\n  typecheck?: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatParamDefinitions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardhatParamDefinitions = {\n  [param in keyof Required<HardhatArguments>]: CLIOptionalParamDefinition<\n    HardhatArguments[param]\n  >;\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "TasksMap",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TasksMap {\n  [name: string]: TaskDefinition;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ScopesMap",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ScopesMap {\n  [scopeName: string]: ScopeDefinition;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RunTaskFunction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RunTaskFunction = (\n  taskIdentifier: TaskIdentifier,\n  taskArguments?: TaskArguments,\n  subtaskArguments?: SubtaskArguments\n) => Promise<any>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatRuntimeEnvironment",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatRuntimeEnvironment {\n  readonly config: HardhatConfig;\n  readonly userConfig: HardhatUserConfig;\n  readonly hardhatArguments: HardhatArguments;\n  readonly tasks: TasksMap;\n  readonly scopes: ScopesMap;\n  readonly run: RunTaskFunction;\n  readonly network: Network;\n  readonly a",
      "doc": "",
      "tags": []
    },
    {
      "name": "Network",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Network {\n  name: string;\n  config: NetworkConfig;\n  provider: EthereumProvider;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EnvironmentExtender",
      "kind": "TypeAliasDeclaration",
      "signature": "export type EnvironmentExtender = (env: HardhatRuntimeEnvironment) => void;",
      "doc": "A function that receives a HardhatRuntimeEnvironment and\nmodify its properties or add new ones.",
      "tags": []
    },
    {
      "name": "ProviderExtender",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProviderExtender = (\n  provider: EIP1193Provider,\n  config: HardhatConfig,\n  network: string\n) => EIP1193Provider | Promise<EIP1193Provider>;",
      "doc": "A function that receives a provider, crafts and returns a new one.\nAdding and modifying the current provider is preferred over ignoring it and returning a new instance.",
      "tags": []
    },
    {
      "name": "RequestArguments",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RequestArguments {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProviderRpcError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProviderRpcError extends Error {\n  code: number;\n  data?: unknown;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProviderMessage",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProviderMessage {\n  readonly type: string;\n  readonly data: unknown;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EthSubscription",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EthSubscription extends ProviderMessage {\n  readonly type: \"eth_subscription\";\n  readonly data: {\n    readonly subscription: string;\n    readonly result: unknown;\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProviderConnectInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProviderConnectInfo {\n  readonly chainId: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EIP1193Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EIP1193Provider extends EventEmitter {\n  request(args: RequestArguments): Promise<unknown>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcRequest {\n  jsonrpc: string;\n  method: string;\n  params: any[];\n  id: number;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcResponse",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcResponse {\n  jsonrpc: string;\n  id: number;\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EthereumProvider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EthereumProvider extends EIP1193Provider {\n  send(method: string, params?: any[]): Promise<any>;\n  sendAsync(\n    payload: JsonRpcRequest,\n    callback: (error: any, response: JsonRpcResponse) => void\n  ): void;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NetworksUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NetworksUserConfig {\n  hardhat?: HardhatNetworkUserConfig;\n\n  [networkName: string]: NetworkUserConfig | undefined;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NetworkUserConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type NetworkUserConfig =\n  | HardhatNetworkUserConfig\n  | HttpNetworkUserConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardforkHistoryUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardforkHistoryUserConfig {\n  [hardforkName: string]: number /* block number */;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkChainUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkChainUserConfig {\n  hardforkHistory?: HardforkHistoryUserConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkChainsUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkChainsUserConfig {\n  [chainId: number]: HardhatNetworkChainUserConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkUserConfig {\n  chainId?: number;\n  from?: string;\n  gas?: \"auto\" | number;\n  gasPrice?: \"auto\" | number;\n  gasMultiplier?: number;\n  initialBaseFeePerGas?: number;\n  hardfork?: string;\n  mining?: HardhatNetworkMiningUserConfig;\n  accounts?: HardhatNetworkAccountsUserCo",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkAccountsUserConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardhatNetworkAccountsUserConfig =\n  | HardhatNetworkAccountUserConfig[]\n  | HardhatNetworkHDAccountsUserConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkAccountUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkAccountUserConfig {\n  privateKey: string;\n  balance: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkHDAccountsUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkHDAccountsUserConfig {\n  mnemonic?: string;\n  initialIndex?: number;\n  count?: number;\n  path?: string;\n  accountsBalance?: string;\n  passphrase?: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HDAccountsUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HDAccountsUserConfig {\n  mnemonic: string;\n  initialIndex?: number;\n  count?: number;\n  path?: string;\n  passphrase?: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkForkingUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkForkingUserConfig {\n  enabled?: boolean;\n  url: string;\n  blockNumber?: number;\n  httpHeaders?: { [name: string]: string };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkAccountsUserConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HttpNetworkAccountsUserConfig =\n  | \"remote\"\n  | string[]\n  | HDAccountsUserConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HttpNetworkUserConfig {\n  chainId?: number;\n  from?: string;\n  gas?: \"auto\" | number;\n  gasPrice?: \"auto\" | number;\n  gasMultiplier?: number;\n  url?: string;\n  timeout?: number;\n  httpHeaders?: { [name: string]: string };\n  accounts?: HttpNetworkAccountsUserConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NetworksConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NetworksConfig {\n  hardhat: HardhatNetworkConfig;\n  localhost: HttpNetworkConfig;\n\n  [networkName: string]: NetworkConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NetworkConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type NetworkConfig = HardhatNetworkConfig | HttpNetworkConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardforkHistoryConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardforkHistoryConfig = Map<\n  /* hardforkName */ string,\n  /* blockNumber */ number\n>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkChainConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkChainConfig {\n  hardforkHistory: HardforkHistoryConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkChainsConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardhatNetworkChainsConfig = Map<\n  /* chainId */ number,\n  HardhatNetworkChainConfig\n>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkConfig {\n  chainId: number;\n  from?: string;\n  gas: \"auto\" | number;\n  gasPrice: \"auto\" | number;\n  gasMultiplier: number;\n  initialBaseFeePerGas?: number;\n  hardfork: string;\n  mining: HardhatNetworkMiningConfig;\n  accounts: HardhatNetworkAccountsConfig;\n  blockGasLim",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkAccountsConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardhatNetworkAccountsConfig =\n  | HardhatNetworkHDAccountsConfig\n  | HardhatNetworkAccountConfig[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkAccountConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkAccountConfig {\n  privateKey: string;\n  balance: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkHDAccountsConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkHDAccountsConfig {\n  mnemonic: string;\n  initialIndex: number;\n  count: number;\n  path: string;\n  accountsBalance: string;\n  passphrase: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkForkingConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkForkingConfig {\n  enabled: boolean;\n  url: string;\n  blockNumber?: number;\n  httpHeaders?: { [name: string]: string };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HttpNetworkConfig {\n  chainId?: number;\n  from?: string;\n  gas: \"auto\" | number;\n  gasPrice: \"auto\" | number;\n  gasMultiplier: number;\n  url: string;\n  timeout: number;\n  httpHeaders: { [name: string]: string };\n  accounts: HttpNetworkAccountsConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkAccountsConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HttpNetworkAccountsConfig =\n  | \"remote\"\n  | string[]\n  | HttpNetworkHDAccountsConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkHDAccountsConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HttpNetworkHDAccountsConfig {\n  mnemonic: string;\n  initialIndex: number;\n  count: number;\n  path: string;\n  passphrase: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkMiningConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkMiningConfig {\n  auto: boolean;\n  interval: number | [number, number];\n  mempool: HardhatNetworkMempoolConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkMiningUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkMiningUserConfig {\n  auto?: boolean;\n  interval?: number | [number, number];\n  mempool?: HardhatNetworkMempoolUserConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkMempoolConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkMempoolConfig {\n  order: string; // Guaranteed at runtime to be have a valid value\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkMempoolUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkMempoolUserConfig {\n  order?: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProjectPathsUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProjectPathsUserConfig {\n  root?: string;\n  cache?: string;\n  artifacts?: string;\n  sources?: string;\n  tests?: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProjectPathsConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProjectPathsConfig {\n  root: string;\n  configFile: string;\n  cache: string;\n  artifacts: string;\n  sources: string;\n  tests: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolidityUserConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type SolidityUserConfig = string | SolcUserConfig | MultiSolcUserConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolcUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolcUserConfig {\n  version: string;\n  settings?: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MultiSolcUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MultiSolcUserConfig {\n  compilers: SolcUserConfig[];\n  overrides?: Record<string, SolcUserConfig>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolcConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolcConfig {\n  version: string;\n  settings: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolidityConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolidityConfig {\n  compilers: SolcConfig[];\n  overrides: Record<string, SolcConfig>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatUserConfig {\n  defaultNetwork?: string;\n  paths?: ProjectPathsUserConfig;\n  networks?: NetworksUserConfig;\n  solidity?: SolidityUserConfig;\n  mocha?: Mocha.MochaOptions;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatConfig {\n  defaultNetwork: string;\n  paths: ProjectPathsConfig;\n  networks: NetworksConfig;\n  solidity: SolidityConfig;\n  mocha: Mocha.MochaOptions;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ConfigExtender",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ConfigExtender = (\n  config: HardhatConfig,\n  userConfig: Readonly<HardhatUserConfig>\n) => void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "RequestArguments",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RequestArguments {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProviderRpcError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProviderRpcError extends Error {\n  code: number;\n  data?: unknown;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProviderMessage",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProviderMessage {\n  readonly type: string;\n  readonly data: unknown;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EthSubscription",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EthSubscription extends ProviderMessage {\n  readonly type: \"eth_subscription\";\n  readonly data: {\n    readonly subscription: string;\n    readonly result: unknown;\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProviderConnectInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProviderConnectInfo {\n  readonly chainId: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EIP1193Provider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EIP1193Provider extends EventEmitter {\n  request(args: RequestArguments): Promise<unknown>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcRequest {\n  jsonrpc: string;\n  method: string;\n  params: any[];\n  id: number;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcResponse",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcResponse {\n  jsonrpc: string;\n  id: number;\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EthereumProvider",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EthereumProvider extends EIP1193Provider {\n  send(method: string, params?: any[]): Promise<any>;\n  sendAsync(\n    payload: JsonRpcRequest,\n    callback: (error: any, response: JsonRpcResponse) => void\n  ): void;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ArgumentType",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ArgumentType<T> {\n  /**\n   * The type's name.\n   */\n  name: string;\n\n  /**\n   * Check if argument value is of type <T>.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param argumentValue - value to be validated\n   *\n   * @throws HH301 if",
      "doc": "This class is used to dynamically validate task's argument types.",
      "tags": []
    },
    {
      "name": "CLIArgumentType",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CLIArgumentType<T> extends ArgumentType<T> {\n  /**\n   * Parses strValue into T. This function MUST throw HH301 if it\n   * can parse the given value.\n   *\n   * @param argName argument's name - used for context in case of error.\n   * @param strValue argument's string value to be parse",
      "doc": "This is a special case of ArgumentType.\n\nThese types must have a human-friendly string representation, so that they\ncan be used as command line arguments.",
      "tags": []
    },
    {
      "name": "ConfigurableTaskDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConfigurableTaskDefinition {\n  setDescription(description: string): this;\n\n  setAction(action: ActionType<TaskArguments>): this;\n\n  addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;\n\n  addOp",
      "doc": "",
      "tags": []
    },
    {
      "name": "ConfigurableScopeDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ConfigurableScopeDefinition {\n  setDescription(description: string): this;\n\n  task: AddConfigurableTaskFunction;\n  subtask: AddConfigurableTaskFunction;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ParamDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ParamDefinition<T> {\n  name: string;\n  defaultValue?: T;\n  type: ArgumentType<T>;\n  description?: string;\n  isOptional: boolean;\n  isFlag: boolean;\n  isVariadic: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "OptionalParamDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface OptionalParamDefinition<T> extends ParamDefinition<T> {\n  defaultValue: T;\n  isOptional: true;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CLIOptionalParamDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CLIOptionalParamDefinition<T>\n  extends OptionalParamDefinition<T> {\n  type: CLIArgumentType<T>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ParamDefinitionsMap",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ParamDefinitionsMap {\n  [paramName: string]: ParamDefinition<any>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "TaskDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TaskDefinition extends ConfigurableTaskDefinition {\n  readonly scope?: string;\n  readonly name: string;\n  readonly description?: string;\n  readonly action: ActionType<TaskArguments>;\n  readonly isSubtask: boolean;\n\n  // TODO: Rename this to something better. It doesn't include the p",
      "doc": "",
      "tags": []
    },
    {
      "name": "ScopeDefinition",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ScopeDefinition extends ConfigurableScopeDefinition {\n  readonly name: string;\n  readonly description?: string;\n  readonly tasks: TasksMap;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "TaskIdentifier",
      "kind": "TypeAliasDeclaration",
      "signature": "export type TaskIdentifier = string | { scope?: string; task: string };",
      "doc": "",
      "tags": []
    },
    {
      "name": "TaskArguments",
      "kind": "TypeAliasDeclaration",
      "signature": "export type TaskArguments = any;",
      "doc": "",
      "tags": [
        {
          "tagName": "type",
          "text": "{object-like} - the input arguments for a task.\n\nTaskArguments type is set to 'any' because it's interface is dynamic.\nIt's impossible in TypeScript to statically specify a variadic\nnumber of fields and at the same time define specific types for\\\nthe argument values.\n\nFor example, we could define:\ntype TaskArguments = Record<string, any>;\n\n...but then, we couldn't narrow the actual argument value's type in compile time,\nthus we have no other option than forcing it to be just 'any'."
        }
      ]
    },
    {
      "name": "SubtaskArguments",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SubtaskArguments {\n  [subtaskName: string]: TaskArguments;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RunSuperFunction",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RunSuperFunction<TaskArgumentsT extends TaskArguments> {\n  (\n    taskArguments?: TaskArgumentsT,\n    subtaskArguments?: SubtaskArguments\n  ): Promise<any>;\n  isDefined: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ActionType",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ActionType<TaskArgumentsT extends TaskArguments> = (\n  taskArgs: TaskArgumentsT,\n  env: HardhatRuntimeEnvironment,\n  runSuper: RunSuperFunction<TaskArgumentsT>\n) => Promise<any>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatArguments",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatArguments {\n  network?: string;\n  showStackTraces: boolean;\n  version: boolean;\n  help: boolean;\n  emoji: boolean;\n  config?: string;\n  verbose: boolean;\n  maxMemory?: number;\n  tsconfig?: string;\n  flamegraph?: boolean;\n  typecheck?: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatParamDefinitions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardhatParamDefinitions = {\n  [param in keyof Required<HardhatArguments>]: CLIOptionalParamDefinition<\n    HardhatArguments[param]\n  >;\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "TasksMap",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TasksMap {\n  [name: string]: TaskDefinition;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ScopesMap",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ScopesMap {\n  [scopeName: string]: ScopeDefinition;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RunTaskFunction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RunTaskFunction = (\n  taskIdentifier: TaskIdentifier,\n  taskArguments?: TaskArguments,\n  subtaskArguments?: SubtaskArguments\n) => Promise<any>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatRuntimeEnvironment",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatRuntimeEnvironment {\n  readonly config: HardhatConfig;\n  readonly userConfig: HardhatUserConfig;\n  readonly hardhatArguments: HardhatArguments;\n  readonly tasks: TasksMap;\n  readonly scopes: ScopesMap;\n  readonly run: RunTaskFunction;\n  readonly network: Network;\n  readonly a",
      "doc": "",
      "tags": []
    },
    {
      "name": "Network",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Network {\n  name: string;\n  config: NetworkConfig;\n  provider: EthereumProvider;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EnvironmentExtender",
      "kind": "TypeAliasDeclaration",
      "signature": "export type EnvironmentExtender = (env: HardhatRuntimeEnvironment) => void;",
      "doc": "A function that receives a HardhatRuntimeEnvironment and\nmodify its properties or add new ones.",
      "tags": []
    },
    {
      "name": "ProviderExtender",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProviderExtender = (\n  provider: EIP1193Provider,\n  config: HardhatConfig,\n  network: string\n) => EIP1193Provider | Promise<EIP1193Provider>;",
      "doc": "A function that receives a provider, crafts and returns a new one.\nAdding and modifying the current provider is preferred over ignoring it and returning a new instance.",
      "tags": []
    },
    {
      "name": "Artifacts",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Artifacts {\n  /**\n   * Reads an artifact.\n   *\n   * @param contractNameOrFullyQualifiedName The name of the contract.\n   *   It can be a contract bare contract name (e.g. \"Token\") if it's\n   *   unique in your project, or a fully qualified contract name\n   *   (e.g. \"contract/token.",
      "doc": "",
      "tags": []
    },
    {
      "name": "Artifact",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Artifact {\n  _format: string;\n  contractName: string;\n  sourceName: string;\n  abi: any[];\n  bytecode: string; // \"0x\"-prefixed hex string\n  deployedBytecode: string; // \"0x\"-prefixed hex string\n  linkReferences: LinkReferences;\n  deployedLinkReferences: LinkReferences;\n}",
      "doc": "An artifact representing the compilation output of a contract.\n\nThis file has just enough information to deploy the contract and interact\nwith an already deployed instance of it.\n\nFor debugging information and other extra information, you should look for\nits companion DebugFile, which should be stored right next to it.\n\nNote that DebugFiles are only generated for Solidity contracts.",
      "tags": []
    },
    {
      "name": "DebugFile",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DebugFile {\n  _format: string;\n  buildInfo: string;\n}",
      "doc": "A DebugFile contains any extra information about a Solidity contract that\nHardhat and its plugins need.\n\nThe current version of DebugFiles only contains a path to a BuildInfo file.",
      "tags": []
    },
    {
      "name": "BuildInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BuildInfo {\n  _format: string;\n  id: string;\n  solcVersion: string;\n  solcLongVersion: string;\n  input: CompilerInput;\n  output: CompilerOutput;\n}",
      "doc": "A BuildInfo is a file that contains all the information of a solc run. It\nincludes all the necessary information to recreate that exact same run, and\nall of its output.",
      "tags": []
    },
    {
      "name": "LinkReferences",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LinkReferences {\n  [libraryFileName: string]: {\n    [libraryName: string]: Array<{ length: number; start: number }>;\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerInput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerInput {\n  language: string;\n  sources: { [sourceName: string]: { content: string } };\n  settings: {\n    viaIR?: boolean;\n    optimizer: {\n      runs?: number;\n      enabled?: boolean;\n      details?: {\n        yulDetails: {\n          optimizerSteps: string;\n        };\n      ",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutputContract",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutputContract {\n  abi: any;\n  evm: {\n    bytecode: CompilerOutputBytecode;\n    deployedBytecode: CompilerOutputBytecode;\n    methodIdentifiers: {\n      [methodSignature: string]: string;\n    };\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutput {\n  sources: CompilerOutputSources;\n  contracts: {\n    [sourceName: string]: {\n      [contractName: string]: CompilerOutputContract;\n    };\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutputSource",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutputSource {\n  id: number;\n  ast: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutputSources",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutputSources {\n  [sourceName: string]: CompilerOutputSource;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutputBytecode",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutputBytecode {\n  object: string;\n  opcodes: string;\n  sourceMap: string;\n  linkReferences: {\n    [sourceName: string]: {\n      [libraryName: string]: Array<{ start: number; length: 20 }>;\n    };\n  };\n  immutableReferences?: {\n    [key: string]: Array<{ start: number; lengt",
      "doc": "",
      "tags": []
    },
    {
      "name": "ResolvedFile",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ResolvedFile {\n  library?: LibraryInfo;\n  sourceName: string;\n  absolutePath: string;\n  content: FileContent;\n  // IMPORTANT: Mapped to ctime, NOT mtime. mtime isn't updated when the file\n  // properties (e.g. its name) are changed, only when it's content changes.\n  lastModification",
      "doc": "A Solidity file.",
      "tags": []
    },
    {
      "name": "ArtifactsEmittedPerFile",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ArtifactsEmittedPerFile = Array<{\n  file: ResolvedFile;\n  artifactsEmitted: string[];\n}>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "LibraryInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LibraryInfo {\n  name: string;\n  version: string;\n}",
      "doc": "Information about an npm library.",
      "tags": []
    },
    {
      "name": "FileContent",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FileContent {\n  rawContent: string;\n  imports: string[];\n  versionPragmas: string[];\n}",
      "doc": "The content of a Solidity file. Including its raw content, its imports and\nversion pragma directives.",
      "tags": []
    },
    {
      "name": "CompilationJob",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJob {\n  emitsArtifacts(file: ResolvedFile): boolean;\n  hasSolc9573Bug(): boolean;\n  merge(other: CompilationJob): CompilationJob;\n  getResolvedFiles(): ResolvedFile[];\n  getSolcConfig(): SolcConfig;\n}",
      "doc": "A CompilationJob includes all the necessary information to generate artifacts\nfrom a group of files. This includes those files, their dependencies, and the\nversion and configuration of solc that should be used.",
      "tags": []
    },
    {
      "name": "DependencyGraph",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DependencyGraph {\n  getConnectedComponents(): DependencyGraph[];\n  getDependencies(file: ResolvedFile): ResolvedFile[];\n  getResolvedFiles(): ResolvedFile[];\n  getTransitiveDependencies(file: ResolvedFile): TransitiveDependency[];\n}",
      "doc": "A DependencyGraph represents a group of files and how they depend on each\nother.",
      "tags": []
    },
    {
      "name": "TransitiveDependency",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransitiveDependency {\n  dependency: ResolvedFile;\n\n  /**\n   * The list of intermediate files between the file and the dependency\n   * this is not guaranteed to be the shortest path\n   */\n  path: ResolvedFile[];\n}",
      "doc": "Used as part of the return value of DependencyGraph.getTransitiveDependencies",
      "tags": []
    },
    {
      "name": "CompilationJobsCreationResult",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJobsCreationResult {\n  jobs: CompilationJob[];\n  errors: CompilationJobCreationError[];\n}",
      "doc": "An object with a list of successfully created compilation jobs and a list of\nerrors. The `errors` entry maps error codes (that come from the\nCompilationJobCreationError enum) to the source names of the files that\ncaused that error.",
      "tags": []
    },
    {
      "name": "CompilationJobCreationError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJobCreationError {\n  reason: CompilationJobCreationErrorReason;\n  file: ResolvedFile;\n  extra?: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilationJobCreationErrorReason",
      "kind": "EnumDeclaration",
      "signature": "export enum CompilationJobCreationErrorReason {\n  OTHER_ERROR = \"other\",\n  NO_COMPATIBLE_SOLC_VERSION_FOUND = \"no-compatible-solc-version-found\",\n  INCOMPATIBLE_OVERRIDDEN_SOLC_VERSION = \"incompatible-overridden-solc-version\",\n  DIRECTLY_IMPORTS_INCOMPATIBLE_FILE = \"directly-imports-incompatible-fil",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolcBuild",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolcBuild {\n  version: string;\n  longVersion: string;\n  compilerPath: string;\n  isSolcJs: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcServer",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcServer {\n  listen(): Promise<{ address: string; port: number }>;\n  waitUntilClosed(): Promise<void>;\n\n  close(): Promise<void>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NetworksUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NetworksUserConfig {\n  hardhat?: HardhatNetworkUserConfig;\n\n  [networkName: string]: NetworkUserConfig | undefined;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NetworkUserConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type NetworkUserConfig =\n  | HardhatNetworkUserConfig\n  | HttpNetworkUserConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardforkHistoryUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardforkHistoryUserConfig {\n  [hardforkName: string]: number /* block number */;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkChainUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkChainUserConfig {\n  hardforkHistory?: HardforkHistoryUserConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkChainsUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkChainsUserConfig {\n  [chainId: number]: HardhatNetworkChainUserConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkUserConfig {\n  chainId?: number;\n  from?: string;\n  gas?: \"auto\" | number;\n  gasPrice?: \"auto\" | number;\n  gasMultiplier?: number;\n  initialBaseFeePerGas?: number;\n  hardfork?: string;\n  mining?: HardhatNetworkMiningUserConfig;\n  accounts?: HardhatNetworkAccountsUserCo",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkAccountsUserConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardhatNetworkAccountsUserConfig =\n  | HardhatNetworkAccountUserConfig[]\n  | HardhatNetworkHDAccountsUserConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkAccountUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkAccountUserConfig {\n  privateKey: string;\n  balance: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkHDAccountsUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkHDAccountsUserConfig {\n  mnemonic?: string;\n  initialIndex?: number;\n  count?: number;\n  path?: string;\n  accountsBalance?: string;\n  passphrase?: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HDAccountsUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HDAccountsUserConfig {\n  mnemonic: string;\n  initialIndex?: number;\n  count?: number;\n  path?: string;\n  passphrase?: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkForkingUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkForkingUserConfig {\n  enabled?: boolean;\n  url: string;\n  blockNumber?: number;\n  httpHeaders?: { [name: string]: string };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkAccountsUserConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HttpNetworkAccountsUserConfig =\n  | \"remote\"\n  | string[]\n  | HDAccountsUserConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HttpNetworkUserConfig {\n  chainId?: number;\n  from?: string;\n  gas?: \"auto\" | number;\n  gasPrice?: \"auto\" | number;\n  gasMultiplier?: number;\n  url?: string;\n  timeout?: number;\n  httpHeaders?: { [name: string]: string };\n  accounts?: HttpNetworkAccountsUserConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NetworksConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NetworksConfig {\n  hardhat: HardhatNetworkConfig;\n  localhost: HttpNetworkConfig;\n\n  [networkName: string]: NetworkConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NetworkConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type NetworkConfig = HardhatNetworkConfig | HttpNetworkConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardforkHistoryConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardforkHistoryConfig = Map<\n  /* hardforkName */ string,\n  /* blockNumber */ number\n>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkChainConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkChainConfig {\n  hardforkHistory: HardforkHistoryConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkChainsConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardhatNetworkChainsConfig = Map<\n  /* chainId */ number,\n  HardhatNetworkChainConfig\n>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkConfig {\n  chainId: number;\n  from?: string;\n  gas: \"auto\" | number;\n  gasPrice: \"auto\" | number;\n  gasMultiplier: number;\n  initialBaseFeePerGas?: number;\n  hardfork: string;\n  mining: HardhatNetworkMiningConfig;\n  accounts: HardhatNetworkAccountsConfig;\n  blockGasLim",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkAccountsConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HardhatNetworkAccountsConfig =\n  | HardhatNetworkHDAccountsConfig\n  | HardhatNetworkAccountConfig[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkAccountConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkAccountConfig {\n  privateKey: string;\n  balance: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkHDAccountsConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkHDAccountsConfig {\n  mnemonic: string;\n  initialIndex: number;\n  count: number;\n  path: string;\n  accountsBalance: string;\n  passphrase: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkForkingConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkForkingConfig {\n  enabled: boolean;\n  url: string;\n  blockNumber?: number;\n  httpHeaders?: { [name: string]: string };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HttpNetworkConfig {\n  chainId?: number;\n  from?: string;\n  gas: \"auto\" | number;\n  gasPrice: \"auto\" | number;\n  gasMultiplier: number;\n  url: string;\n  timeout: number;\n  httpHeaders: { [name: string]: string };\n  accounts: HttpNetworkAccountsConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkAccountsConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type HttpNetworkAccountsConfig =\n  | \"remote\"\n  | string[]\n  | HttpNetworkHDAccountsConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpNetworkHDAccountsConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HttpNetworkHDAccountsConfig {\n  mnemonic: string;\n  initialIndex: number;\n  count: number;\n  path: string;\n  passphrase: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkMiningConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkMiningConfig {\n  auto: boolean;\n  interval: number | [number, number];\n  mempool: HardhatNetworkMempoolConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkMiningUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkMiningUserConfig {\n  auto?: boolean;\n  interval?: number | [number, number];\n  mempool?: HardhatNetworkMempoolUserConfig;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkMempoolConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkMempoolConfig {\n  order: string; // Guaranteed at runtime to be have a valid value\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatNetworkMempoolUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatNetworkMempoolUserConfig {\n  order?: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProjectPathsUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProjectPathsUserConfig {\n  root?: string;\n  cache?: string;\n  artifacts?: string;\n  sources?: string;\n  tests?: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProjectPathsConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ProjectPathsConfig {\n  root: string;\n  configFile: string;\n  cache: string;\n  artifacts: string;\n  sources: string;\n  tests: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolidityUserConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type SolidityUserConfig = string | SolcUserConfig | MultiSolcUserConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolcUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolcUserConfig {\n  version: string;\n  settings?: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MultiSolcUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MultiSolcUserConfig {\n  compilers: SolcUserConfig[];\n  overrides?: Record<string, SolcUserConfig>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolcConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolcConfig {\n  version: string;\n  settings: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolidityConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolidityConfig {\n  compilers: SolcConfig[];\n  overrides: Record<string, SolcConfig>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatUserConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatUserConfig {\n  defaultNetwork?: string;\n  paths?: ProjectPathsUserConfig;\n  networks?: NetworksUserConfig;\n  solidity?: SolidityUserConfig;\n  mocha?: Mocha.MochaOptions;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatConfig {\n  defaultNetwork: string;\n  paths: ProjectPathsConfig;\n  networks: NetworksConfig;\n  solidity: SolidityConfig;\n  mocha: Mocha.MochaOptions;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ConfigExtender",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ConfigExtender = (\n  config: HardhatConfig,\n  userConfig: Readonly<HardhatUserConfig>\n) => void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "Artifacts",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Artifacts {\n  /**\n   * Reads an artifact.\n   *\n   * @param contractNameOrFullyQualifiedName The name of the contract.\n   *   It can be a contract bare contract name (e.g. \"Token\") if it's\n   *   unique in your project, or a fully qualified contract name\n   *   (e.g. \"contract/token.",
      "doc": "",
      "tags": []
    },
    {
      "name": "Artifact",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Artifact {\n  _format: string;\n  contractName: string;\n  sourceName: string;\n  abi: any[];\n  bytecode: string; // \"0x\"-prefixed hex string\n  deployedBytecode: string; // \"0x\"-prefixed hex string\n  linkReferences: LinkReferences;\n  deployedLinkReferences: LinkReferences;\n}",
      "doc": "An artifact representing the compilation output of a contract.\n\nThis file has just enough information to deploy the contract and interact\nwith an already deployed instance of it.\n\nFor debugging information and other extra information, you should look for\nits companion DebugFile, which should be stored right next to it.\n\nNote that DebugFiles are only generated for Solidity contracts.",
      "tags": []
    },
    {
      "name": "DebugFile",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DebugFile {\n  _format: string;\n  buildInfo: string;\n}",
      "doc": "A DebugFile contains any extra information about a Solidity contract that\nHardhat and its plugins need.\n\nThe current version of DebugFiles only contains a path to a BuildInfo file.",
      "tags": []
    },
    {
      "name": "BuildInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface BuildInfo {\n  _format: string;\n  id: string;\n  solcVersion: string;\n  solcLongVersion: string;\n  input: CompilerInput;\n  output: CompilerOutput;\n}",
      "doc": "A BuildInfo is a file that contains all the information of a solc run. It\nincludes all the necessary information to recreate that exact same run, and\nall of its output.",
      "tags": []
    },
    {
      "name": "LinkReferences",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LinkReferences {\n  [libraryFileName: string]: {\n    [libraryName: string]: Array<{ length: number; start: number }>;\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerInput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerInput {\n  language: string;\n  sources: { [sourceName: string]: { content: string } };\n  settings: {\n    viaIR?: boolean;\n    optimizer: {\n      runs?: number;\n      enabled?: boolean;\n      details?: {\n        yulDetails: {\n          optimizerSteps: string;\n        };\n      ",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutputContract",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutputContract {\n  abi: any;\n  evm: {\n    bytecode: CompilerOutputBytecode;\n    deployedBytecode: CompilerOutputBytecode;\n    methodIdentifiers: {\n      [methodSignature: string]: string;\n    };\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutput {\n  sources: CompilerOutputSources;\n  contracts: {\n    [sourceName: string]: {\n      [contractName: string]: CompilerOutputContract;\n    };\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutputSource",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutputSource {\n  id: number;\n  ast: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutputSources",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutputSources {\n  [sourceName: string]: CompilerOutputSource;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerOutputBytecode",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilerOutputBytecode {\n  object: string;\n  opcodes: string;\n  sourceMap: string;\n  linkReferences: {\n    [sourceName: string]: {\n      [libraryName: string]: Array<{ start: number; length: 20 }>;\n    };\n  };\n  immutableReferences?: {\n    [key: string]: Array<{ start: number; lengt",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcServer",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcServer {\n  listen(): Promise<{ address: string; port: number }>;\n  waitUntilClosed(): Promise<void>;\n\n  close(): Promise<void>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ResolvedFile",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ResolvedFile {\n  library?: LibraryInfo;\n  sourceName: string;\n  absolutePath: string;\n  content: FileContent;\n  // IMPORTANT: Mapped to ctime, NOT mtime. mtime isn't updated when the file\n  // properties (e.g. its name) are changed, only when it's content changes.\n  lastModification",
      "doc": "A Solidity file.",
      "tags": []
    },
    {
      "name": "ArtifactsEmittedPerFile",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ArtifactsEmittedPerFile = Array<{\n  file: ResolvedFile;\n  artifactsEmitted: string[];\n}>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "LibraryInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LibraryInfo {\n  name: string;\n  version: string;\n}",
      "doc": "Information about an npm library.",
      "tags": []
    },
    {
      "name": "FileContent",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FileContent {\n  rawContent: string;\n  imports: string[];\n  versionPragmas: string[];\n}",
      "doc": "The content of a Solidity file. Including its raw content, its imports and\nversion pragma directives.",
      "tags": []
    },
    {
      "name": "CompilationJob",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJob {\n  emitsArtifacts(file: ResolvedFile): boolean;\n  hasSolc9573Bug(): boolean;\n  merge(other: CompilationJob): CompilationJob;\n  getResolvedFiles(): ResolvedFile[];\n  getSolcConfig(): SolcConfig;\n}",
      "doc": "A CompilationJob includes all the necessary information to generate artifacts\nfrom a group of files. This includes those files, their dependencies, and the\nversion and configuration of solc that should be used.",
      "tags": []
    },
    {
      "name": "DependencyGraph",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DependencyGraph {\n  getConnectedComponents(): DependencyGraph[];\n  getDependencies(file: ResolvedFile): ResolvedFile[];\n  getResolvedFiles(): ResolvedFile[];\n  getTransitiveDependencies(file: ResolvedFile): TransitiveDependency[];\n}",
      "doc": "A DependencyGraph represents a group of files and how they depend on each\nother.",
      "tags": []
    },
    {
      "name": "TransitiveDependency",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransitiveDependency {\n  dependency: ResolvedFile;\n\n  /**\n   * The list of intermediate files between the file and the dependency\n   * this is not guaranteed to be the shortest path\n   */\n  path: ResolvedFile[];\n}",
      "doc": "Used as part of the return value of DependencyGraph.getTransitiveDependencies",
      "tags": []
    },
    {
      "name": "CompilationJobsCreationResult",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJobsCreationResult {\n  jobs: CompilationJob[];\n  errors: CompilationJobCreationError[];\n}",
      "doc": "An object with a list of successfully created compilation jobs and a list of\nerrors. The `errors` entry maps error codes (that come from the\nCompilationJobCreationError enum) to the source names of the files that\ncaused that error.",
      "tags": []
    },
    {
      "name": "CompilationJobCreationError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJobCreationError {\n  reason: CompilationJobCreationErrorReason;\n  file: ResolvedFile;\n  extra?: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilationJobCreationErrorReason",
      "kind": "EnumDeclaration",
      "signature": "export enum CompilationJobCreationErrorReason {\n  OTHER_ERROR = \"other\",\n  NO_COMPATIBLE_SOLC_VERSION_FOUND = \"no-compatible-solc-version-found\",\n  INCOMPATIBLE_OVERRIDDEN_SOLC_VERSION = \"incompatible-overridden-solc-version\",\n  DIRECTLY_IMPORTS_INCOMPATIBLE_FILE = \"directly-imports-incompatible-fil",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolcBuild",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolcBuild {\n  version: string;\n  longVersion: string;\n  compilerPath: string;\n  isSolcJs: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcServer",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcServer {\n  listen(): Promise<{ address: string; port: number }>;\n  waitUntilClosed(): Promise<void>;\n\n  close(): Promise<void>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ResolvedFile",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ResolvedFile {\n  library?: LibraryInfo;\n  sourceName: string;\n  absolutePath: string;\n  content: FileContent;\n  // IMPORTANT: Mapped to ctime, NOT mtime. mtime isn't updated when the file\n  // properties (e.g. its name) are changed, only when it's content changes.\n  lastModification",
      "doc": "A Solidity file.",
      "tags": []
    },
    {
      "name": "ArtifactsEmittedPerFile",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ArtifactsEmittedPerFile = Array<{\n  file: ResolvedFile;\n  artifactsEmitted: string[];\n}>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "LibraryInfo",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LibraryInfo {\n  name: string;\n  version: string;\n}",
      "doc": "Information about an npm library.",
      "tags": []
    },
    {
      "name": "FileContent",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FileContent {\n  rawContent: string;\n  imports: string[];\n  versionPragmas: string[];\n}",
      "doc": "The content of a Solidity file. Including its raw content, its imports and\nversion pragma directives.",
      "tags": []
    },
    {
      "name": "CompilationJob",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJob {\n  emitsArtifacts(file: ResolvedFile): boolean;\n  hasSolc9573Bug(): boolean;\n  merge(other: CompilationJob): CompilationJob;\n  getResolvedFiles(): ResolvedFile[];\n  getSolcConfig(): SolcConfig;\n}",
      "doc": "A CompilationJob includes all the necessary information to generate artifacts\nfrom a group of files. This includes those files, their dependencies, and the\nversion and configuration of solc that should be used.",
      "tags": []
    },
    {
      "name": "DependencyGraph",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DependencyGraph {\n  getConnectedComponents(): DependencyGraph[];\n  getDependencies(file: ResolvedFile): ResolvedFile[];\n  getResolvedFiles(): ResolvedFile[];\n  getTransitiveDependencies(file: ResolvedFile): TransitiveDependency[];\n}",
      "doc": "A DependencyGraph represents a group of files and how they depend on each\nother.",
      "tags": []
    },
    {
      "name": "TransitiveDependency",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TransitiveDependency {\n  dependency: ResolvedFile;\n\n  /**\n   * The list of intermediate files between the file and the dependency\n   * this is not guaranteed to be the shortest path\n   */\n  path: ResolvedFile[];\n}",
      "doc": "Used as part of the return value of DependencyGraph.getTransitiveDependencies",
      "tags": []
    },
    {
      "name": "CompilationJobsCreationResult",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJobsCreationResult {\n  jobs: CompilationJob[];\n  errors: CompilationJobCreationError[];\n}",
      "doc": "An object with a list of successfully created compilation jobs and a list of\nerrors. The `errors` entry maps error codes (that come from the\nCompilationJobCreationError enum) to the source names of the files that\ncaused that error.",
      "tags": []
    },
    {
      "name": "CompilationJobCreationError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CompilationJobCreationError {\n  reason: CompilationJobCreationErrorReason;\n  file: ResolvedFile;\n  extra?: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilationJobCreationErrorReason",
      "kind": "EnumDeclaration",
      "signature": "export enum CompilationJobCreationErrorReason {\n  OTHER_ERROR = \"other\",\n  NO_COMPATIBLE_SOLC_VERSION_FOUND = \"no-compatible-solc-version-found\",\n  INCOMPATIBLE_OVERRIDDEN_SOLC_VERSION = \"incompatible-overridden-solc-version\",\n  DIRECTLY_IMPORTS_INCOMPATIBLE_FILE = \"directly-imports-incompatible-fil",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolcBuild",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SolcBuild {\n  version: string;\n  longVersion: string;\n  compilerPath: string;\n  isSolcJs: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "resetHardhatContext",
      "kind": "FunctionDeclaration",
      "signature": "export function resetHardhatContext() {\n  if (HardhatContext.isCreated()) {\n    const ctx = HardhatContext.getHardhatContext();\n\n    if (ctx.environment !== undefined) {\n      const globalAsAny = global as any;\n      for (const key of Object.keys(ctx.environment)) {\n        globalAsAny.hre = undefin",
      "doc": "",
      "tags": []
    },
    {
      "name": "GlobalWithHardhatContext",
      "kind": "TypeAliasDeclaration",
      "signature": "export type GlobalWithHardhatContext = typeof global & {\n  __hardhatContext: HardhatContext;\n};",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatContext",
      "kind": "ClassDeclaration",
      "signature": "export class HardhatContext {\n  constructor() {\n    this.varsManager = new VarsManager(getVarsFilePath());\n  }\n\n  public static isCreated(): boolean {\n    const globalWithHardhatContext = global as GlobalWithHardhatContext;\n    return globalWithHardhatContext.__hardhatContext !== undefined;\n  }\n\n  p",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NAME",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NAME = \"Hardhat\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_EXECUTABLE_NAME",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_EXECUTABLE_NAME = \"hardhat\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_NAME",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_NAME = \"hardhat\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "SOLIDITY_FILES_CACHE_FILENAME",
      "kind": "VariableDeclaration",
      "signature": "SOLIDITY_FILES_CACHE_FILENAME = \"solidity-files-cache.json\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_SUPPORTED_HARDFORKS",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_SUPPORTED_HARDFORKS = [\n  // \"chainstart\",\n  // \"homestead\",\n  // \"dao\",\n  // \"tangerineWhistle\",\n  // \"spuriousDragon\",\n  \"byzantium\",\n  \"constantinople\",\n  \"petersburg\",\n  \"istanbul\",\n  \"muirGlacier\",\n  \"berlin\",\n  \"london\",\n  \"arrowGlacier\",\n  \"grayGlacier\",\n  \"merge\",\n  \"shanghai",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_MEMPOOL_SUPPORTED_ORDERS",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_MEMPOOL_SUPPORTED_ORDERS = [\"fifo\", \"priority\"] as const",
      "doc": "",
      "tags": []
    },
    {
      "name": "ARTIFACT_FORMAT_VERSION",
      "kind": "VariableDeclaration",
      "signature": "ARTIFACT_FORMAT_VERSION = \"hh-sol-artifact-1\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "DEBUG_FILE_FORMAT_VERSION",
      "kind": "VariableDeclaration",
      "signature": "DEBUG_FILE_FORMAT_VERSION = \"hh-sol-dbg-1\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "BUILD_INFO_FORMAT_VERSION",
      "kind": "VariableDeclaration",
      "signature": "BUILD_INFO_FORMAT_VERSION = \"hh-sol-build-info-1\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "BUILD_INFO_DIR_NAME",
      "kind": "VariableDeclaration",
      "signature": "BUILD_INFO_DIR_NAME = \"build-info\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "EDIT_DISTANCE_THRESHOLD",
      "kind": "VariableDeclaration",
      "signature": "EDIT_DISTANCE_THRESHOLD = 3",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_RESET_EVENT",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_RESET_EVENT = \"hardhatNetworkReset\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT =\n  \"hardhatNetworkRevertSnapshot\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "getArtifactFromContractOutput",
      "kind": "FunctionDeclaration",
      "signature": "export function getArtifactFromContractOutput(\n  sourceName: string,\n  contractName: string,\n  contractOutput: any\n): Artifact {\n  const evmBytecode = contractOutput.evm?.bytecode;\n  let bytecode: string = evmBytecode?.object ?? \"\";\n\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode ",
      "doc": "Retrieves an artifact for the given `contractName` from the compilation output.",
      "tags": [
        {
          "tagName": "param",
          "text": "The contract's source name."
        },
        {
          "tagName": "param",
          "text": "the contract's name."
        },
        {
          "tagName": "param",
          "text": "the contract's compilation output as emitted by `solc`."
        }
      ]
    },
    {
      "name": "getArtifactFromContractOutput._format",
      "kind": "PropertySignature",
      "signature": "_format: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getArtifactFromContractOutput.contractName",
      "kind": "PropertySignature",
      "signature": "contractName: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getArtifactFromContractOutput.sourceName",
      "kind": "PropertySignature",
      "signature": "sourceName: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getArtifactFromContractOutput.abi",
      "kind": "PropertySignature",
      "signature": "abi: any[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getArtifactFromContractOutput.bytecode",
      "kind": "PropertySignature",
      "signature": "bytecode: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getArtifactFromContractOutput.deployedBytecode",
      "kind": "PropertySignature",
      "signature": "deployedBytecode: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getArtifactFromContractOutput.linkReferences",
      "kind": "PropertySignature",
      "signature": "linkReferences: LinkReferences;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getArtifactFromContractOutput.deployedLinkReferences",
      "kind": "PropertySignature",
      "signature": "deployedLinkReferences: LinkReferences;",
      "doc": "",
      "tags": []
    },
    {
      "name": "Artifacts",
      "kind": "ClassDeclaration",
      "signature": "export class Artifacts implements IArtifacts {\n  private _validArtifacts: Array<{ sourceName: string; artifacts: string[] }>;\n\n  // Undefined means that the cache is disabled.\n  private _cache?: Cache = {\n    artifactNameToArtifactPathCache: new Map(),\n    artifactFQNToBuildInfoPathCache: new Map(),",
      "doc": "",
      "tags": []
    },
    {
      "name": "Semaphore",
      "kind": "ClassDeclaration",
      "signature": "export class Semaphore {\n  public count: number;\n  private _tasks: Array<() => void> = [];\n\n  constructor(count: number) {\n    this.count = count;\n  }\n\n  public acquire() {\n    return new Promise<() => void>((res) => {\n      const task = () => {\n        let released = false;\n        res(() => {\n    ",
      "doc": "",
      "tags": []
    },
    {
      "name": "Mutex",
      "kind": "ClassDeclaration",
      "signature": "export class Mutex extends Semaphore {\n  constructor() {\n    super(1);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "weiToHumanReadableString",
      "kind": "FunctionDeclaration",
      "signature": "export function weiToHumanReadableString(wei: bigint | number): string {\n  if (typeof wei === \"number\") {\n    wei = BigInt(wei);\n  }\n\n  if (wei === 0n) {\n    return \"0 ETH\";\n  }\n\n  if (wei < 100_000n) {\n    return `${wei.toString()} wei`;\n  }\n\n  if (wei < 10n ** 14n) {\n    return `${toDecimalString(",
      "doc": "This function turns a wei value in a human readable string. It shows values\nin ETH, gwei or wei, depending on how large it is.\n\nIt never show more than 99999 wei or gwei, moving to the larger denominator\nwhen necessary.\n\nIt never shows more than 4 decimal digits. Adapting denominator and\ntruncating as necessary.",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries",
      "kind": "FunctionDeclaration",
      "signature": "export function unsafeObjectEntries<T extends object>(o: T) {\n  return Object.entries(o) as Array<[keyof T, T[keyof T]]>;\n}",
      "doc": "This function is a typed version of `Object.entries`. Note that it's type\nunsafe. You have to be sure that `o` has exactly the same keys as `T`.",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectEntries.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "unsafeObjectKeys",
      "kind": "VariableDeclaration",
      "signature": "unsafeObjectKeys = Object.keys as <T>(\n  o: T\n) => Array<Extract<keyof T, string>>",
      "doc": "",
      "tags": []
    },
    {
      "name": "pluralize",
      "kind": "FunctionDeclaration",
      "signature": "export function pluralize(n: number, singular: string, plural?: string) {\n  if (n === 1) {\n    return singular;\n  }\n\n  if (plural !== undefined) {\n    return plural;\n  }\n\n  return `${singular}s`;\n}",
      "doc": "Returns the plural form of a word.",
      "tags": [
        {
          "tagName": "param",
          "text": "The number of things to represent. This dictates whether to return\nthe singular or plural form of the word."
        },
        {
          "tagName": "param",
          "text": "The singular form of the word."
        },
        {
          "tagName": "param",
          "text": "An optional plural form of the word. If non is given, the\nplural form is constructed by appending an \"s\" to the singular form."
        }
      ]
    },
    {
      "name": "replaceAll",
      "kind": "FunctionDeclaration",
      "signature": "export function replaceAll(\n  str: string,\n  toReplace: string,\n  replacement: string\n) {\n  return str.split(toReplace).join(replacement);\n}",
      "doc": "Replaces all the instances of [[toReplace]] by [[replacement]] in [[str]].",
      "tags": []
    },
    {
      "name": "runScript",
      "kind": "FunctionDeclaration",
      "signature": "export async function runScript(\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  const { fork } = await import(\"child_process\");\n\n  return new Promise((resolve, reject) => {\n    const processExe",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScript.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScript.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScript.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScript.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScriptWithHardhat",
      "kind": "FunctionDeclaration",
      "signature": "export async function runScriptWithHardhat(\n  hardhatArguments: HardhatArguments,\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n\n  retu",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScriptWithHardhat.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScriptWithHardhat.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScriptWithHardhat.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "runScriptWithHardhat.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function requestJson(\n  url: string,\n  timeout?: number\n): Promise<unknown> {\n  const { request } = await import(\"undici\");\n\n  const controller = new AbortController();\n  const requestAborted = new Error(\"Request aborted: timeout reached\");\n\n  let timeoutId: ReturnType<typeof setTimeout",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestJson.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "shouldUseProxy",
      "kind": "FunctionDeclaration",
      "signature": "export function shouldUseProxy(url: string): boolean {\n  const { hostname } = new URL(url);\n  const noProxy = process.env.NO_PROXY;\n\n  if (hostname === \"localhost\" || hostname === \"127.0.0.1\" || noProxy === \"*\") {\n    return false;\n  }\n\n  if (noProxy !== undefined && noProxy !== \"\") {\n    const noPr",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles",
      "kind": "FunctionDeclaration",
      "signature": "export function getRequireCachedFiles(): string[] {\n  return Object.keys(require.cache).filter(\n    (p) => !p.startsWith(\"internal\") && (p.endsWith(\".js\") || p.endsWith(\".ts\"))\n  );\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRequireCachedFiles.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageJsonPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getPackageJsonPath(): string {\n  return findClosestPackageJson(__filename)!;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageRoot",
      "kind": "FunctionDeclaration",
      "signature": "export function getPackageRoot(): string {\n  const packageJsonPath = getPackageJsonPath();\n\n  return path.dirname(packageJsonPath);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "findClosestPackageJson",
      "kind": "FunctionDeclaration",
      "signature": "export function findClosestPackageJson(file: string): string | undefined {\n  return findup.sync(\"package.json\", { cwd: path.dirname(file) });\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageName",
      "kind": "FunctionDeclaration",
      "signature": "export async function getPackageName(file: string): Promise<string> {\n  const packageJsonPath = findClosestPackageJson(file);\n  if (packageJsonPath !== undefined && packageJsonPath !== \"\") {\n    const packageJson: PackageJson = await fsExtra.readJSON(packageJsonPath);\n    return packageJson.name;\n  ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageName.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageName.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageName.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageName.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageJson",
      "kind": "FunctionDeclaration",
      "signature": "export async function getPackageJson(): Promise<PackageJson> {\n  const root = getPackageRoot();\n  return fsExtra.readJSON(path.join(root, \"package.json\"));\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getPackageJson.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardhatVersion",
      "kind": "FunctionDeclaration",
      "signature": "export function getHardhatVersion(): string {\n  const packageJsonPath = findClosestPackageJson(__filename);\n\n  assertHardhatInvariant(\n    packageJsonPath !== undefined,\n    \"There should be a package.json in hardhat-core's root directory\"\n  );\n\n  const packageJson = fsExtra.readJsonSync(packageJson",
      "doc": "",
      "tags": []
    },
    {
      "name": "getProjectPackageJson",
      "kind": "FunctionDeclaration",
      "signature": "export function getProjectPackageJson(): Promise<any> {\n  const packageJsonPath = findup.sync(\"package.json\");\n\n  assertHardhatInvariant(\n    packageJsonPath !== undefined,\n    \"Expected a package.json file in the current directory or in an ancestor directory\"\n  );\n\n  return fsExtra.readJson(package",
      "doc": "Return the contents of the package.json in the user's project",
      "tags": []
    },
    {
      "name": "getProjectPackageJson.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getProjectPackageJson.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getProjectPackageJson.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getProjectPackageJson.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "PackageJson",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PackageJson {\n  name: string;\n  version: string;\n  type?: \"commonjs\" | \"module\";\n  engines: {\n    node: string;\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MultiProcessMutex",
      "kind": "ClassDeclaration",
      "signature": "export class MultiProcessMutex {\n  private _mutexFilePath: string;\n  private _mutexLifespanInMs: number;\n\n  constructor(mutexName: string, maxMutexLifespanInMs?: number) {\n    log(`Creating mutex with name '${mutexName}'`);\n\n    this._mutexFilePath = path.join(os.tmpdir(), `${mutexName}.txt`);\n    t",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyObject",
      "kind": "FunctionDeclaration",
      "signature": "export function lazyObject<T extends object>(objectCreator: () => T): T {\n  return createLazyProxy(\n    objectCreator,\n    (getRealTarget) => ({\n      [inspect](\n        depth: number,\n        options: InspectOptions,\n        inspectFn: (\n          object: any,\n          options: InspectOptions\n    ",
      "doc": "This module provides function to implement proxy-based object, functions, and\nclasses (they are functions). They receive an initializer function that it's\nnot used until someone interacts with the lazy element.\n\nThis functions can also be used like a lazy `require`, creating a proxy that\ndoesn't require the module until needed.\n\nThe disadvantage of using this technique is that the type information is\nlost wrt `import`, as `require` returns an `any. If done with enough care,\nthis can be manually fixed.\n\nTypeScript doesn't emit `require` calls for modules that are imported only\nbecause of their types. So if one uses lazyObject or lazyFunction along with\na normal ESM import you can pass the module's type to this function.\n\nAn example of this can be:\n\n   import findUpT from \"find-up\";\n   export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n\nYou can also use it with named exports:\n\n   import { EthT } from \"web3x/eth\";\n   const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);",
      "tags": []
    },
    {
      "name": "lazyFunction",
      "kind": "FunctionDeclaration",
      "signature": "export function lazyFunction<T extends Function>(functionCreator: () => T): T {\n  return createLazyProxy(\n    functionCreator,\n    (getRealTarget) => {\n      function dummyTarget() {}\n\n      (dummyTarget as any)[inspect] = function (\n        depth: number,\n        options: InspectOptions,\n        in",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.apply",
      "kind": "MethodSignature",
      "signature": "apply(this:Function,thisArg:any,argArray?:any):any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.call",
      "kind": "MethodSignature",
      "signature": "call(this:Function,thisArg:any,...argArray:any[]):any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.bind",
      "kind": "MethodSignature",
      "signature": "bind(this:Function,thisArg:any,...argArray:any[]):any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.prototype",
      "kind": "PropertySignature",
      "signature": "prototype:any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.arguments",
      "kind": "PropertySignature",
      "signature": "arguments:any;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.caller",
      "kind": "PropertySignature",
      "signature": "caller:Function;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.name",
      "kind": "PropertySignature",
      "signature": "readonly name:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.__@hasInstance@38",
      "kind": "MethodSignature",
      "signature": "[Symbol.hasInstance](value:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "lazyFunction.__@metadata@40",
      "kind": "PropertySignature",
      "signature": "[Symbol.metadata]:DecoratorMetadata|null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "fromEntries",
      "kind": "FunctionDeclaration",
      "signature": "export function fromEntries<T = any>(entries: Array<[string, any]>): T {\n  return Object.assign(\n    {},\n    ...entries.map(([name, value]) => ({\n      [name]: value,\n    }))\n  );\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "mapValues",
      "kind": "FunctionDeclaration",
      "signature": "export function mapValues<T extends object, ResultT>(\n  o: T,\n  callback: (value: T[keyof T]) => ResultT[keyof ResultT]\n): ResultT {\n  const result: any = {};\n\n  for (const [key, value] of Object.entries(o)) {\n    result[key] = callback(value);\n  }\n\n  return result;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath",
      "kind": "FunctionDeclaration",
      "signature": "export function deriveKeyFromMnemonicAndPath(\n  mnemonic: string,\n  hdPath: string,\n  passphrase: string\n): Buffer | undefined {\n  const {\n    mnemonicToSeedSync,\n  }: {\n    mnemonicToSeedSync: typeof mnemonicToSeedSyncT;\n  } = require(\"ethereum-cryptography/bip39\");\n  // NOTE: If mnemonic has space",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?: number, end?: number): Buffer<ArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nThis method is not compatible with the `Uint8Array.prototype.slice()`,\nwhich is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconst copiedBuf = Uint8Array.prototype.slice.call(buf);\ncopiedBuf[0]++;\nconsole.log(copiedBuf.toString());\n// Prints: cuffer\n\nconsole.log(buf.toString());\n// Prints: buffer\n\n// With buf.slice(), the original buffer is modified.\nconst notReallyCopiedBuf = buf.slice();\nnotReallyCopiedBuf[0]++;\nconsole.log(notReallyCopiedBuf.toString());\n// Prints: cuffer\nconsole.log(buf.toString());\n// Also prints: cuffer (!)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.0"
        },
        {
          "tagName": "deprecated",
          "text": "Use `subarray` instead."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(start?: number, end?: number): Buffer<TArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nSpecifying `end` greater than `buf.length` will return the same result as\nthat of `end` equal to `buf.length`.\n\nThis method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).\n\nModifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.subarray(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: !bc\n```\n\nSpecifying negative indexes causes the slice to be generated relative to the\nend of `buf` rather than the beginning.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.subarray(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.subarray(0, 5).)\n\nconsole.log(buf.subarray(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.subarray(0, 4).)\n\nconsole.log(buf.subarray(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.subarray(1, 4).)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v3.0.0"
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.write",
      "kind": "MethodSignature",
      "signature": "write(string: string, encoding?: BufferEncoding): number;",
      "doc": "Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did\nnot contain enough space to fit the entire string, only part of `string` will be\nwritten. However, partially encoded characters will not be written.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(256);\n\nconst len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n\nconsole.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n// Prints: 12 bytes:  +  = \n\nconst buffer = Buffer.alloc(10);\n\nconst length = buffer.write('abcd', 8);\n\nconsole.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);\n// Prints: 2 bytes : ab\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "String to write to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write `string`."
        },
        {
          "tagName": "param",
          "text": "Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`)."
        },
        {
          "tagName": "param",
          "text": "The character encoding of `string`."
        },
        {
          "tagName": "return",
          "text": "Number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.toString",
      "kind": "MethodSignature",
      "signature": "toString(encoding?: BufferEncoding, start?: number, end?: number): string;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "The character encoding to use."
        },
        {
          "tagName": "param",
          "text": "The byte offset to start decoding at."
        },
        {
          "tagName": "param",
          "text": "The byte offset to stop decoding at (not inclusive)."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.toJSON",
      "kind": "MethodSignature",
      "signature": "toJSON(): {\n                type: \"Buffer\";\n                data: number[];\n            };",
      "doc": "Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls\nthis function when stringifying a `Buffer` instance.\n\n`Buffer.from()` accepts objects in the format returned from this method.\nIn particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value &#x26;&#x26; value.type === 'Buffer' ?\n    Buffer.from(value) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: <Buffer 01 02 03 04 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.2"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.equals",
      "kind": "MethodSignature",
      "signature": "equals(otherBuffer: Uint8Array): boolean;",
      "doc": "Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.compare",
      "kind": "MethodSignature",
      "signature": "compare(\n                target: Uint8Array,\n                targetStart?: number,\n                targetEnd?: number,\n                sourceStart?: number,\n                sourceEnd?: number,\n            ): -1 | 0 | 1;",
      "doc": "Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.\nComparison is based on the actual sequence of bytes in each `Buffer`.\n\n* `0` is returned if `target` is the same as `buf`\n* `1` is returned if `target` should come _before_`buf` when sorted.\n* `-1` is returned if `target` should come _after_`buf` when sorted.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]\n// (This result is equal to: [buf1, buf3, buf2].)\n```\n\nThe optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used to limit the comparison to specific ranges within `target` and `buf` respectively.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n```\n\n`ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`, `targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to end comparison (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to end comparison (not inclusive)."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.copy",
      "kind": "MethodSignature",
      "signature": "copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;",
      "doc": "Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.\n\n[`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available\nfor all TypedArrays, including Node.js `Buffer`s, although it takes\ndifferent function arguments.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.\nbuf1.copy(buf2, 8, 16, 20);\n// This is equivalent to:\n// buf2.set(buf1.subarray(16, 20), 8);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n```\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} to copy into."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin writing."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` from which to begin copying."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to stop copying (not inclusive)."
        },
        {
          "tagName": "return",
          "text": "The number of bytes copied."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeBigInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64BE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeBigInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64LE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\nThis function is also available under the `writeBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64BE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de ca fa fe ca ce fa de>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeBigUint64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64BE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64LE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de fa ce ca fe fa ca de>\n```\n\nThis function is also available under the `writeBigUint64LE` alias.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeBigUint64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64LE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUIntLE",
      "kind": "MethodSignature",
      "signature": "writeUIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUintLE",
      "kind": "MethodSignature",
      "signature": "writeUintLE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUIntBE",
      "kind": "MethodSignature",
      "signature": "writeUIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUintBE",
      "kind": "MethodSignature",
      "signature": "writeUintBE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeIntLE",
      "kind": "MethodSignature",
      "signature": "writeIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than a signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeIntBE",
      "kind": "MethodSignature",
      "signature": "writeIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a\nsigned integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64BE(offset?: number): bigint;",
      "doc": "Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64BE(0));\n// Prints: 4294967295n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readBigUint64BE",
      "kind": "MethodSignature",
      "signature": "readBigUint64BE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64LE(offset?: number): bigint;",
      "doc": "Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64LE(0));\n// Prints: 18446744069414584320n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readBigUint64LE",
      "kind": "MethodSignature",
      "signature": "readBigUint64LE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readBigInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigInt64BE(offset?: number): bigint;",
      "doc": "Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readBigInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigInt64LE(offset?: number): bigint;",
      "doc": "Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUIntLE",
      "kind": "MethodSignature",
      "signature": "readUIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned, little-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUintLE",
      "kind": "MethodSignature",
      "signature": "readUintLE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUIntBE",
      "kind": "MethodSignature",
      "signature": "readUIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned big-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUintBE",
      "kind": "MethodSignature",
      "signature": "readUintBE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readIntLE",
      "kind": "MethodSignature",
      "signature": "readIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a little-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readIntBE",
      "kind": "MethodSignature",
      "signature": "readIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a big-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUInt8",
      "kind": "MethodSignature",
      "signature": "readUInt8(offset?: number): number;",
      "doc": "Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUint8",
      "kind": "MethodSignature",
      "signature": "readUint8(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUInt16LE",
      "kind": "MethodSignature",
      "signature": "readUInt16LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 16-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUint16LE",
      "kind": "MethodSignature",
      "signature": "readUint16LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUInt16BE",
      "kind": "MethodSignature",
      "signature": "readUInt16BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUint16BE",
      "kind": "MethodSignature",
      "signature": "readUint16BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUInt32LE",
      "kind": "MethodSignature",
      "signature": "readUInt32LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUint32LE",
      "kind": "MethodSignature",
      "signature": "readUint32LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUInt32BE",
      "kind": "MethodSignature",
      "signature": "readUInt32BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readUint32BE",
      "kind": "MethodSignature",
      "signature": "readUint32BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readInt8",
      "kind": "MethodSignature",
      "signature": "readInt8(offset?: number): number;",
      "doc": "Reads a signed 8-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readInt16LE",
      "kind": "MethodSignature",
      "signature": "readInt16LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readInt16BE",
      "kind": "MethodSignature",
      "signature": "readInt16BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readInt32LE",
      "kind": "MethodSignature",
      "signature": "readInt32LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readInt32BE",
      "kind": "MethodSignature",
      "signature": "readInt32BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readFloatLE",
      "kind": "MethodSignature",
      "signature": "readFloatLE(offset?: number): number;",
      "doc": "Reads a 32-bit, little-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readFloatBE",
      "kind": "MethodSignature",
      "signature": "readFloatBE(offset?: number): number;",
      "doc": "Reads a 32-bit, big-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readDoubleLE",
      "kind": "MethodSignature",
      "signature": "readDoubleLE(offset?: number): number;",
      "doc": "Reads a 64-bit, little-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.readDoubleBE",
      "kind": "MethodSignature",
      "signature": "readDoubleBE(offset?: number): number;",
      "doc": "Reads a 64-bit, big-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.reverse",
      "kind": "MethodSignature",
      "signature": "reverse(): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.swap16",
      "kind": "MethodSignature",
      "signature": "swap16(): this;",
      "doc": "Interprets `buf` as an array of unsigned 16-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: <Buffer 02 01 04 03 06 05 08 07>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```\n\nOne convenient use of `buf.swap16()` is to perform a fast in-place conversion\nbetween UTF-16 little-endian and UTF-16 big-endian:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\nbuf.swap16(); // Convert to big-endian UTF-16 text.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.swap32",
      "kind": "MethodSignature",
      "signature": "swap32(): this;",
      "doc": "Interprets `buf` as an array of unsigned 32-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: <Buffer 04 03 02 01 08 07 06 05>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.swap64",
      "kind": "MethodSignature",
      "signature": "swap64(): this;",
      "doc": "Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.\nThrows `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.3.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUInt8",
      "kind": "MethodSignature",
      "signature": "writeUInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a\nvalid unsigned 8-bit integer. Behavior is undefined when `value` is anything\nother than an unsigned 8-bit integer.\n\nThis function is also available under the `writeUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: <Buffer 03 04 23 42>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUint8",
      "kind": "MethodSignature",
      "signature": "writeUint8(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUInt16LE",
      "kind": "MethodSignature",
      "signature": "writeUInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 16-bit integer.\n\nThis function is also available under the `writeUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer ad de ef be>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUint16LE",
      "kind": "MethodSignature",
      "signature": "writeUint16LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUInt16BE",
      "kind": "MethodSignature",
      "signature": "writeUInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 16-bit integer.\n\nThis function is also available under the `writeUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer de ad be ef>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUint16BE",
      "kind": "MethodSignature",
      "signature": "writeUint16BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUInt32LE",
      "kind": "MethodSignature",
      "signature": "writeUInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 32-bit integer.\n\nThis function is also available under the `writeUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer ce fa ed fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUint32LE",
      "kind": "MethodSignature",
      "signature": "writeUint32LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUInt32BE",
      "kind": "MethodSignature",
      "signature": "writeUInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 32-bit integer.\n\nThis function is also available under the `writeUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer fe ed fa ce>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeUint32BE",
      "kind": "MethodSignature",
      "signature": "writeUint32BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeInt8",
      "kind": "MethodSignature",
      "signature": "writeInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a valid\nsigned 8-bit integer. Behavior is undefined when `value` is anything other than\na signed 8-bit integer.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: <Buffer 02 fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeInt16LE",
      "kind": "MethodSignature",
      "signature": "writeInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16LE(0x0304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 04 03>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeInt16BE",
      "kind": "MethodSignature",
      "signature": "writeInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16BE(0x0102, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeInt32LE",
      "kind": "MethodSignature",
      "signature": "writeInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32LE(0x05060708, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeInt32BE",
      "kind": "MethodSignature",
      "signature": "writeInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32BE(0x01020304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeFloatLE",
      "kind": "MethodSignature",
      "signature": "writeFloatLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer bb fe 4a 4f>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeFloatBE",
      "kind": "MethodSignature",
      "signature": "writeFloatBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 4f 4a fe bb>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeDoubleLE",
      "kind": "MethodSignature",
      "signature": "writeDoubleLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.writeDoubleBE",
      "kind": "MethodSignature",
      "signature": "writeDoubleBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 40 5e dd 2f 1a 9f be 77>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.fill",
      "kind": "MethodSignature",
      "signature": "fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;",
      "doc": "Fills `buf` with the specified `value`. If the `offset` and `end` are not given,\nthe entire `buf` will be filled:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with the ASCII character 'h'.\n\nconst b = Buffer.allocUnsafe(50).fill('h');\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n\n// Fill a buffer with empty string\nconst c = Buffer.allocUnsafe(5).fill('');\n\nconsole.log(c.fill(''));\n// Prints: <Buffer 00 00 00 00 00>\n```\n\n`value` is coerced to a `uint32` value if it is not a string, `Buffer`, or\ninteger. If the resulting integer is greater than `255` (decimal), `buf` will be\nfilled with `value &#x26; 255`.\n\nIf the final write of a `fill()` operation falls on a multi-byte character,\nthen only the bytes of that character that fit into `buf` are written:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with character that takes up two bytes in UTF-8.\n\nconsole.log(Buffer.allocUnsafe(5).fill('\\u0222'));\n// Prints: <Buffer c8 a2 c8 a2 c8>\n```\n\nIf `value` contains invalid characters, it is truncated; if no valid\nfill data remains, an exception is thrown:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill('a'));\n// Prints: <Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Throws an exception.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to fill `buf`."
        },
        {
          "tagName": "param",
          "text": "Where to stop filling `buf` (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The encoding for `value` if `value` is a string."
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "If `value` is:\n\n* a string, `value` is interpreted according to the character encoding in `encoding`.\n* a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.\nTo compare a partial `Buffer`, use `buf.subarray`.\n* a number, `value` will be interpreted as an unsigned 8-bit integer\nvalue between `0` and `255`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.indexOf('this'));\n// Prints: 0\nconsole.log(buf.indexOf('is'));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from('a buffer')));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.indexOf(Buffer.from('a buffer example')));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n// Prints: 6\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. If the result\nof coercion is `NaN` or `0`, then the entire buffer will be searched. This\nbehavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer` and `byteOffset` is less\nthan `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v1.5.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "Identical to `buf.indexOf()`, except the last occurrence of `value` is found\nrather than the first occurrence.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this buffer is a buffer');\n\nconsole.log(buf.lastIndexOf('this'));\n// Prints: 0\nconsole.log(buf.lastIndexOf('buffer'));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from('buffer')));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.lastIndexOf(Buffer.from('yolo')));\n// Prints: -1\nconsole.log(buf.lastIndexOf('buffer', 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf('buffer', 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n// Prints: 4\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. Any arguments\nthat coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.\nThis behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n\n// Passing a byteOffset that coerces to 0.\n// Prints: -1, equivalent to passing 0.\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.includes",
      "kind": "MethodSignature",
      "signature": "includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;",
      "doc": "Equivalent to `buf.indexOf() !== -1`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.includes('this'));\n// Prints: true\nconsole.log(buf.includes('is'));\n// Prints: true\nconsole.log(buf.includes(Buffer.from('a buffer')));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for 'a')\nconsole.log(buf.includes(Buffer.from('a buffer example')));\n// Prints: false\nconsole.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes('this', 4));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.3.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is its encoding."
        },
        {
          "tagName": "return",
          "text": "`true` if `value` was found in `buf`, `false` otherwise."
        }
      ]
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends number>(predicate:(value:number,index:number,array:this,)=>value is S,thisArg?:any,):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any,):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:number,b:number)=>number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "deriveKeyFromMnemonicAndPath.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256",
      "kind": "FunctionDeclaration",
      "signature": "export function keccak256(data: Uint8Array): Uint8Array {\n  return createKeccakHash(\"keccak256\").update(Buffer.from(data)).digest();\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:number,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:number,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(begin?:number,end?:number):Uint8Array<TArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:number,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends number>(predicate:(value:number,index:number,array:this,)=>value is S,thisArg?:any,):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any,):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:number,b:number)=>number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "keccak256.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseJsonResponse",
      "kind": "FunctionDeclaration",
      "signature": "export function parseJsonResponse(\n  text: string\n): JsonRpcResponse | JsonRpcResponse[] {\n  try {\n    const json = JSON.parse(text);\n\n    const responses = Array.isArray(json) ? json : [json];\n    for (const response of responses) {\n      if (!isValidJsonResponse(response)) {\n        // We are send",
      "doc": "",
      "tags": []
    },
    {
      "name": "isValidJsonRequest",
      "kind": "FunctionDeclaration",
      "signature": "export function isValidJsonRequest(payload: any): boolean {\n  if (payload.jsonrpc !== \"2.0\") {\n    return false;\n  }\n\n  if (typeof payload.id !== \"number\" && typeof payload.id !== \"string\") {\n    return false;\n  }\n\n  if (typeof payload.method !== \"string\") {\n    return false;\n  }\n\n  if (payload.para",
      "doc": "",
      "tags": []
    },
    {
      "name": "isValidJsonResponse",
      "kind": "FunctionDeclaration",
      "signature": "export function isValidJsonResponse(payload: any) {\n  if (payload.jsonrpc !== \"2.0\") {\n    return false;\n  }\n\n  if (\n    typeof payload.id !== \"number\" &&\n    typeof payload.id !== \"string\" &&\n    payload.id !== null\n  ) {\n    return false;\n  }\n\n  if (payload.id === null && payload.error === undefin",
      "doc": "",
      "tags": []
    },
    {
      "name": "isSuccessfulJsonResponse",
      "kind": "FunctionDeclaration",
      "signature": "export function isSuccessfulJsonResponse(\n  payload: JsonRpcResponse\n): payload is SuccessfulJsonRpcResponse {\n  return \"result\" in payload;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcRequest",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcRequest {\n  jsonrpc: string;\n  method: string;\n  params: any[];\n  id: number | string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SuccessfulJsonRpcResponse",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SuccessfulJsonRpcResponse {\n  jsonrpc: string;\n  id: number | string;\n  result: any;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "FailedJsonRpcResponse",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FailedJsonRpcResponse {\n  jsonrpc: string;\n  id: number | string | null;\n  error: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcResponse",
      "kind": "TypeAliasDeclaration",
      "signature": "export type JsonRpcResponse = SuccessfulJsonRpcResponse | FailedJsonRpcResponse;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalOrNullable",
      "kind": "FunctionDeclaration",
      "signature": "export function optionalOrNullable<TypeT, OutputT, InputT>(\n  codec: t.Type<TypeT, OutputT, InputT>,\n  name: string = `${codec.name} | undefined`\n): t.Type<TypeT | undefined, OutputT | undefined, InputT | undefined | null> {\n  return new t.Type(\n    name,\n    (u: unknown): u is TypeT | undefined => ",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalOrNullable.name",
      "kind": "PropertyDeclaration",
      "signature": "readonly name: string;",
      "doc": "a unique name for this codec",
      "tags": []
    },
    {
      "name": "optionalOrNullable.is",
      "kind": "PropertyDeclaration",
      "signature": "readonly is: Is<A>;",
      "doc": "a custom type guard",
      "tags": []
    },
    {
      "name": "optionalOrNullable.validate",
      "kind": "PropertyDeclaration",
      "signature": "readonly validate: Validate<I, A>;",
      "doc": "succeeds if a value of type I can be decoded to a value of type A",
      "tags": []
    },
    {
      "name": "optionalOrNullable.encode",
      "kind": "PropertyDeclaration",
      "signature": "readonly encode: Encode<A, O>;",
      "doc": "converts a value of type A to a value of type O",
      "tags": []
    },
    {
      "name": "optionalOrNullable._A",
      "kind": "PropertyDeclaration",
      "signature": "readonly _A: A;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalOrNullable._O",
      "kind": "PropertyDeclaration",
      "signature": "readonly _O: O;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalOrNullable._I",
      "kind": "PropertyDeclaration",
      "signature": "readonly _I: I;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalOrNullable.pipe",
      "kind": "MethodDeclaration",
      "signature": "pipe<B, IB, A extends IB, OB extends A>(this: Type<A, O, I>, ab: Type<B, OB, IB>, name?: string): Type<B, O, I>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalOrNullable.asDecoder",
      "kind": "MethodDeclaration",
      "signature": "asDecoder(): Decoder<I, A>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalOrNullable.asEncoder",
      "kind": "MethodDeclaration",
      "signature": "asEncoder(): Encoder<A, O>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalOrNullable.decode",
      "kind": "MethodDeclaration",
      "signature": "decode(i: I): Validation<A>;",
      "doc": "a version of `validate` with a default context",
      "tags": []
    },
    {
      "name": "optional",
      "kind": "FunctionDeclaration",
      "signature": "export function optional<TypeT, OutputT, InputT>(\n  codec: t.Type<TypeT, OutputT, InputT>,\n  name: string = `${codec.name} | undefined`\n): t.Type<TypeT | undefined, OutputT | undefined, InputT | undefined> {\n  return new t.Type(\n    name,\n    (u: unknown): u is TypeT | undefined => u === undefined |",
      "doc": "",
      "tags": []
    },
    {
      "name": "optional.name",
      "kind": "PropertyDeclaration",
      "signature": "readonly name: string;",
      "doc": "a unique name for this codec",
      "tags": []
    },
    {
      "name": "optional.is",
      "kind": "PropertyDeclaration",
      "signature": "readonly is: Is<A>;",
      "doc": "a custom type guard",
      "tags": []
    },
    {
      "name": "optional.validate",
      "kind": "PropertyDeclaration",
      "signature": "readonly validate: Validate<I, A>;",
      "doc": "succeeds if a value of type I can be decoded to a value of type A",
      "tags": []
    },
    {
      "name": "optional.encode",
      "kind": "PropertyDeclaration",
      "signature": "readonly encode: Encode<A, O>;",
      "doc": "converts a value of type A to a value of type O",
      "tags": []
    },
    {
      "name": "optional._A",
      "kind": "PropertyDeclaration",
      "signature": "readonly _A: A;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optional._O",
      "kind": "PropertyDeclaration",
      "signature": "readonly _O: O;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optional._I",
      "kind": "PropertyDeclaration",
      "signature": "readonly _I: I;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optional.pipe",
      "kind": "MethodDeclaration",
      "signature": "pipe<B, IB, A extends IB, OB extends A>(this: Type<A, O, I>, ab: Type<B, OB, IB>, name?: string): Type<B, O, I>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optional.asDecoder",
      "kind": "MethodDeclaration",
      "signature": "asDecoder(): Decoder<I, A>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optional.asEncoder",
      "kind": "MethodDeclaration",
      "signature": "asEncoder(): Encoder<A, O>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optional.decode",
      "kind": "MethodDeclaration",
      "signature": "decode(i: I): Validation<A>;",
      "doc": "a version of `validate` with a default context",
      "tags": []
    },
    {
      "name": "nullable",
      "kind": "FunctionDeclaration",
      "signature": "export function nullable<TypeT, OutputT, InputT>(\n  codec: t.Type<TypeT, OutputT, InputT>,\n  name: string = `${codec.name} | null`\n): t.Type<TypeT | null, OutputT | null, InputT | null> {\n  return new t.Type(\n    name,\n    (u: unknown): u is TypeT | null => u === null || codec.is(u),\n    (u, c) => (",
      "doc": "",
      "tags": []
    },
    {
      "name": "nullable.name",
      "kind": "PropertyDeclaration",
      "signature": "readonly name: string;",
      "doc": "a unique name for this codec",
      "tags": []
    },
    {
      "name": "nullable.is",
      "kind": "PropertyDeclaration",
      "signature": "readonly is: Is<A>;",
      "doc": "a custom type guard",
      "tags": []
    },
    {
      "name": "nullable.validate",
      "kind": "PropertyDeclaration",
      "signature": "readonly validate: Validate<I, A>;",
      "doc": "succeeds if a value of type I can be decoded to a value of type A",
      "tags": []
    },
    {
      "name": "nullable.encode",
      "kind": "PropertyDeclaration",
      "signature": "readonly encode: Encode<A, O>;",
      "doc": "converts a value of type A to a value of type O",
      "tags": []
    },
    {
      "name": "nullable._A",
      "kind": "PropertyDeclaration",
      "signature": "readonly _A: A;",
      "doc": "",
      "tags": []
    },
    {
      "name": "nullable._O",
      "kind": "PropertyDeclaration",
      "signature": "readonly _O: O;",
      "doc": "",
      "tags": []
    },
    {
      "name": "nullable._I",
      "kind": "PropertyDeclaration",
      "signature": "readonly _I: I;",
      "doc": "",
      "tags": []
    },
    {
      "name": "nullable.pipe",
      "kind": "MethodDeclaration",
      "signature": "pipe<B, IB, A extends IB, OB extends A>(this: Type<A, O, I>, ab: Type<B, OB, IB>, name?: string): Type<B, O, I>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "nullable.asDecoder",
      "kind": "MethodDeclaration",
      "signature": "asDecoder(): Decoder<I, A>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "nullable.asEncoder",
      "kind": "MethodDeclaration",
      "signature": "asEncoder(): Encoder<A, O>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "nullable.decode",
      "kind": "MethodDeclaration",
      "signature": "decode(i: I): Validation<A>;",
      "doc": "a version of `validate` with a default context",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier",
      "kind": "FunctionDeclaration",
      "signature": "export function createNonCryptographicHashBasedIdentifier(\n  input: Buffer\n): Buffer {\n  const { createHash } = require(\"crypto\");\n\n  return createHash(\"md5\").update(input).digest();\n}",
      "doc": "This function hashes its input with a NON cryptographic.\n\nThis function is useful for creating unique identifiers based on some\ninput. You can be confident that there won't be any collision, as long\nas the input is not generated by an attacker.\n\nThe exact algorithm being used shouldn't matter.",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?: number, end?: number): Buffer<ArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nThis method is not compatible with the `Uint8Array.prototype.slice()`,\nwhich is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconst copiedBuf = Uint8Array.prototype.slice.call(buf);\ncopiedBuf[0]++;\nconsole.log(copiedBuf.toString());\n// Prints: cuffer\n\nconsole.log(buf.toString());\n// Prints: buffer\n\n// With buf.slice(), the original buffer is modified.\nconst notReallyCopiedBuf = buf.slice();\nnotReallyCopiedBuf[0]++;\nconsole.log(notReallyCopiedBuf.toString());\n// Prints: cuffer\nconsole.log(buf.toString());\n// Also prints: cuffer (!)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.0"
        },
        {
          "tagName": "deprecated",
          "text": "Use `subarray` instead."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(start?: number, end?: number): Buffer<TArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nSpecifying `end` greater than `buf.length` will return the same result as\nthat of `end` equal to `buf.length`.\n\nThis method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).\n\nModifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.subarray(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: !bc\n```\n\nSpecifying negative indexes causes the slice to be generated relative to the\nend of `buf` rather than the beginning.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.subarray(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.subarray(0, 5).)\n\nconsole.log(buf.subarray(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.subarray(0, 4).)\n\nconsole.log(buf.subarray(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.subarray(1, 4).)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v3.0.0"
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.write",
      "kind": "MethodSignature",
      "signature": "write(string: string, encoding?: BufferEncoding): number;",
      "doc": "Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did\nnot contain enough space to fit the entire string, only part of `string` will be\nwritten. However, partially encoded characters will not be written.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(256);\n\nconst len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n\nconsole.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n// Prints: 12 bytes:  +  = \n\nconst buffer = Buffer.alloc(10);\n\nconst length = buffer.write('abcd', 8);\n\nconsole.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);\n// Prints: 2 bytes : ab\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "String to write to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write `string`."
        },
        {
          "tagName": "param",
          "text": "Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`)."
        },
        {
          "tagName": "param",
          "text": "The character encoding of `string`."
        },
        {
          "tagName": "return",
          "text": "Number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.toString",
      "kind": "MethodSignature",
      "signature": "toString(encoding?: BufferEncoding, start?: number, end?: number): string;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "The character encoding to use."
        },
        {
          "tagName": "param",
          "text": "The byte offset to start decoding at."
        },
        {
          "tagName": "param",
          "text": "The byte offset to stop decoding at (not inclusive)."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.toJSON",
      "kind": "MethodSignature",
      "signature": "toJSON(): {\n                type: \"Buffer\";\n                data: number[];\n            };",
      "doc": "Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls\nthis function when stringifying a `Buffer` instance.\n\n`Buffer.from()` accepts objects in the format returned from this method.\nIn particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value &#x26;&#x26; value.type === 'Buffer' ?\n    Buffer.from(value) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: <Buffer 01 02 03 04 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.2"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.equals",
      "kind": "MethodSignature",
      "signature": "equals(otherBuffer: Uint8Array): boolean;",
      "doc": "Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.compare",
      "kind": "MethodSignature",
      "signature": "compare(\n                target: Uint8Array,\n                targetStart?: number,\n                targetEnd?: number,\n                sourceStart?: number,\n                sourceEnd?: number,\n            ): -1 | 0 | 1;",
      "doc": "Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.\nComparison is based on the actual sequence of bytes in each `Buffer`.\n\n* `0` is returned if `target` is the same as `buf`\n* `1` is returned if `target` should come _before_`buf` when sorted.\n* `-1` is returned if `target` should come _after_`buf` when sorted.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]\n// (This result is equal to: [buf1, buf3, buf2].)\n```\n\nThe optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used to limit the comparison to specific ranges within `target` and `buf` respectively.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n```\n\n`ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`, `targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to end comparison (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to end comparison (not inclusive)."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.copy",
      "kind": "MethodSignature",
      "signature": "copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;",
      "doc": "Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.\n\n[`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available\nfor all TypedArrays, including Node.js `Buffer`s, although it takes\ndifferent function arguments.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.\nbuf1.copy(buf2, 8, 16, 20);\n// This is equivalent to:\n// buf2.set(buf1.subarray(16, 20), 8);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n```\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} to copy into."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin writing."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` from which to begin copying."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to stop copying (not inclusive)."
        },
        {
          "tagName": "return",
          "text": "The number of bytes copied."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeBigInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64BE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeBigInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64LE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\nThis function is also available under the `writeBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64BE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de ca fa fe ca ce fa de>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeBigUint64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64BE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64LE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de fa ce ca fe fa ca de>\n```\n\nThis function is also available under the `writeBigUint64LE` alias.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeBigUint64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64LE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUIntLE",
      "kind": "MethodSignature",
      "signature": "writeUIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUintLE",
      "kind": "MethodSignature",
      "signature": "writeUintLE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUIntBE",
      "kind": "MethodSignature",
      "signature": "writeUIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUintBE",
      "kind": "MethodSignature",
      "signature": "writeUintBE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeIntLE",
      "kind": "MethodSignature",
      "signature": "writeIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than a signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeIntBE",
      "kind": "MethodSignature",
      "signature": "writeIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a\nsigned integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64BE(offset?: number): bigint;",
      "doc": "Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64BE(0));\n// Prints: 4294967295n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readBigUint64BE",
      "kind": "MethodSignature",
      "signature": "readBigUint64BE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64LE(offset?: number): bigint;",
      "doc": "Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64LE(0));\n// Prints: 18446744069414584320n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readBigUint64LE",
      "kind": "MethodSignature",
      "signature": "readBigUint64LE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readBigInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigInt64BE(offset?: number): bigint;",
      "doc": "Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readBigInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigInt64LE(offset?: number): bigint;",
      "doc": "Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUIntLE",
      "kind": "MethodSignature",
      "signature": "readUIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned, little-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUintLE",
      "kind": "MethodSignature",
      "signature": "readUintLE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUIntBE",
      "kind": "MethodSignature",
      "signature": "readUIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned big-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUintBE",
      "kind": "MethodSignature",
      "signature": "readUintBE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readIntLE",
      "kind": "MethodSignature",
      "signature": "readIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a little-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readIntBE",
      "kind": "MethodSignature",
      "signature": "readIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a big-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUInt8",
      "kind": "MethodSignature",
      "signature": "readUInt8(offset?: number): number;",
      "doc": "Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUint8",
      "kind": "MethodSignature",
      "signature": "readUint8(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUInt16LE",
      "kind": "MethodSignature",
      "signature": "readUInt16LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 16-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUint16LE",
      "kind": "MethodSignature",
      "signature": "readUint16LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUInt16BE",
      "kind": "MethodSignature",
      "signature": "readUInt16BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUint16BE",
      "kind": "MethodSignature",
      "signature": "readUint16BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUInt32LE",
      "kind": "MethodSignature",
      "signature": "readUInt32LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUint32LE",
      "kind": "MethodSignature",
      "signature": "readUint32LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUInt32BE",
      "kind": "MethodSignature",
      "signature": "readUInt32BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readUint32BE",
      "kind": "MethodSignature",
      "signature": "readUint32BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readInt8",
      "kind": "MethodSignature",
      "signature": "readInt8(offset?: number): number;",
      "doc": "Reads a signed 8-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readInt16LE",
      "kind": "MethodSignature",
      "signature": "readInt16LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readInt16BE",
      "kind": "MethodSignature",
      "signature": "readInt16BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readInt32LE",
      "kind": "MethodSignature",
      "signature": "readInt32LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readInt32BE",
      "kind": "MethodSignature",
      "signature": "readInt32BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readFloatLE",
      "kind": "MethodSignature",
      "signature": "readFloatLE(offset?: number): number;",
      "doc": "Reads a 32-bit, little-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readFloatBE",
      "kind": "MethodSignature",
      "signature": "readFloatBE(offset?: number): number;",
      "doc": "Reads a 32-bit, big-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readDoubleLE",
      "kind": "MethodSignature",
      "signature": "readDoubleLE(offset?: number): number;",
      "doc": "Reads a 64-bit, little-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.readDoubleBE",
      "kind": "MethodSignature",
      "signature": "readDoubleBE(offset?: number): number;",
      "doc": "Reads a 64-bit, big-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.reverse",
      "kind": "MethodSignature",
      "signature": "reverse(): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.swap16",
      "kind": "MethodSignature",
      "signature": "swap16(): this;",
      "doc": "Interprets `buf` as an array of unsigned 16-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: <Buffer 02 01 04 03 06 05 08 07>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```\n\nOne convenient use of `buf.swap16()` is to perform a fast in-place conversion\nbetween UTF-16 little-endian and UTF-16 big-endian:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\nbuf.swap16(); // Convert to big-endian UTF-16 text.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.swap32",
      "kind": "MethodSignature",
      "signature": "swap32(): this;",
      "doc": "Interprets `buf` as an array of unsigned 32-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: <Buffer 04 03 02 01 08 07 06 05>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.swap64",
      "kind": "MethodSignature",
      "signature": "swap64(): this;",
      "doc": "Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.\nThrows `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.3.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUInt8",
      "kind": "MethodSignature",
      "signature": "writeUInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a\nvalid unsigned 8-bit integer. Behavior is undefined when `value` is anything\nother than an unsigned 8-bit integer.\n\nThis function is also available under the `writeUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: <Buffer 03 04 23 42>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUint8",
      "kind": "MethodSignature",
      "signature": "writeUint8(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUInt16LE",
      "kind": "MethodSignature",
      "signature": "writeUInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 16-bit integer.\n\nThis function is also available under the `writeUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer ad de ef be>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUint16LE",
      "kind": "MethodSignature",
      "signature": "writeUint16LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUInt16BE",
      "kind": "MethodSignature",
      "signature": "writeUInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 16-bit integer.\n\nThis function is also available under the `writeUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer de ad be ef>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUint16BE",
      "kind": "MethodSignature",
      "signature": "writeUint16BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUInt32LE",
      "kind": "MethodSignature",
      "signature": "writeUInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 32-bit integer.\n\nThis function is also available under the `writeUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer ce fa ed fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUint32LE",
      "kind": "MethodSignature",
      "signature": "writeUint32LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUInt32BE",
      "kind": "MethodSignature",
      "signature": "writeUInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 32-bit integer.\n\nThis function is also available under the `writeUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer fe ed fa ce>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeUint32BE",
      "kind": "MethodSignature",
      "signature": "writeUint32BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeInt8",
      "kind": "MethodSignature",
      "signature": "writeInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a valid\nsigned 8-bit integer. Behavior is undefined when `value` is anything other than\na signed 8-bit integer.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: <Buffer 02 fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeInt16LE",
      "kind": "MethodSignature",
      "signature": "writeInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16LE(0x0304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 04 03>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeInt16BE",
      "kind": "MethodSignature",
      "signature": "writeInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16BE(0x0102, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeInt32LE",
      "kind": "MethodSignature",
      "signature": "writeInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32LE(0x05060708, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeInt32BE",
      "kind": "MethodSignature",
      "signature": "writeInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32BE(0x01020304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeFloatLE",
      "kind": "MethodSignature",
      "signature": "writeFloatLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer bb fe 4a 4f>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeFloatBE",
      "kind": "MethodSignature",
      "signature": "writeFloatBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 4f 4a fe bb>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeDoubleLE",
      "kind": "MethodSignature",
      "signature": "writeDoubleLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.writeDoubleBE",
      "kind": "MethodSignature",
      "signature": "writeDoubleBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 40 5e dd 2f 1a 9f be 77>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.fill",
      "kind": "MethodSignature",
      "signature": "fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;",
      "doc": "Fills `buf` with the specified `value`. If the `offset` and `end` are not given,\nthe entire `buf` will be filled:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with the ASCII character 'h'.\n\nconst b = Buffer.allocUnsafe(50).fill('h');\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n\n// Fill a buffer with empty string\nconst c = Buffer.allocUnsafe(5).fill('');\n\nconsole.log(c.fill(''));\n// Prints: <Buffer 00 00 00 00 00>\n```\n\n`value` is coerced to a `uint32` value if it is not a string, `Buffer`, or\ninteger. If the resulting integer is greater than `255` (decimal), `buf` will be\nfilled with `value &#x26; 255`.\n\nIf the final write of a `fill()` operation falls on a multi-byte character,\nthen only the bytes of that character that fit into `buf` are written:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with character that takes up two bytes in UTF-8.\n\nconsole.log(Buffer.allocUnsafe(5).fill('\\u0222'));\n// Prints: <Buffer c8 a2 c8 a2 c8>\n```\n\nIf `value` contains invalid characters, it is truncated; if no valid\nfill data remains, an exception is thrown:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill('a'));\n// Prints: <Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Throws an exception.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to fill `buf`."
        },
        {
          "tagName": "param",
          "text": "Where to stop filling `buf` (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The encoding for `value` if `value` is a string."
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "If `value` is:\n\n* a string, `value` is interpreted according to the character encoding in `encoding`.\n* a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.\nTo compare a partial `Buffer`, use `buf.subarray`.\n* a number, `value` will be interpreted as an unsigned 8-bit integer\nvalue between `0` and `255`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.indexOf('this'));\n// Prints: 0\nconsole.log(buf.indexOf('is'));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from('a buffer')));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.indexOf(Buffer.from('a buffer example')));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n// Prints: 6\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. If the result\nof coercion is `NaN` or `0`, then the entire buffer will be searched. This\nbehavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer` and `byteOffset` is less\nthan `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v1.5.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "Identical to `buf.indexOf()`, except the last occurrence of `value` is found\nrather than the first occurrence.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this buffer is a buffer');\n\nconsole.log(buf.lastIndexOf('this'));\n// Prints: 0\nconsole.log(buf.lastIndexOf('buffer'));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from('buffer')));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.lastIndexOf(Buffer.from('yolo')));\n// Prints: -1\nconsole.log(buf.lastIndexOf('buffer', 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf('buffer', 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n// Prints: 4\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. Any arguments\nthat coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.\nThis behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n\n// Passing a byteOffset that coerces to 0.\n// Prints: -1, equivalent to passing 0.\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.includes",
      "kind": "MethodSignature",
      "signature": "includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;",
      "doc": "Equivalent to `buf.indexOf() !== -1`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.includes('this'));\n// Prints: true\nconsole.log(buf.includes('is'));\n// Prints: true\nconsole.log(buf.includes(Buffer.from('a buffer')));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for 'a')\nconsole.log(buf.includes(Buffer.from('a buffer example')));\n// Prints: false\nconsole.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes('this', 4));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.3.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is its encoding."
        },
        {
          "tagName": "return",
          "text": "`true` if `value` was found in `buf`, `false` otherwise."
        }
      ]
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends number>(predicate:(value:number,index:number,array:this,)=>value is S,thisArg?:any,):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any,):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:number,b:number)=>number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createNonCryptographicHashBasedIdentifier.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName",
      "kind": "FunctionDeclaration",
      "signature": "export function getHardforkName(name: string): HardforkName {\n  const hardforkName =\n    Object.values(HardforkName)[\n      Object.values<string>(HardforkName).indexOf(name)\n    ];\n\n  assertHardhatInvariant(\n    hardforkName !== undefined,\n    `Invalid harfork name ${name}`\n  );\n\n  return hardforkNa",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.charAt",
      "kind": "MethodSignature",
      "signature": "charAt(pos:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.charCodeAt",
      "kind": "MethodSignature",
      "signature": "charCodeAt(index:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.concat",
      "kind": "MethodSignature",
      "signature": "concat(...strings:string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchString:string,position?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchString:string,position?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.localeCompare",
      "kind": "MethodSignature",
      "signature": "localeCompare(that:string):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.match",
      "kind": "MethodSignature",
      "signature": "match(regexp:string|RegExp):RegExpMatchArray|null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.replace",
      "kind": "MethodSignature",
      "signature": "replace(searchValue:string|RegExp,replaceValue:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.search",
      "kind": "MethodSignature",
      "signature": "search(regexp:string|RegExp):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.split",
      "kind": "MethodSignature",
      "signature": "split(separator:string|RegExp,limit?:number):string[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.substring",
      "kind": "MethodSignature",
      "signature": "substring(start:number,end?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.toLowerCase",
      "kind": "MethodSignature",
      "signature": "toLowerCase():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.toLocaleLowerCase",
      "kind": "MethodSignature",
      "signature": "toLocaleLowerCase(locales?:string|string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.toUpperCase",
      "kind": "MethodSignature",
      "signature": "toUpperCase():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.toLocaleUpperCase",
      "kind": "MethodSignature",
      "signature": "toLocaleUpperCase(locales?:string|string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.trim",
      "kind": "MethodSignature",
      "signature": "trim():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.substr",
      "kind": "MethodSignature",
      "signature": "substr(from:number,length?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.codePointAt",
      "kind": "MethodSignature",
      "signature": "codePointAt(pos:number):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchString:string,position?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.endsWith",
      "kind": "MethodSignature",
      "signature": "endsWith(searchString:string,endPosition?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.normalize",
      "kind": "MethodSignature",
      "signature": "normalize(form:\"NFC\"|\"NFD\"|\"NFKC\"|\"NFKD\"):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.repeat",
      "kind": "MethodSignature",
      "signature": "repeat(count:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.startsWith",
      "kind": "MethodSignature",
      "signature": "startsWith(searchString:string,position?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.anchor",
      "kind": "MethodSignature",
      "signature": "anchor(name:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.big",
      "kind": "MethodSignature",
      "signature": "big():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.blink",
      "kind": "MethodSignature",
      "signature": "blink():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.bold",
      "kind": "MethodSignature",
      "signature": "bold():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.fixed",
      "kind": "MethodSignature",
      "signature": "fixed():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.fontcolor",
      "kind": "MethodSignature",
      "signature": "fontcolor(color:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.fontsize",
      "kind": "MethodSignature",
      "signature": "fontsize(size:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.italics",
      "kind": "MethodSignature",
      "signature": "italics():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.link",
      "kind": "MethodSignature",
      "signature": "link(url:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.small",
      "kind": "MethodSignature",
      "signature": "small():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.strike",
      "kind": "MethodSignature",
      "signature": "strike():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.sub",
      "kind": "MethodSignature",
      "signature": "sub():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.sup",
      "kind": "MethodSignature",
      "signature": "sup():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.padStart",
      "kind": "MethodSignature",
      "signature": "padStart(maxLength:number,fillString?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.padEnd",
      "kind": "MethodSignature",
      "signature": "padEnd(maxLength:number,fillString?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.trimEnd",
      "kind": "MethodSignature",
      "signature": "trimEnd():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.trimStart",
      "kind": "MethodSignature",
      "signature": "trimStart():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.trimLeft",
      "kind": "MethodSignature",
      "signature": "trimLeft():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.trimRight",
      "kind": "MethodSignature",
      "signature": "trimRight():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.matchAll",
      "kind": "MethodSignature",
      "signature": "matchAll(regexp:RegExp):RegExpStringIterator<RegExpExecArray>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.replaceAll",
      "kind": "MethodSignature",
      "signature": "replaceAll(searchValue:string|RegExp,replaceValue:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):string|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.isWellFormed",
      "kind": "MethodSignature",
      "signature": "isWellFormed():boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.toWellFormed",
      "kind": "MethodSignature",
      "signature": "toWellFormed():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getHardforkName.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():StringIterator<string>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "hardforkGte",
      "kind": "FunctionDeclaration",
      "signature": "export function hardforkGte(\n  hardforkA: HardforkName,\n  hardforkB: HardforkName\n): boolean {\n  // This function should not load any ethereumjs library, as it's used during\n  // the Hardhat initialization, and that would make it too slow.\n  const indexA = HARDFORKS_ORDER.lastIndexOf(hardforkA);\n  c",
      "doc": "Check if `hardforkA` is greater than or equal to `hardforkB`,\nthat is, if it includes all its changes.",
      "tags": []
    },
    {
      "name": "selectHardfork",
      "kind": "FunctionDeclaration",
      "signature": "export function selectHardfork(\n  forkBlockNumber: bigint | undefined,\n  currentHardfork: string,\n  hardforkActivations: HardforkHistoryConfig | undefined,\n  blockNumber: bigint\n): string {\n  if (forkBlockNumber === undefined || blockNumber > forkBlockNumber) {\n    return currentHardfork;\n  }\n\n  if ",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardforkName",
      "kind": "EnumDeclaration",
      "signature": "export enum HardforkName {\n  FRONTIER = \"chainstart\",\n  HOMESTEAD = \"homestead\",\n  DAO = \"dao\",\n  TANGERINE_WHISTLE = \"tangerineWhistle\",\n  SPURIOUS_DRAGON = \"spuriousDragon\",\n  BYZANTIUM = \"byzantium\",\n  CONSTANTINOPLE = \"constantinople\",\n  PETERSBURG = \"petersburg\",\n  ISTANBUL = \"istanbul\",\n  MUIR",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCacheDir",
      "kind": "FunctionDeclaration",
      "signature": "export async function getCacheDir(): Promise<string> {\n  const { cache } = await generatePaths();\n  await fs.ensureDir(cache);\n  return cache;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCacheDir.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCacheDir.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCacheDir.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCacheDir.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readAnalyticsId",
      "kind": "FunctionDeclaration",
      "signature": "export async function readAnalyticsId() {\n  const globalDataDir = await getDataDir();\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "readAnalyticsId.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readAnalyticsId.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readAnalyticsId.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readAnalyticsId.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readFirstLegacyAnalyticsId",
      "kind": "FunctionDeclaration",
      "signature": "export function readFirstLegacyAnalyticsId() {\n  const oldIdFile = path.join(os.homedir(), \".buidler\", \"config.json\");\n  return readId(oldIdFile);\n}",
      "doc": "This is the first way that the analytics id was saved.",
      "tags": []
    },
    {
      "name": "readFirstLegacyAnalyticsId.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readFirstLegacyAnalyticsId.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readFirstLegacyAnalyticsId.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readFirstLegacyAnalyticsId.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readSecondLegacyAnalyticsId",
      "kind": "FunctionDeclaration",
      "signature": "export async function readSecondLegacyAnalyticsId() {\n  const globalDataDir = await getDataDir(\"buidler\");\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}",
      "doc": "This is the same way the analytics id is saved now, but using buidler as the\nname of the project for env-paths",
      "tags": []
    },
    {
      "name": "readSecondLegacyAnalyticsId.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readSecondLegacyAnalyticsId.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readSecondLegacyAnalyticsId.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "readSecondLegacyAnalyticsId.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "writeAnalyticsId",
      "kind": "FunctionDeclaration",
      "signature": "export async function writeAnalyticsId(clientId: string) {\n  const globalDataDir = await getDataDir();\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  await fs.writeJSON(\n    idFile,\n    {\n      analytics: {\n        clientId,\n      },\n    },\n    { encoding: \"utf-8\", spaces: 2 }\n  );\n ",
      "doc": "",
      "tags": []
    },
    {
      "name": "writeAnalyticsId.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "writeAnalyticsId.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "writeAnalyticsId.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "writeAnalyticsId.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCompilersDir",
      "kind": "FunctionDeclaration",
      "signature": "export async function getCompilersDir() {\n  const cache = await getCacheDir();\n  // Note: we introduce `-v2` to invalidate all the previous compilers at once\n  const compilersCache = path.join(cache, \"compilers-v2\");\n  await fs.ensureDir(compilersCache);\n  return compilersCache;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCompilersDir.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCompilersDir.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCompilersDir.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCompilersDir.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "hasConsentedTelemetry",
      "kind": "FunctionDeclaration",
      "signature": "export function hasConsentedTelemetry(): boolean | undefined {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path.join(configDir, \"telemetry-consent.json\");\n\n  const fileExists = fs.pathExistsSync(telemetryConsentPath);\n\n  if (!fileExists) {\n    return undefined;\n  }\n\n  cons",
      "doc": "Checks if the user has given (or refused) consent for telemetry.\n\nReturns undefined if it can't be determined.",
      "tags": []
    },
    {
      "name": "writeTelemetryConsent",
      "kind": "FunctionDeclaration",
      "signature": "export function writeTelemetryConsent(consent: boolean) {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path.join(configDir, \"telemetry-consent.json\");\n\n  fs.writeJSONSync(telemetryConsentPath, { consent }, { spaces: 2 });\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "hasPromptedForHHVSCode",
      "kind": "FunctionDeclaration",
      "signature": "export function hasPromptedForHHVSCode(): boolean {\n  const configDir = getConfigDirSync();\n  const extensionPromptedPath = path.join(configDir, \"extension-prompt.json\");\n\n  const fileExists = fs.pathExistsSync(extensionPromptedPath);\n\n  return fileExists;\n}",
      "doc": "Checks if we have already prompted the user to install the Hardhat for VSCode extension.",
      "tags": []
    },
    {
      "name": "writePromptedForHHVSCode",
      "kind": "FunctionDeclaration",
      "signature": "export function writePromptedForHHVSCode() {\n  const configDir = getConfigDirSync();\n  const extensionPromptedPath = path.join(configDir, \"extension-prompt.json\");\n\n  fs.writeFileSync(extensionPromptedPath, \"{}\");\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getVarsFilePath",
      "kind": "FunctionDeclaration",
      "signature": "export function getVarsFilePath(): string {\n  return path.join(getConfigDirSync(), \"vars.json\");\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "glob",
      "kind": "FunctionDeclaration",
      "signature": "export async function glob(\n  pattern: string,\n  options: GlobOptions = {}\n): Promise<string[]> {\n  const files = await (await import(\"tinyglobby\")).glob([pattern], options);\n  return files.map(path.normalize);\n}",
      "doc": "DO NOT USE THIS FUNCTION. It's SLOW and its semantics are optimized for\nuser-facing CLI globs, not traversing the FS.\n\nIt's not removed because unfortunately some plugins used it, like the truffle\nones.",
      "tags": [
        {
          "tagName": "deprecated",
          "text": ""
        }
      ]
    },
    {
      "name": "glob.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "glob.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "glob.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "glob.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync",
      "kind": "FunctionDeclaration",
      "signature": "export function globSync(pattern: string, options: GlobOptions = {}): string[] {\n  const files = (require(\"tinyglobby\") as typeof import(\"tinyglobby\")).globSync(\n    [pattern],\n    options\n  );\n  return files.map(path.normalize);\n}",
      "doc": "",
      "tags": [
        {
          "tagName": "deprecated",
          "text": ""
        },
        {
          "tagName": "see",
          "text": ""
        }
      ]
    },
    {
      "name": "globSync.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "globSync.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRealPath",
      "kind": "FunctionDeclaration",
      "signature": "export async function getRealPath(absolutePath: string): Promise<string> {\n  try {\n    // This method returns the actual casing.\n    // Please read Node.js' docs to learn more.\n    return await fsPromises.realpath(path.normalize(absolutePath));\n  } catch (e: any) {\n    if (e.code === \"ENOENT\") {\n   ",
      "doc": "Returns the real path of absolutePath, resolving symlinks.",
      "tags": [
        {
          "tagName": "throws",
          "text": "FileNotFoundError if absolutePath doesn't exist."
        }
      ]
    },
    {
      "name": "getRealPath.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRealPath.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRealPath.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRealPath.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRealPathSync",
      "kind": "FunctionDeclaration",
      "signature": "export function getRealPathSync(absolutePath: string): string {\n  try {\n    // This method returns the actual casing.\n    // Please read Node.js' docs to learn more.\n    return fs.realpathSync.native(path.normalize(absolutePath));\n  } catch (e: any) {\n    if (e.code === \"ENOENT\") {\n      // eslint-d",
      "doc": "Sync version of getRealPath",
      "tags": [
        {
          "tagName": "see",
          "text": ""
        }
      ]
    },
    {
      "name": "getAllFilesMatching",
      "kind": "FunctionDeclaration",
      "signature": "export async function getAllFilesMatching(\n  absolutePathToDir: string,\n  matches?: (absolutePathToFile: string) => boolean\n): Promise<string[]> {\n  const dir = await readdir(absolutePathToDir);\n\n  const results = await Promise.all(\n    dir.map(async (file) => {\n      const absolutePathToFile = path",
      "doc": "Returns an array of files (not dirs) that match a condition.",
      "tags": [
        {
          "tagName": "param",
          "text": "A directory. If it doesn't exist `[]` is returned."
        },
        {
          "tagName": "param",
          "text": "A function to filter files (not directories)"
        },
        {
          "tagName": "returns",
          "text": "An array of absolute paths. Each file has its true case, except\nfor the initial absolutePathToDir part, which preserves the given casing.\nNo order is guaranteed."
        }
      ]
    },
    {
      "name": "getAllFilesMatching.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatching.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatching.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatching.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync",
      "kind": "FunctionDeclaration",
      "signature": "export function getAllFilesMatchingSync(\n  absolutePathToDir: string,\n  matches?: (absolutePathToFile: string) => boolean\n): string[] {\n  const dir = readdirSync(absolutePathToDir);\n\n  const results = dir.map((file) => {\n    const absolutePathToFile = path.join(absolutePathToDir, file);\n    const st",
      "doc": "Sync version of getAllFilesMatching",
      "tags": [
        {
          "tagName": "see",
          "text": ""
        }
      ]
    },
    {
      "name": "getAllFilesMatchingSync.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getAllFilesMatchingSync.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "getFileTrueCase",
      "kind": "FunctionDeclaration",
      "signature": "export async function getFileTrueCase(\n  from: string,\n  relativePath: string\n): Promise<string> {\n  const dirEntries = await readdir(from);\n\n  const parts = relativePath.split(path.sep);\n  const nextDirLowerCase = parts[0].toLowerCase();\n\n  for (const dirEntry of dirEntries) {\n    if (dirEntry.toLo",
      "doc": "Returns the true case relative path of `relativePath` from `from`, without\nresolving symlinks.",
      "tags": []
    },
    {
      "name": "getFileTrueCase.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getFileTrueCase.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getFileTrueCase.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getFileTrueCase.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getFileTrueCaseSync",
      "kind": "FunctionDeclaration",
      "signature": "export function getFileTrueCaseSync(\n  from: string,\n  relativePath: string\n): string {\n  const dirEntries = readdirSync(from);\n\n  const parts = relativePath.split(path.sep);\n  const nextDirLowerCase = parts[0].toLowerCase();\n\n  for (const dirEntry of dirEntries) {\n    if (dirEntry.toLowerCase() ===",
      "doc": "Sync version of getFileTrueCase",
      "tags": [
        {
          "tagName": "see",
          "text": ""
        }
      ]
    },
    {
      "name": "FileSystemAccessError",
      "kind": "ClassDeclaration",
      "signature": "export class FileSystemAccessError extends CustomError {}",
      "doc": "",
      "tags": []
    },
    {
      "name": "FileNotFoundError",
      "kind": "ClassDeclaration",
      "signature": "export class FileNotFoundError extends CustomError {\n  constructor(filePath: string, parent?: Error) {\n    super(`File ${filePath} not found`, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InvalidDirectoryError",
      "kind": "ClassDeclaration",
      "signature": "export class InvalidDirectoryError extends CustomError {\n  constructor(filePath: string, parent: Error) {\n    super(`Invalid directory ${filePath}`, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EventEmitterWrapper",
      "kind": "ClassDeclaration",
      "signature": "export class EventEmitterWrapper implements EventEmitter {\n  constructor(private readonly _wrapped: EventEmitter) {}\n\n  public addListener(\n    event: string | symbol,\n    listener: (...args: any[]) => void\n  ): this {\n    this._wrapped.addListener(event, listener);\n    return this;\n  }\n\n  public on",
      "doc": "",
      "tags": []
    },
    {
      "name": "download",
      "kind": "FunctionDeclaration",
      "signature": "export async function download(\n  url: string,\n  filePath: string,\n  timeoutMillis = 10000,\n  extraHeaders: { [name: string]: string } = {}\n) {\n  const { getGlobalDispatcher, ProxyAgent, request } = await import(\"undici\");\n\n  let dispatcher: Dispatcher;\n  if (process.env.http_proxy !== undefined && ",
      "doc": "",
      "tags": []
    },
    {
      "name": "download.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "download.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "download.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "download.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString",
      "kind": "FunctionDeclaration",
      "signature": "export function parseDateString(str: string): Date {\n  return new Date(str);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toDateString",
      "kind": "MethodSignature",
      "signature": "toDateString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toTimeString",
      "kind": "MethodSignature",
      "signature": "toTimeString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toLocaleDateString",
      "kind": "MethodSignature",
      "signature": "toLocaleDateString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toLocaleTimeString",
      "kind": "MethodSignature",
      "signature": "toLocaleTimeString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getTime",
      "kind": "MethodSignature",
      "signature": "getTime():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getFullYear",
      "kind": "MethodSignature",
      "signature": "getFullYear():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getUTCFullYear",
      "kind": "MethodSignature",
      "signature": "getUTCFullYear():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getMonth",
      "kind": "MethodSignature",
      "signature": "getMonth():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getUTCMonth",
      "kind": "MethodSignature",
      "signature": "getUTCMonth():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getDate",
      "kind": "MethodSignature",
      "signature": "getDate():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getUTCDate",
      "kind": "MethodSignature",
      "signature": "getUTCDate():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getDay",
      "kind": "MethodSignature",
      "signature": "getDay():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getUTCDay",
      "kind": "MethodSignature",
      "signature": "getUTCDay():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getHours",
      "kind": "MethodSignature",
      "signature": "getHours():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getUTCHours",
      "kind": "MethodSignature",
      "signature": "getUTCHours():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getMinutes",
      "kind": "MethodSignature",
      "signature": "getMinutes():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getUTCMinutes",
      "kind": "MethodSignature",
      "signature": "getUTCMinutes():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getSeconds",
      "kind": "MethodSignature",
      "signature": "getSeconds():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getUTCSeconds",
      "kind": "MethodSignature",
      "signature": "getUTCSeconds():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getMilliseconds",
      "kind": "MethodSignature",
      "signature": "getMilliseconds():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getUTCMilliseconds",
      "kind": "MethodSignature",
      "signature": "getUTCMilliseconds():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getTimezoneOffset",
      "kind": "MethodSignature",
      "signature": "getTimezoneOffset():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setTime",
      "kind": "MethodSignature",
      "signature": "setTime(time:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setMilliseconds",
      "kind": "MethodSignature",
      "signature": "setMilliseconds(ms:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setUTCMilliseconds",
      "kind": "MethodSignature",
      "signature": "setUTCMilliseconds(ms:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setSeconds",
      "kind": "MethodSignature",
      "signature": "setSeconds(sec:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setUTCSeconds",
      "kind": "MethodSignature",
      "signature": "setUTCSeconds(sec:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setMinutes",
      "kind": "MethodSignature",
      "signature": "setMinutes(min:number,sec?:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setUTCMinutes",
      "kind": "MethodSignature",
      "signature": "setUTCMinutes(min:number,sec?:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setHours",
      "kind": "MethodSignature",
      "signature": "setHours(hours:number,min?:number,sec?:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setUTCHours",
      "kind": "MethodSignature",
      "signature": "setUTCHours(hours:number,min?:number,sec?:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setDate",
      "kind": "MethodSignature",
      "signature": "setDate(date:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setUTCDate",
      "kind": "MethodSignature",
      "signature": "setUTCDate(date:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setMonth",
      "kind": "MethodSignature",
      "signature": "setMonth(month:number,date?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setUTCMonth",
      "kind": "MethodSignature",
      "signature": "setUTCMonth(month:number,date?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setFullYear",
      "kind": "MethodSignature",
      "signature": "setFullYear(year:number,month?:number,date?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.setUTCFullYear",
      "kind": "MethodSignature",
      "signature": "setUTCFullYear(year:number,month?:number,date?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toUTCString",
      "kind": "MethodSignature",
      "signature": "toUTCString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toISOString",
      "kind": "MethodSignature",
      "signature": "toISOString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.toJSON",
      "kind": "MethodSignature",
      "signature": "toJSON(key?:any):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.getVarDate",
      "kind": "PropertySignature",
      "signature": "getVarDate:()=>VarDate;",
      "doc": "",
      "tags": []
    },
    {
      "name": "parseDateString.__@toPrimitive@383",
      "kind": "MethodSignature",
      "signature": "[Symbol.toPrimitive](hint:\"default\"):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "dateToTimestampSeconds",
      "kind": "FunctionDeclaration",
      "signature": "export function dateToTimestampSeconds(date: Date): number {\n  return Math.floor(date.valueOf() / 1000);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate",
      "kind": "FunctionDeclaration",
      "signature": "export function timestampSecondsToDate(timestamp: number): Date {\n  return new Date(timestamp * 1000);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toDateString",
      "kind": "MethodSignature",
      "signature": "toDateString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toTimeString",
      "kind": "MethodSignature",
      "signature": "toTimeString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toLocaleDateString",
      "kind": "MethodSignature",
      "signature": "toLocaleDateString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toLocaleTimeString",
      "kind": "MethodSignature",
      "signature": "toLocaleTimeString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getTime",
      "kind": "MethodSignature",
      "signature": "getTime():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getFullYear",
      "kind": "MethodSignature",
      "signature": "getFullYear():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getUTCFullYear",
      "kind": "MethodSignature",
      "signature": "getUTCFullYear():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getMonth",
      "kind": "MethodSignature",
      "signature": "getMonth():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getUTCMonth",
      "kind": "MethodSignature",
      "signature": "getUTCMonth():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getDate",
      "kind": "MethodSignature",
      "signature": "getDate():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getUTCDate",
      "kind": "MethodSignature",
      "signature": "getUTCDate():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getDay",
      "kind": "MethodSignature",
      "signature": "getDay():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getUTCDay",
      "kind": "MethodSignature",
      "signature": "getUTCDay():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getHours",
      "kind": "MethodSignature",
      "signature": "getHours():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getUTCHours",
      "kind": "MethodSignature",
      "signature": "getUTCHours():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getMinutes",
      "kind": "MethodSignature",
      "signature": "getMinutes():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getUTCMinutes",
      "kind": "MethodSignature",
      "signature": "getUTCMinutes():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getSeconds",
      "kind": "MethodSignature",
      "signature": "getSeconds():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getUTCSeconds",
      "kind": "MethodSignature",
      "signature": "getUTCSeconds():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getMilliseconds",
      "kind": "MethodSignature",
      "signature": "getMilliseconds():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getUTCMilliseconds",
      "kind": "MethodSignature",
      "signature": "getUTCMilliseconds():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getTimezoneOffset",
      "kind": "MethodSignature",
      "signature": "getTimezoneOffset():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setTime",
      "kind": "MethodSignature",
      "signature": "setTime(time:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setMilliseconds",
      "kind": "MethodSignature",
      "signature": "setMilliseconds(ms:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setUTCMilliseconds",
      "kind": "MethodSignature",
      "signature": "setUTCMilliseconds(ms:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setSeconds",
      "kind": "MethodSignature",
      "signature": "setSeconds(sec:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setUTCSeconds",
      "kind": "MethodSignature",
      "signature": "setUTCSeconds(sec:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setMinutes",
      "kind": "MethodSignature",
      "signature": "setMinutes(min:number,sec?:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setUTCMinutes",
      "kind": "MethodSignature",
      "signature": "setUTCMinutes(min:number,sec?:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setHours",
      "kind": "MethodSignature",
      "signature": "setHours(hours:number,min?:number,sec?:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setUTCHours",
      "kind": "MethodSignature",
      "signature": "setUTCHours(hours:number,min?:number,sec?:number,ms?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setDate",
      "kind": "MethodSignature",
      "signature": "setDate(date:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setUTCDate",
      "kind": "MethodSignature",
      "signature": "setUTCDate(date:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setMonth",
      "kind": "MethodSignature",
      "signature": "setMonth(month:number,date?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setUTCMonth",
      "kind": "MethodSignature",
      "signature": "setUTCMonth(month:number,date?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setFullYear",
      "kind": "MethodSignature",
      "signature": "setFullYear(year:number,month?:number,date?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.setUTCFullYear",
      "kind": "MethodSignature",
      "signature": "setUTCFullYear(year:number,month?:number,date?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toUTCString",
      "kind": "MethodSignature",
      "signature": "toUTCString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toISOString",
      "kind": "MethodSignature",
      "signature": "toISOString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.toJSON",
      "kind": "MethodSignature",
      "signature": "toJSON(key?:any):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.getVarDate",
      "kind": "PropertySignature",
      "signature": "getVarDate:()=>VarDate;",
      "doc": "",
      "tags": []
    },
    {
      "name": "timestampSecondsToDate.__@toPrimitive@383",
      "kind": "MethodSignature",
      "signature": "[Symbol.toPrimitive](hint:\"default\"):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getDifferenceInSeconds",
      "kind": "FunctionDeclaration",
      "signature": "export function getDifferenceInSeconds(a: Date, b: Date): number {\n  return Math.floor((a.valueOf() - b.valueOf()) / 1000);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "isNodeCalledWithoutAScript",
      "kind": "FunctionDeclaration",
      "signature": "export function isNodeCalledWithoutAScript() {\n  const script = process.argv[1];\n  return script === undefined || script.trim() === \"\";\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "disableReplWriterShowProxy",
      "kind": "FunctionDeclaration",
      "signature": "export function disableReplWriterShowProxy() {\n  const repl = require(\"repl\") as typeof ReplT;\n\n  if (repl.writer.options !== undefined) {\n    Object.defineProperty(repl.writer.options, \"showProxy\", {\n      value: false,\n      writable: false,\n      configurable: false,\n    });\n  }\n}",
      "doc": "Starting at node 10, proxies are shown in the console by default, instead\nof actually inspecting them. This makes all our lazy loading efforts wicked,\nso we disable it in hardhat/register.",
      "tags": []
    },
    {
      "name": "isRunningOnCiServer",
      "kind": "FunctionDeclaration",
      "signature": "export function isRunningOnCiServer(): boolean {\n  const ci = require(\"ci-info\") as typeof CiInfoT;\n  return (\n    ci.isCI ||\n    isGithubActions() ||\n    isLinuxWithoutDisplayServer() ||\n    isNow() ||\n    isAwsCodeBuild()\n  );\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getClosestCallerPackage",
      "kind": "FunctionDeclaration",
      "signature": "export function getClosestCallerPackage(): string | undefined {\n  const previousPrepareStackTrace = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = (e, s) => s;\n\n  const error = new Error();\n  const stack: NodeJS.CallSite[] = error.stack as any;\n\n  Error.prepareStackTrace = previousPrepareStac",
      "doc": "Returns the name of the closest package in the callstack that isn't this.",
      "tags": []
    },
    {
      "name": "min",
      "kind": "FunctionDeclaration",
      "signature": "export function min(x: bigint, y: bigint): bigint {\n  return x < y ? x : y;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "max",
      "kind": "FunctionDeclaration",
      "signature": "export function max(x: bigint, y: bigint): bigint {\n  return x > y ? x : y;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "isBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function isBigInt(x: unknown): x is bigint {\n  return typeof x === \"bigint\";\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "divUp",
      "kind": "FunctionDeclaration",
      "signature": "export function divUp(x: bigint, y: bigint): bigint {\n  let result = x / y;\n\n  if (x % y !== 0n) {\n    result = result + 1n;\n  }\n\n  return result;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "cmp",
      "kind": "FunctionDeclaration",
      "signature": "export function cmp(a: bigint, b: bigint): number {\n  return a < b ? -1 : a > b ? 1 : 0;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "toEvmWord",
      "kind": "FunctionDeclaration",
      "signature": "export function toEvmWord(x: bigint | number): string {\n  return x.toString(16).padStart(64, \"0\");\n}",
      "doc": "Converts the number to a hexadecimal string with a length of 32\nbytes. This hex string is NOT 0x-prefixed.",
      "tags": []
    },
    {
      "name": "fromBigIntLike",
      "kind": "FunctionDeclaration",
      "signature": "export function fromBigIntLike(\n  x: string | number | bigint | Uint8Array | undefined\n): bigint | undefined {\n  if (x === undefined || typeof x === \"bigint\") {\n    return x;\n  }\n  if (typeof x === \"number\" || typeof x === \"string\") {\n    return BigInt(x);\n  }\n  if (x instanceof Uint8Array) {\n    re",
      "doc": "",
      "tags": []
    },
    {
      "name": "toHex",
      "kind": "FunctionDeclaration",
      "signature": "export function toHex(x: number | bigint): string {\n  assertHardhatInvariant(\n    x >= 0,\n    `toHex can only be used with non-negative numbers, but received ${x}`\n  );\n\n  return `0x${x.toString(16)}`;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "AbiHelpers",
      "kind": "ClassDeclaration",
      "signature": "export class AbiHelpers {\n  /**\n   * Try to compute the selector for the function/event/error\n   * with the given name and param types. Return undefined\n   * if it cannot do it. This can happen if some ParamType is\n   * not understood by @ethersproject/abi\n   */\n  public static computeSelector(\n    ",
      "doc": "",
      "tags": []
    },
    {
      "name": "ResolvedFilesMap",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ResolvedFilesMap {\n  [sourceName: string]: ResolvedFile;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ResolvedFile",
      "kind": "ClassDeclaration",
      "signature": "export class ResolvedFile implements IResolvedFile {\n  public readonly library?: LibraryInfo;\n\n  constructor(\n    public readonly sourceName: string,\n    public readonly absolutePath: string,\n    public readonly content: FileContent,\n    public readonly contentHash: string,\n    public readonly lastM",
      "doc": "",
      "tags": []
    },
    {
      "name": "Resolver",
      "kind": "ClassDeclaration",
      "signature": "export class Resolver {\n  private readonly _cache: Map<string, ResolvedFile> = new Map();\n\n  constructor(\n    private readonly _projectRoot: string,\n    private readonly _parser: Parser,\n    private readonly _remappings: Record<string, string>,\n    private readonly _readFile: (absolutePath: string) ",
      "doc": "",
      "tags": []
    },
    {
      "name": "Parser",
      "kind": "ClassDeclaration",
      "signature": "export class Parser {\n  private _cache = new Map<string, ParsedData>();\n  private _solidityFilesCache: SolidityFilesCache;\n\n  constructor(_solidityFilesCache?: SolidityFilesCache) {\n    this._solidityFilesCache =\n      _solidityFilesCache ?? SolidityFilesCache.createEmpty();\n  }\n\n  public parse(\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "DependencyGraph",
      "kind": "ClassDeclaration",
      "signature": "export class DependencyGraph implements taskTypes.DependencyGraph {\n  public static async createFromResolvedFiles(\n    resolver: Resolver,\n    resolvedFiles: ResolvedFile[]\n  ): Promise<DependencyGraph> {\n    const graph = new DependencyGraph();\n\n    // TODO refactor this to make the results determi",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobsFromConnectedComponent",
      "kind": "FunctionDeclaration",
      "signature": "export async function createCompilationJobsFromConnectedComponent(\n  connectedComponent: taskTypes.DependencyGraph,\n  getFromFile: (\n    file: ResolvedFile\n  ) => Promise<taskTypes.CompilationJob | CompilationJobCreationError>\n): Promise<CompilationJobsCreationResult> {\n  const compilationJobs: task",
      "doc": "Creates a list of compilation jobs from a dependency graph. *This function\nassumes that the given graph is a connected component*.\nReturns the list of compilation jobs on success, and a list of\nnon-compilable files on failure.",
      "tags": []
    },
    {
      "name": "createCompilationJobsFromConnectedComponent.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobsFromConnectedComponent.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobsFromConnectedComponent.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobsFromConnectedComponent.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobFromFile",
      "kind": "FunctionDeclaration",
      "signature": "export async function createCompilationJobFromFile(\n  dependencyGraph: taskTypes.DependencyGraph,\n  file: ResolvedFile,\n  solidityConfig: SolidityConfig\n): Promise<CompilationJob | CompilationJobCreationError> {\n  const directDependencies = dependencyGraph.getDependencies(file);\n  const transitiveDe",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobFromFile.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobFromFile.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobFromFile.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createCompilationJobFromFile.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug",
      "kind": "FunctionDeclaration",
      "signature": "export function mergeCompilationJobsWithBug(\n  compilationJobs: taskTypes.CompilationJob[]\n): taskTypes.CompilationJob[] {\n  return mergeCompilationJobs(compilationJobs, (job) => job.hasSolc9573Bug());\n}",
      "doc": "Merge compilation jobs affected by the solc #9573 bug",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithBug.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug",
      "kind": "FunctionDeclaration",
      "signature": "export function mergeCompilationJobsWithoutBug(\n  compilationJobs: taskTypes.CompilationJob[]\n): taskTypes.CompilationJob[] {\n  return mergeCompilationJobs(compilationJobs, (job) => !job.hasSolc9573Bug());\n}",
      "doc": "Merge compilation jobs not affected by the solc #9573 bug",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "mergeCompilationJobsWithoutBug.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilationJob",
      "kind": "ClassDeclaration",
      "signature": "export class CompilationJob implements taskTypes.CompilationJob {\n  private _filesToCompile: Map<\n    string,\n    { file: ResolvedFile; emitsArtifacts: boolean }\n  > = new Map();\n\n  constructor(public solidityConfig: SolcConfig) {}\n\n  public addFileToCompile(file: ResolvedFile, emitsArtifacts: boole",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEvmVersionFromSolcVersion",
      "kind": "FunctionDeclaration",
      "signature": "export function getEvmVersionFromSolcVersion(\n  solcVersion: string\n): string | undefined {\n  return defaultEvmTargets[solcVersion];\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "execFileWithInput",
      "kind": "FunctionDeclaration",
      "signature": "export async function execFileWithInput(\n  file: string,\n  args: readonly string[],\n  input: string,\n  options: ExecFileOptions = {}\n): Promise<{ stdout: string; stderr: string }> {\n  return new Promise((resolve, reject) => {\n    const child = execFile(file, args, options, (error, stdout, stderr) =>",
      "doc": "Executes a command using execFile, writes provided input to stdin,\nand returns a Promise that resolves with stdout and stderr.",
      "tags": [
        {
          "tagName": "param",
          "text": "- The file to execute."
        },
        {
          "tagName": "param",
          "text": "- The arguments to pass to the file."
        },
        {
          "tagName": "param",
          "text": "- The options to pass to the exec function."
        },
        {
          "tagName": "returns",
          "text": ""
        }
      ]
    },
    {
      "name": "execFileWithInput.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "execFileWithInput.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "execFileWithInput.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "execFileWithInput.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ICompiler",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ICompiler {\n  compile(input: CompilerInput): Promise<CompilerOutput>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "Compiler",
      "kind": "ClassDeclaration",
      "signature": "export class Compiler implements ICompiler {\n  constructor(private _pathToSolcJs: string) {}\n\n  public async compile(input: CompilerInput) {\n    const scriptPath = path.join(__dirname, \"./solcjs-runner.js\");\n\n    let output: string;\n    try {\n      const { stdout } = await execFileWithInput(\n       ",
      "doc": "",
      "tags": []
    },
    {
      "name": "NativeCompiler",
      "kind": "ClassDeclaration",
      "signature": "export class NativeCompiler implements ICompiler {\n  constructor(private _pathToSolc: string, private _solcVersion?: string) {}\n\n  public async compile(input: CompilerInput) {\n    const args = [\"--standard-json\"];\n\n    // Logic to make sure that solc default import callback is not being used.\n    //",
      "doc": "",
      "tags": []
    },
    {
      "name": "CompilerPlatform",
      "kind": "EnumDeclaration",
      "signature": "export enum CompilerPlatform {\n  LINUX = \"linux-amd64\",\n  WINDOWS = \"windows-amd64\",\n  MACOS = \"macosx-amd64\",\n  WASM = \"wasm\",\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "Compiler",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Compiler {\n  version: string;\n  longVersion: string;\n  compilerPath: string;\n  isSolcJs: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ICompilerDownloader",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ICompilerDownloader {\n  /**\n   * Returns true if the compiler has been downloaded.\n   *\n   * This function access the filesystem, but doesn't modify it.\n   */\n  isCompilerDownloaded(version: string): Promise<boolean>;\n\n  /**\n   * Downloads the compiler for a given version, which can",
      "doc": "A compiler downloader which must be specialized per-platform. It can't and\nshouldn't support multiple platforms at the same time.",
      "tags": []
    },
    {
      "name": "CompilerDownloader",
      "kind": "ClassDeclaration",
      "signature": "export class CompilerDownloader implements ICompilerDownloader {\n  public static getCompilerPlatform(): CompilerPlatform {\n    // TODO: This check is seriously wrong. It doesn't take into account\n    //  the architecture nor the toolchain. This should check the triplet of\n    //  system instead (see",
      "doc": "Default implementation of ICompilerDownloader.\n\nImportant things to note:\n  1. If a compiler version is not found, this downloader may fail.\n   1.1. It only re-downloads the list of compilers once every X time.\n     1.1.1 If a user tries to download a new compiler before X amount of time\n     has passed since its release, they may need to clean the cache, as\n     indicated in the error messages.",
      "tags": []
    },
    {
      "name": "getInputFromCompilationJob",
      "kind": "FunctionDeclaration",
      "signature": "export function getInputFromCompilationJob(\n  compilationJob: CompilationJob\n): CompilerInput {\n  const sources: { [sourceName: string]: { content: string } } = {};\n\n  // we sort the files so that we always get the same compilation input\n  const resolvedFiles = compilationJob\n    .getResolvedFiles()",
      "doc": "",
      "tags": []
    },
    {
      "name": "getInputFromCompilationJob.language",
      "kind": "PropertySignature",
      "signature": "language: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getInputFromCompilationJob.sources",
      "kind": "PropertySignature",
      "signature": "sources: { [sourceName: string]: { content: string } };",
      "doc": "",
      "tags": []
    },
    {
      "name": "getInputFromCompilationJob.settings",
      "kind": "PropertySignature",
      "signature": "settings: {\n    viaIR?: boolean;\n    optimizer: {\n      runs?: number;\n      enabled?: boolean;\n      details?: {\n        yulDetails: {\n          optimizerSteps: string;\n        };\n      };\n    };\n    metadata?: { useLiteralContent: boolean };\n    outputSelection: {\n      [sourceName: string]: {\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "getSubprocessTransport",
      "kind": "FunctionDeclaration",
      "signature": "export function getSubprocessTransport(): any {\n  const { Status, Transports } = require(\"@sentry/node\");\n\n  class SubprocessTransport extends Transports.BaseTransport {\n    public async sendEvent(event: Event): Promise<Response> {\n      const extra: { verbose?: boolean; configPath?: string } =\n    ",
      "doc": "",
      "tags": []
    },
    {
      "name": "SENTRY_DSN",
      "kind": "VariableDeclaration",
      "signature": "SENTRY_DSN =\n  \"https://38ba58bb85fa409e9bb7f50d2c419bc2@o385026.ingest.sentry.io/5224869\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Reporter",
      "kind": "ClassDeclaration",
      "signature": "export class Reporter {\n  public static reportError(error: Error) {\n    const instance = Reporter._getInstance();\n\n    if (!instance.enabled) {\n      return;\n    }\n\n    if (!Reporter.shouldReport(error)) {\n      return;\n    }\n\n    instance.init();\n\n    const Sentry = require(\"@sentry/node\");\n    Sen",
      "doc": "This class acts as a global singleton for reporting errors through Sentry.",
      "tags": []
    },
    {
      "name": "Anonymizer",
      "kind": "ClassDeclaration",
      "signature": "export class Anonymizer {\n  constructor(private _configPath?: string) {}\n\n  /**\n   * Given a sentry serialized exception\n   * (https://develop.sentry.dev/sdk/event-payloads/exception/), return an\n   * anonymized version of the event.\n   */\n  public anonymize(event: any): either.Either<string, Event>",
      "doc": "",
      "tags": []
    },
    {
      "name": "SourceReference",
      "kind": "InterfaceDeclaration",
      "signature": "export interface SourceReference {\n  sourceName: string\n  sourceContent: string\n  contract?: string\n  function?: string\n  line: number\n  range: Array<number>\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "StackTraceEntryType",
      "kind": "BindingElement",
      "signature": "StackTraceEntryType",
      "doc": "",
      "tags": []
    },
    {
      "name": "stackTraceEntryTypeToString",
      "kind": "BindingElement",
      "signature": "stackTraceEntryTypeToString",
      "doc": "",
      "tags": []
    },
    {
      "name": "FALLBACK_FUNCTION_NAME",
      "kind": "BindingElement",
      "signature": "FALLBACK_FUNCTION_NAME",
      "doc": "",
      "tags": []
    },
    {
      "name": "RECEIVE_FUNCTION_NAME",
      "kind": "BindingElement",
      "signature": "RECEIVE_FUNCTION_NAME",
      "doc": "",
      "tags": []
    },
    {
      "name": "CONSTRUCTOR_FUNCTION_NAME",
      "kind": "BindingElement",
      "signature": "CONSTRUCTOR_FUNCTION_NAME",
      "doc": "",
      "tags": []
    },
    {
      "name": "UNRECOGNIZED_FUNCTION_NAME",
      "kind": "BindingElement",
      "signature": "UNRECOGNIZED_FUNCTION_NAME",
      "doc": "",
      "tags": []
    },
    {
      "name": "UNKNOWN_FUNCTION_NAME",
      "kind": "BindingElement",
      "signature": "UNKNOWN_FUNCTION_NAME",
      "doc": "",
      "tags": []
    },
    {
      "name": "PRECOMPILE_FUNCTION_NAME",
      "kind": "BindingElement",
      "signature": "PRECOMPILE_FUNCTION_NAME",
      "doc": "",
      "tags": []
    },
    {
      "name": "UNRECOGNIZED_CONTRACT_NAME",
      "kind": "BindingElement",
      "signature": "UNRECOGNIZED_CONTRACT_NAME",
      "doc": "",
      "tags": []
    },
    {
      "name": "CallstackEntryStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CallstackEntryStackTraceEntry {\n  type: StackTraceEntryType.CALLSTACK_ENTRY\n  sourceReference: SourceReference\n  functionType: ContractFunctionType\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "UnrecognizedCreateCallstackEntryStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnrecognizedCreateCallstackEntryStackTraceEntry {\n  type: StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY\n  sourceReference?: undefined\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "UnrecognizedContractCallstackEntryStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnrecognizedContractCallstackEntryStackTraceEntry {\n  type: StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY\n  address: Uint8Array\n  sourceReference?: undefined\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "PrecompileErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PrecompileErrorStackTraceEntry {\n  type: StackTraceEntryType.PRECOMPILE_ERROR\n  precompile: number\n  sourceReference?: undefined\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RevertErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RevertErrorStackTraceEntry {\n  type: StackTraceEntryType.REVERT_ERROR\n  returnData: Uint8Array\n  sourceReference: SourceReference\n  isInvalidOpcodeError: boolean\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "PanicErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface PanicErrorStackTraceEntry {\n  type: StackTraceEntryType.PANIC_ERROR\n  errorCode: bigint\n  sourceReference?: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CustomErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CustomErrorStackTraceEntry {\n  type: StackTraceEntryType.CUSTOM_ERROR\n  message: string\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "FunctionNotPayableErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FunctionNotPayableErrorStackTraceEntry {\n  type: StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR\n  value: bigint\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InvalidParamsErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InvalidParamsErrorStackTraceEntry {\n  type: StackTraceEntryType.INVALID_PARAMS_ERROR\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "FallbackNotPayableErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FallbackNotPayableErrorStackTraceEntry {\n  type: StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR\n  value: bigint\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "FallbackNotPayableAndNoReceiveErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface FallbackNotPayableAndNoReceiveErrorStackTraceEntry {\n  type: StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR\n  value: bigint\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "UnrecognizedFunctionWithoutFallbackErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnrecognizedFunctionWithoutFallbackErrorStackTraceEntry {\n  type: StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MissingFallbackOrReceiveErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MissingFallbackOrReceiveErrorStackTraceEntry {\n  type: StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ReturndataSizeErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ReturndataSizeErrorStackTraceEntry {\n  type: StackTraceEntryType.RETURNDATA_SIZE_ERROR\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "NonContractAccountCalledErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface NonContractAccountCalledErrorStackTraceEntry {\n  type: StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CallFailedErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CallFailedErrorStackTraceEntry {\n  type: StackTraceEntryType.CALL_FAILED_ERROR\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "DirectLibraryCallErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface DirectLibraryCallErrorStackTraceEntry {\n  type: StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "UnrecognizedCreateErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnrecognizedCreateErrorStackTraceEntry {\n  type: StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR\n  returnData: Uint8Array\n  sourceReference?: undefined\n  isInvalidOpcodeError: boolean\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "UnrecognizedContractErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnrecognizedContractErrorStackTraceEntry {\n  type: StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR\n  address: Uint8Array\n  returnData: Uint8Array\n  sourceReference?: undefined\n  isInvalidOpcodeError: boolean\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "OtherExecutionErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface OtherExecutionErrorStackTraceEntry {\n  type: StackTraceEntryType.OTHER_EXECUTION_ERROR\n  sourceReference?: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "UnmappedSolc063RevertErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface UnmappedSolc063RevertErrorStackTraceEntry {\n  type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n  sourceReference?: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ContractTooLargeErrorStackTraceEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractTooLargeErrorStackTraceEntry {\n  type: StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR\n  sourceReference?: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InternalFunctionCallStackEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface InternalFunctionCallStackEntry {\n  type: StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY\n  pc: number\n  sourceReference: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ContractCallRunOutOfGasError",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ContractCallRunOutOfGasError {\n  type: StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR\n  sourceReference?: SourceReference\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolidityStackTraceEntry",
      "kind": "TypeAliasDeclaration",
      "signature": "export type SolidityStackTraceEntry =\n  | CallstackEntryStackTraceEntry\n  | UnrecognizedCreateCallstackEntryStackTraceEntry\n  | UnrecognizedContractCallstackEntryStackTraceEntry\n  | PrecompileErrorStackTraceEntry\n  | RevertErrorStackTraceEntry\n  | PanicErrorStackTraceEntry\n  | CustomErrorStackTraceE",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolidityStackTrace",
      "kind": "TypeAliasDeclaration",
      "signature": "export type SolidityStackTrace = SolidityStackTraceEntry[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack",
      "kind": "FunctionDeclaration",
      "signature": "export function getCurrentStack(): NodeJS.CallSite[] {\n  const previousPrepareStackTrace = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = (e, s) => s;\n\n  const error = new Error();\n  const stack: NodeJS.CallSite[] = error.stack as any;\n\n  Error.prepareStackTrace = previousPrepareStackTrace;\n\n",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack._URI",
      "kind": "PropertySignature",
      "signature": "_URI: URI;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "getCurrentStack._A",
      "kind": "PropertySignature",
      "signature": "_A: T;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "getCurrentStack.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentStack.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "wrapWithSolidityErrorsCorrection",
      "kind": "FunctionDeclaration",
      "signature": "export async function wrapWithSolidityErrorsCorrection(\n  f: () => Promise<any>,\n  stackFramesToRemove: number\n) {\n  const stackTraceAtCall = getCurrentStack().slice(stackFramesToRemove);\n\n  try {\n    return await f();\n  } catch (error: any) {\n    if (error.stackTrace === undefined) {\n      // eslin",
      "doc": "",
      "tags": []
    },
    {
      "name": "wrapWithSolidityErrorsCorrection.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "wrapWithSolidityErrorsCorrection.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "wrapWithSolidityErrorsCorrection.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "wrapWithSolidityErrorsCorrection.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeSolidityStackTrace",
      "kind": "FunctionDeclaration",
      "signature": "export function encodeSolidityStackTrace(\n  fallbackMessage: string,\n  stackTrace: SolidityStackTrace,\n  previousStack?: NodeJS.CallSite[]\n): SolidityError {\n  if (Error.prepareStackTrace === undefined) {\n    // Node 12 doesn't have a default Error.prepareStackTrace\n    require(\"source-map-support/r",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeSolidityStackTrace.stackTrace",
      "kind": "PropertyDeclaration",
      "signature": "public readonly stackTrace: SolidityStackTrace;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeSolidityStackTrace.inspect",
      "kind": "MethodDeclaration",
      "signature": "public inspect(): string {\n    return this.stack !== undefined\n      ? this.stack\n      : \"Internal error when encoding SolidityError\";\n  }",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeSolidityStackTrace.__@inspect@543",
      "kind": "MethodDeclaration",
      "signature": "public [inspect](): string {\n    return this.inspect();\n  }",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeSolidityStackTrace.name",
      "kind": "PropertySignature",
      "signature": "name:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeSolidityStackTrace.message",
      "kind": "PropertySignature",
      "signature": "message:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeSolidityStackTrace.stack",
      "kind": "PropertySignature",
      "signature": "stack?:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "encodeSolidityStackTrace.cause",
      "kind": "PropertySignature",
      "signature": "cause?:unknown;",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolidityError",
      "kind": "ClassDeclaration",
      "signature": "export class SolidityError extends Error {\n  public readonly stackTrace: SolidityStackTrace;\n\n  constructor(message: string, stackTrace: SolidityStackTrace) {\n    super(message);\n    this.stackTrace = stackTrace;\n  }\n\n  public [inspect](): string {\n    return this.inspect();\n  }\n\n  public inspect():",
      "doc": "",
      "tags": []
    },
    {
      "name": "panicErrorCodeToMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function panicErrorCodeToMessage(errorCode: bigint): string {\n  const reason = panicErrorCodeToReason(errorCode);\n\n  if (reason !== undefined) {\n    return `reverted with panic code 0x${errorCode.toString(16)} (${reason})`;\n  }\n\n  return `reverted with unknown panic code 0x${errorCode.toStrin",
      "doc": "",
      "tags": []
    },
    {
      "name": "Int256Ty",
      "kind": "VariableDeclaration",
      "signature": "Int256Ty = \"Int256\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Uint256Ty",
      "kind": "VariableDeclaration",
      "signature": "Uint256Ty = \"Uint256\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "StringTy",
      "kind": "VariableDeclaration",
      "signature": "StringTy = \"String\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "BoolTy",
      "kind": "VariableDeclaration",
      "signature": "BoolTy = \"Bool\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "AddressTy",
      "kind": "VariableDeclaration",
      "signature": "AddressTy = \"Address\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "BytesTy",
      "kind": "VariableDeclaration",
      "signature": "BytesTy = \"Bytes\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes1Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes1Ty = \"Bytes1\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes2Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes2Ty = \"Bytes2\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes3Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes3Ty = \"Bytes3\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes4Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes4Ty = \"Bytes4\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes5Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes5Ty = \"Bytes5\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes6Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes6Ty = \"Bytes6\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes7Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes7Ty = \"Bytes7\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes8Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes8Ty = \"Bytes8\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes9Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes9Ty = \"Bytes9\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes10Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes10Ty = \"Bytes10\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes11Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes11Ty = \"Bytes11\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes12Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes12Ty = \"Bytes12\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes13Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes13Ty = \"Bytes13\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes14Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes14Ty = \"Bytes14\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes15Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes15Ty = \"Bytes15\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes16Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes16Ty = \"Bytes16\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes17Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes17Ty = \"Bytes17\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes18Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes18Ty = \"Bytes18\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes19Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes19Ty = \"Bytes19\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes20Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes20Ty = \"Bytes20\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes21Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes21Ty = \"Bytes21\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes22Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes22Ty = \"Bytes22\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes23Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes23Ty = \"Bytes23\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes24Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes24Ty = \"Bytes24\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes25Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes25Ty = \"Bytes25\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes26Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes26Ty = \"Bytes26\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes27Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes27Ty = \"Bytes27\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes28Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes28Ty = \"Bytes28\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes29Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes29Ty = \"Bytes29\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes30Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes30Ty = \"Bytes30\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes31Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes31Ty = \"Bytes31\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "Bytes32Ty",
      "kind": "VariableDeclaration",
      "signature": "Bytes32Ty = \"Bytes32\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "CONSOLE_LOG_SIGNATURES",
      "kind": "VariableDeclaration",
      "signature": "CONSOLE_LOG_SIGNATURES: Record<number, string[]> = {\n  0x51973ec9: [],\n  0x2d5b6cb9: [Int256Ty],\n  0xf82c50f1: [Uint256Ty],\n  0x41304fac: [StringTy],\n  0x32458eed: [BoolTy],\n  0x2c2ecbc2: [AddressTy],\n  0x0be77f56: [BytesTy],\n  0x6e18a128: [Bytes1Ty],\n  0xe9b62296: [Bytes2Ty],\n  0x2d834926: [Bytes3T",
      "doc": "",
      "tags": []
    },
    {
      "name": "linkHexStringBytecode",
      "kind": "BindingElement",
      "signature": "linkHexStringBytecode",
      "doc": "",
      "tags": []
    },
    {
      "name": "SUPPORTED_SOLIDITY_VERSION_RANGE",
      "kind": "VariableDeclaration",
      "signature": "SUPPORTED_SOLIDITY_VERSION_RANGE = \"<=0.8.28\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "ConsoleLogArgs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ConsoleLogArgs = string[];",
      "doc": "The decoded string representation of the arguments supplied to console.log",
      "tags": []
    },
    {
      "name": "ConsoleLogs",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ConsoleLogs = ConsoleLogArgs[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "ConsoleLogger",
      "kind": "ClassDeclaration",
      "signature": "export class ConsoleLogger {\n  /**\n   * Temporary code to print console.sol messages that come from EDR\n   */\n  public static getDecodedLogs(messages: Buffer[]): string[] {\n    const logs: string[] = [];\n\n    for (const message of messages) {\n      const log = ConsoleLogger._maybeConsoleLog(message)",
      "doc": "",
      "tags": []
    },
    {
      "name": "ReturnData",
      "kind": "BindingElement",
      "signature": "ReturnData",
      "doc": "",
      "tags": []
    },
    {
      "name": "getGlobalEdrContext",
      "kind": "FunctionDeclaration",
      "signature": "export function getGlobalEdrContext(): EdrContext {\n  const { EdrContext } = requireNapiRsModule(\n    \"@nomicfoundation/edr\"\n  ) as typeof import(\"@nomicfoundation/edr\");\n\n  if (_globalEdrContext === undefined) {\n    // Only one is allowed to exist\n    _globalEdrContext = new EdrContext();\n  }\n\n  re",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHardhatNetworkProvider",
      "kind": "FunctionDeclaration",
      "signature": "export async function createHardhatNetworkProvider(\n  hardhatNetworkProviderConfig: HardhatNetworkProviderConfig,\n  loggerConfig: LoggerConfig,\n  artifacts?: Artifacts\n): Promise<EIP1193Provider> {\n  log(\"Making tracing config\");\n  const tracingConfig = await makeTracingConfig(artifacts);\n  log(\"Cre",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHardhatNetworkProvider.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHardhatNetworkProvider.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHardhatNetworkProvider.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createHardhatNetworkProvider.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "DEFAULT_COINBASE",
      "kind": "VariableDeclaration",
      "signature": "DEFAULT_COINBASE = \"0xc014ba5ec014ba5ec014ba5ec014ba5ec014ba5e\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "EdrProviderWrapper",
      "kind": "ClassDeclaration",
      "signature": "export class EdrProviderWrapper\n  extends EventEmitter\n  implements EIP1193Provider\n{\n  private _failedStackTraces = 0;\n\n  // temporarily added to make smock work with HH+EDR\n  private _callOverrideCallback?: CallOverrideCallback;\n\n  private constructor(\n    private readonly _provider: EdrProviderT,",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcBlockOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RpcBlockOutput {\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string | null;\n  logsBloom: string;\n  miner: string;\n  mixHash: string | null;\n  nonce: string | null;\n  number: string | null;\n  parentHash: string;\n  receiptsRoot: string;\n  ",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcTransactionOutput",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcTransactionOutput =\n  | LegacyRpcTransactionOutput\n  | AccessListEIP2930RpcTransactionOutput\n  | EIP1559RpcTransactionOutput\n  | EOACodeEIP7702TransactionOutput;",
      "doc": "",
      "tags": []
    },
    {
      "name": "LegacyRpcTransactionOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LegacyRpcTransactionOutput extends BaseRpcTransactionOutput {\n  gasPrice: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcAccessListOutput",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcAccessListOutput = Array<{\n  address: string;\n  storageKeys: string[];\n}>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcAuthorizationListOutput",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcAuthorizationListOutput = Array<{\n  chainId: string;\n  address: string;\n  nonce: string;\n  yParity: string;\n  r: string;\n  s: string;\n}>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "AccessListEIP2930RpcTransactionOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AccessListEIP2930RpcTransactionOutput\n  extends BaseRpcTransactionOutput {\n  gasPrice: string;\n  accessList?: RpcAccessListOutput;\n  chainId: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EIP1559RpcTransactionOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EIP1559RpcTransactionOutput extends BaseRpcTransactionOutput {\n  gasPrice: string;\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n  accessList?: RpcAccessListOutput;\n  chainId: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "EOACodeEIP7702TransactionOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface EOACodeEIP7702TransactionOutput\n  extends EIP1559RpcTransactionOutput {\n  authorizationList?: RpcAuthorizationListOutput;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcReceiptOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RpcReceiptOutput {\n  blockHash: string;\n  blockNumber: string;\n  contractAddress: string | null;\n  cumulativeGasUsed: string;\n  from: string;\n  gasUsed: string;\n  logs: RpcLogOutput[];\n  logsBloom: string;\n  to: string | null;\n  transactionHash: string;\n  transactionIndex: string;\n\n",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcLogOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RpcLogOutput {\n  address: string;\n  blockHash: string | null;\n  blockNumber: string | null;\n  data: string;\n  logIndex: string | null;\n  removed: boolean;\n  topics: string[];\n  transactionHash: string | null;\n  transactionIndex: string | null;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcStructLog",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RpcStructLog {\n  depth: number;\n  gas: number;\n  gasCost: number;\n  op: string;\n  pc: number;\n  memory?: string[];\n  stack?: string[];\n  storage?: Record<string, string>;\n  memSize?: number;\n  error?: object;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcDebugTraceOutput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RpcDebugTraceOutput {\n  failed: boolean;\n  gas: number;\n  returnValue: string;\n  structLogs: RpcStructLog[];\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcWithdrawalItem",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RpcWithdrawalItem {\n  index: string;\n  validatorIndex: string;\n  address: string;\n  amount: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ForkConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ForkConfig {\n  jsonRpcUrl: string;\n  blockNumber?: number;\n  httpHeaders?: { [name: string]: string };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "IntervalMiningConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type IntervalMiningConfig = number | [number, number];",
      "doc": "",
      "tags": []
    },
    {
      "name": "MempoolOrder",
      "kind": "TypeAliasDeclaration",
      "signature": "export type MempoolOrder = typeof HARDHAT_MEMPOOL_SUPPORTED_ORDERS[number];",
      "doc": "",
      "tags": []
    },
    {
      "name": "GenesisAccount",
      "kind": "InterfaceDeclaration",
      "signature": "export interface GenesisAccount {\n  privateKey: string;\n  balance: string | number | bigint;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinimalInterpreterStep",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinimalInterpreterStep {\n  pc: number;\n  depth: number;\n  opcode: {\n    name: string;\n  };\n  stack: bigint[];\n  memory?: Uint8Array;\n}",
      "doc": "These types are minimal versions of the values returned by ethereumjs\nin the event listeners.",
      "tags": []
    },
    {
      "name": "MinimalExecResult",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinimalExecResult {\n  success: boolean;\n  executionGasUsed: bigint;\n  contractAddress?: Address;\n  reason?: SuccessReason | ExceptionalHalt;\n  output?: Buffer;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinimalEVMResult",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinimalEVMResult {\n  execResult: MinimalExecResult;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinimalMessage",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinimalMessage {\n  to?: Address;\n  codeAddress?: Address;\n  value: bigint;\n  data: Uint8Array;\n  caller: Address;\n  gasLimit: bigint;\n  isStaticCall: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getMinimalEthereumJsVm",
      "kind": "FunctionDeclaration",
      "signature": "export function getMinimalEthereumJsVm(\n  provider: EdrProviderT\n): MinimalEthereumJsVm {\n  const minimalEthereumJsVm: MinimalEthereumJsVm = {\n    events: new MinimalEthereumJsVmEventEmitter(),\n    evm: {\n      events: new MinimalEthereumJsEvmEventEmitter(),\n    },\n    stateManager: {\n      putContr",
      "doc": "",
      "tags": []
    },
    {
      "name": "getMinimalEthereumJsVm.events",
      "kind": "PropertySignature",
      "signature": "events: AsyncEventEmitter<MinimalEthereumJsVmEvents>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getMinimalEthereumJsVm.evm",
      "kind": "PropertySignature",
      "signature": "evm: {\n    events: AsyncEventEmitter<MinimalEthereumJsEvmEvents>;\n  };",
      "doc": "",
      "tags": []
    },
    {
      "name": "getMinimalEthereumJsVm.stateManager",
      "kind": "PropertySignature",
      "signature": "stateManager: {\n    putContractCode: (address: Address, code: Buffer) => Promise<void>;\n    getContractStorage: (address: Address, slotHash: Buffer) => Promise<Buffer>;\n    putContractStorage: (\n      address: Address,\n      slotHash: Buffer,\n      slotValue: Buffer\n    ) => Promise<void>;\n  };",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinimalEthereumJsVm",
      "kind": "InterfaceDeclaration",
      "signature": "export interface MinimalEthereumJsVm {\n  events: AsyncEventEmitter<MinimalEthereumJsVmEvents>;\n  evm: {\n    events: AsyncEventEmitter<MinimalEthereumJsEvmEvents>;\n  };\n  stateManager: {\n    putContractCode: (address: Address, code: Buffer) => Promise<void>;\n    getContractStorage: (address: Address,",
      "doc": "Used by the provider to keep the `_vm` variable used by some plugins. This\ninterface only has the things used by those plugins.",
      "tags": []
    },
    {
      "name": "MinimalEthereumJsVmEventEmitter",
      "kind": "ClassDeclaration",
      "signature": "export class MinimalEthereumJsVmEventEmitter extends AsyncEventEmitter<MinimalEthereumJsVmEvents> {}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MinimalEthereumJsEvmEventEmitter",
      "kind": "ClassDeclaration",
      "signature": "export class MinimalEthereumJsEvmEventEmitter extends AsyncEventEmitter<MinimalEthereumJsEvmEvents> {}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ExitCode",
      "kind": "BindingElement",
      "signature": "ExitCode",
      "doc": "",
      "tags": []
    },
    {
      "name": "getLargestPossibleReorg",
      "kind": "FunctionDeclaration",
      "signature": "export function getLargestPossibleReorg(networkId: number): bigint | undefined {\n  // mainnet\n  if (networkId === 1) {\n    return 32n;\n  }\n\n  // Kovan\n  if (networkId === 42) {\n    return 32n;\n  }\n\n  // Goerli\n  if (networkId === 5) {\n    return 32n;\n  }\n\n  // Rinkeby\n  if (networkId === 4) {\n    re",
      "doc": "This function returns a number that should be safe to consider as the\nlargest possible reorg in a network.\n\nIf there's not such a number, or we aren't aware of it, this function\nreturns undefined.",
      "tags": []
    },
    {
      "name": "FALLBACK_MAX_REORG",
      "kind": "VariableDeclaration",
      "signature": "FALLBACK_MAX_REORG = 128n",
      "doc": "",
      "tags": []
    },
    {
      "name": "RandomBufferGenerator",
      "kind": "ClassDeclaration",
      "signature": "export class RandomBufferGenerator {\n  private constructor(private _nextValue: Uint8Array) {}\n\n  public static create(seed: string): RandomBufferGenerator {\n    const { keccak256 } = require(\"../../../util/keccak\") as typeof UtilKeccakT;\n\n    const nextValue = keccak256(Buffer.from(seed));\n\n    retu",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomHash",
      "kind": "VariableDeclaration",
      "signature": "randomHash = () => {\n  const { bytesToHex: bufferToHex } =\n    require(\"@ethereumjs/util\") as typeof EthereumjsUtilT;\n  return bufferToHex(randomHashBuffer());\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomHashBuffer",
      "kind": "VariableDeclaration",
      "signature": "randomHashBuffer = (): Uint8Array => {\n  return generator.next();\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomAddress",
      "kind": "VariableDeclaration",
      "signature": "randomAddress = () => {\n  const { Address } = require(\"@ethereumjs/util\") as typeof EthereumjsUtilT;\n  return new Address(randomAddressBuffer());\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomAddressString",
      "kind": "VariableDeclaration",
      "signature": "randomAddressString = () => {\n  const { bytesToHex: bufferToHex } =\n    require(\"@ethereumjs/util\") as typeof EthereumjsUtilT;\n  return bufferToHex(randomAddressBuffer());\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "randomAddressBuffer",
      "kind": "VariableDeclaration",
      "signature": "randomAddressBuffer = (): Uint8Array => {\n  return addressGenerator.next().slice(0, 20);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkProvider",
      "kind": "FunctionDeclaration",
      "signature": "export async function makeForkProvider(forkConfig: ForkConfig): Promise<{\n  forkProvider: HttpProvider;\n  networkId: number;\n  forkBlockNumber: bigint;\n  latestBlockNumber: bigint;\n  maxReorg: bigint;\n}> {\n  const forkProvider = new HttpProvider(\n    forkConfig.jsonRpcUrl,\n    HARDHAT_NETWORK_NAME,\n",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkProvider.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkProvider.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkProvider.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkProvider.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkClient",
      "kind": "FunctionDeclaration",
      "signature": "export async function makeForkClient(\n  forkConfig: ForkConfig,\n  forkCachePath?: string\n): Promise<{\n  forkClient: JsonRpcClient;\n  forkBlockNumber: bigint;\n  forkBlockTimestamp: number;\n  forkBlockHash: string;\n  forkBlockStateRoot: string;\n}> {\n  const {\n    forkProvider,\n    networkId,\n    forkB",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkClient.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkClient.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkClient.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeForkClient.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getLastSafeBlockNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function getLastSafeBlockNumber(\n  latestBlockNumber: bigint,\n  maxReorg: bigint\n): bigint {\n  // Design choice: if latestBlock - maxReorg results in a negative number then the latestBlock block will be used.\n  // This decision is based on the assumption that if maxReorg > latestBlock then th",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeAccount",
      "kind": "FunctionDeclaration",
      "signature": "export function makeAccount(ga: GenesisAccount) {\n  let balance: bigint;\n\n  if (typeof ga.balance === \"string\" && isHexPrefixed(ga.balance)) {\n    balance = BigInt(ga.balance);\n  } else {\n    balance = BigInt(ga.balance);\n  }\n\n  const account = Account.fromAccountData({ balance });\n  const pk = toBy",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHexPrefixed",
      "kind": "FunctionDeclaration",
      "signature": "export function isHexPrefixed(value: string) {\n  return value.toLowerCase().startsWith(\"0x\");\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getCurrentTimestamp",
      "kind": "FunctionDeclaration",
      "signature": "export function getCurrentTimestamp(): number {\n  return Math.ceil(new Date().getTime() / 1000);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "showForkRecommendationsBannerIfNecessary",
      "kind": "FunctionDeclaration",
      "signature": "export async function showForkRecommendationsBannerIfNecessary(\n  currentNetworkConfig: NetworkConfig,\n  forkCachePath: string\n) {\n  if (!(\"forking\" in currentNetworkConfig)) {\n    return;\n  }\n\n  if (currentNetworkConfig.forking?.enabled !== true) {\n    return;\n  }\n\n  if (currentNetworkConfig.forkin",
      "doc": "",
      "tags": []
    },
    {
      "name": "showForkRecommendationsBannerIfNecessary.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "showForkRecommendationsBannerIfNecessary.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "showForkRecommendationsBannerIfNecessary.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "showForkRecommendationsBannerIfNecessary.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getForkCacheDirPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getForkCacheDirPath(paths: ProjectPathsConfig): string {\n  return path.join(paths.cache, \"hardhat-network-fork\");\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumsjsHardforkToEdrSpecId",
      "kind": "FunctionDeclaration",
      "signature": "export function ethereumsjsHardforkToEdrSpecId(hardfork: HardforkName): SpecId {\n  const { SpecId } = requireNapiRsModule(\n    \"@nomicfoundation/edr\"\n  ) as typeof import(\"@nomicfoundation/edr\");\n\n  switch (hardfork) {\n    case HardforkName.FRONTIER:\n      return SpecId.Frontier;\n    case HardforkNa",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumsjsHardforkToEdrSpecId.toString",
      "kind": "MethodSignature",
      "signature": "toString(radix?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumsjsHardforkToEdrSpecId.toFixed",
      "kind": "MethodSignature",
      "signature": "toFixed(fractionDigits?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumsjsHardforkToEdrSpecId.toExponential",
      "kind": "MethodSignature",
      "signature": "toExponential(fractionDigits?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumsjsHardforkToEdrSpecId.toPrecision",
      "kind": "MethodSignature",
      "signature": "toPrecision(precision?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumsjsHardforkToEdrSpecId.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumsjsHardforkToEdrSpecId.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString(locales?:string|string[],options?:Intl.NumberFormatOptions):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork",
      "kind": "FunctionDeclaration",
      "signature": "export function edrSpecIdToEthereumHardfork(specId: SpecId): HardforkName {\n  const { SpecId } = requireNapiRsModule(\n    \"@nomicfoundation/edr\"\n  ) as typeof import(\"@nomicfoundation/edr\");\n\n  switch (specId) {\n    case SpecId.Frontier:\n      return HardforkName.FRONTIER;\n    case SpecId.Homestead:",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.charAt",
      "kind": "MethodSignature",
      "signature": "charAt(pos:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.charCodeAt",
      "kind": "MethodSignature",
      "signature": "charCodeAt(index:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.concat",
      "kind": "MethodSignature",
      "signature": "concat(...strings:string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchString:string,position?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchString:string,position?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.localeCompare",
      "kind": "MethodSignature",
      "signature": "localeCompare(that:string):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.match",
      "kind": "MethodSignature",
      "signature": "match(regexp:string|RegExp):RegExpMatchArray|null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.replace",
      "kind": "MethodSignature",
      "signature": "replace(searchValue:string|RegExp,replaceValue:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.search",
      "kind": "MethodSignature",
      "signature": "search(regexp:string|RegExp):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.split",
      "kind": "MethodSignature",
      "signature": "split(separator:string|RegExp,limit?:number):string[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.substring",
      "kind": "MethodSignature",
      "signature": "substring(start:number,end?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.toLowerCase",
      "kind": "MethodSignature",
      "signature": "toLowerCase():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.toLocaleLowerCase",
      "kind": "MethodSignature",
      "signature": "toLocaleLowerCase(locales?:string|string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.toUpperCase",
      "kind": "MethodSignature",
      "signature": "toUpperCase():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.toLocaleUpperCase",
      "kind": "MethodSignature",
      "signature": "toLocaleUpperCase(locales?:string|string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.trim",
      "kind": "MethodSignature",
      "signature": "trim():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.substr",
      "kind": "MethodSignature",
      "signature": "substr(from:number,length?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.codePointAt",
      "kind": "MethodSignature",
      "signature": "codePointAt(pos:number):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchString:string,position?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.endsWith",
      "kind": "MethodSignature",
      "signature": "endsWith(searchString:string,endPosition?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.normalize",
      "kind": "MethodSignature",
      "signature": "normalize(form:\"NFC\"|\"NFD\"|\"NFKC\"|\"NFKD\"):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.repeat",
      "kind": "MethodSignature",
      "signature": "repeat(count:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.startsWith",
      "kind": "MethodSignature",
      "signature": "startsWith(searchString:string,position?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.anchor",
      "kind": "MethodSignature",
      "signature": "anchor(name:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.big",
      "kind": "MethodSignature",
      "signature": "big():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.blink",
      "kind": "MethodSignature",
      "signature": "blink():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.bold",
      "kind": "MethodSignature",
      "signature": "bold():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.fixed",
      "kind": "MethodSignature",
      "signature": "fixed():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.fontcolor",
      "kind": "MethodSignature",
      "signature": "fontcolor(color:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.fontsize",
      "kind": "MethodSignature",
      "signature": "fontsize(size:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.italics",
      "kind": "MethodSignature",
      "signature": "italics():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.link",
      "kind": "MethodSignature",
      "signature": "link(url:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.small",
      "kind": "MethodSignature",
      "signature": "small():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.strike",
      "kind": "MethodSignature",
      "signature": "strike():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.sub",
      "kind": "MethodSignature",
      "signature": "sub():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.sup",
      "kind": "MethodSignature",
      "signature": "sup():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.padStart",
      "kind": "MethodSignature",
      "signature": "padStart(maxLength:number,fillString?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.padEnd",
      "kind": "MethodSignature",
      "signature": "padEnd(maxLength:number,fillString?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.trimEnd",
      "kind": "MethodSignature",
      "signature": "trimEnd():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.trimStart",
      "kind": "MethodSignature",
      "signature": "trimStart():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.trimLeft",
      "kind": "MethodSignature",
      "signature": "trimLeft():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.trimRight",
      "kind": "MethodSignature",
      "signature": "trimRight():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.matchAll",
      "kind": "MethodSignature",
      "signature": "matchAll(regexp:RegExp):RegExpStringIterator<RegExpExecArray>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.replaceAll",
      "kind": "MethodSignature",
      "signature": "replaceAll(searchValue:string|RegExp,replaceValue:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):string|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.isWellFormed",
      "kind": "MethodSignature",
      "signature": "isWellFormed():boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.toWellFormed",
      "kind": "MethodSignature",
      "signature": "toWellFormed():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrSpecIdToEthereumHardfork.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():StringIterator<string>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsIntervalMiningConfigToEdr",
      "kind": "FunctionDeclaration",
      "signature": "export function ethereumjsIntervalMiningConfigToEdr(\n  config: IntervalMiningConfig\n): bigint | IntervalRange | undefined {\n  if (typeof config === \"number\") {\n    // Is interval mining disabled?\n    if (config === 0) {\n      return undefined;\n    } else {\n      return BigInt(config);\n    }\n  } else",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering",
      "kind": "FunctionDeclaration",
      "signature": "export function ethereumjsMempoolOrderToEdrMineOrdering(\n  mempoolOrder: MempoolOrder\n): MineOrdering {\n  const { MineOrdering } = requireNapiRsModule(\n    \"@nomicfoundation/edr\"\n  ) as typeof import(\"@nomicfoundation/edr\");\n\n  switch (mempoolOrder) {\n    case \"fifo\":\n      return MineOrdering.Fifo;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.charAt",
      "kind": "MethodSignature",
      "signature": "charAt(pos:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.charCodeAt",
      "kind": "MethodSignature",
      "signature": "charCodeAt(index:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.concat",
      "kind": "MethodSignature",
      "signature": "concat(...strings:string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchString:string,position?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchString:string,position?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.localeCompare",
      "kind": "MethodSignature",
      "signature": "localeCompare(that:string):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.match",
      "kind": "MethodSignature",
      "signature": "match(regexp:string|RegExp):RegExpMatchArray|null;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.replace",
      "kind": "MethodSignature",
      "signature": "replace(searchValue:string|RegExp,replaceValue:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.search",
      "kind": "MethodSignature",
      "signature": "search(regexp:string|RegExp):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.split",
      "kind": "MethodSignature",
      "signature": "split(separator:string|RegExp,limit?:number):string[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.substring",
      "kind": "MethodSignature",
      "signature": "substring(start:number,end?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.toLowerCase",
      "kind": "MethodSignature",
      "signature": "toLowerCase():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.toLocaleLowerCase",
      "kind": "MethodSignature",
      "signature": "toLocaleLowerCase(locales?:string|string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.toUpperCase",
      "kind": "MethodSignature",
      "signature": "toUpperCase():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.toLocaleUpperCase",
      "kind": "MethodSignature",
      "signature": "toLocaleUpperCase(locales?:string|string[]):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.trim",
      "kind": "MethodSignature",
      "signature": "trim():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.substr",
      "kind": "MethodSignature",
      "signature": "substr(from:number,length?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.codePointAt",
      "kind": "MethodSignature",
      "signature": "codePointAt(pos:number):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchString:string,position?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.endsWith",
      "kind": "MethodSignature",
      "signature": "endsWith(searchString:string,endPosition?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.normalize",
      "kind": "MethodSignature",
      "signature": "normalize(form:\"NFC\"|\"NFD\"|\"NFKC\"|\"NFKD\"):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.repeat",
      "kind": "MethodSignature",
      "signature": "repeat(count:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.startsWith",
      "kind": "MethodSignature",
      "signature": "startsWith(searchString:string,position?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.anchor",
      "kind": "MethodSignature",
      "signature": "anchor(name:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.big",
      "kind": "MethodSignature",
      "signature": "big():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.blink",
      "kind": "MethodSignature",
      "signature": "blink():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.bold",
      "kind": "MethodSignature",
      "signature": "bold():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.fixed",
      "kind": "MethodSignature",
      "signature": "fixed():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.fontcolor",
      "kind": "MethodSignature",
      "signature": "fontcolor(color:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.fontsize",
      "kind": "MethodSignature",
      "signature": "fontsize(size:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.italics",
      "kind": "MethodSignature",
      "signature": "italics():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.link",
      "kind": "MethodSignature",
      "signature": "link(url:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.small",
      "kind": "MethodSignature",
      "signature": "small():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.strike",
      "kind": "MethodSignature",
      "signature": "strike():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.sub",
      "kind": "MethodSignature",
      "signature": "sub():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.sup",
      "kind": "MethodSignature",
      "signature": "sup():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.padStart",
      "kind": "MethodSignature",
      "signature": "padStart(maxLength:number,fillString?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.padEnd",
      "kind": "MethodSignature",
      "signature": "padEnd(maxLength:number,fillString?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.trimEnd",
      "kind": "MethodSignature",
      "signature": "trimEnd():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.trimStart",
      "kind": "MethodSignature",
      "signature": "trimStart():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.trimLeft",
      "kind": "MethodSignature",
      "signature": "trimLeft():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.trimRight",
      "kind": "MethodSignature",
      "signature": "trimRight():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.matchAll",
      "kind": "MethodSignature",
      "signature": "matchAll(regexp:RegExp):RegExpStringIterator<RegExpExecArray>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.replaceAll",
      "kind": "MethodSignature",
      "signature": "replaceAll(searchValue:string|RegExp,replaceValue:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):string|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.isWellFormed",
      "kind": "MethodSignature",
      "signature": "isWellFormed():boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.toWellFormed",
      "kind": "MethodSignature",
      "signature": "toWellFormed():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "ethereumjsMempoolOrderToEdrMineOrdering.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():StringIterator<string>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrRpcDebugTraceToHardhat",
      "kind": "FunctionDeclaration",
      "signature": "export function edrRpcDebugTraceToHardhat(\n  rpcDebugTrace: DebugTraceResult\n): RpcDebugTraceOutput {\n  const structLogs = rpcDebugTrace.structLogs.map((log) => {\n    const result: RpcStructLog = {\n      depth: Number(log.depth),\n      gas: Number(log.gas),\n      gasCost: Number(log.gasCost),\n      ",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrRpcDebugTraceToHardhat.failed",
      "kind": "PropertySignature",
      "signature": "failed: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrRpcDebugTraceToHardhat.gas",
      "kind": "PropertySignature",
      "signature": "gas: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrRpcDebugTraceToHardhat.returnValue",
      "kind": "PropertySignature",
      "signature": "returnValue: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrRpcDebugTraceToHardhat.structLogs",
      "kind": "PropertySignature",
      "signature": "structLogs: RpcStructLog[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingStepToMinimalInterpreterStep",
      "kind": "FunctionDeclaration",
      "signature": "export function edrTracingStepToMinimalInterpreterStep(\n  step: TracingStep\n): MinimalInterpreterStep {\n  const minimalInterpreterStep: MinimalInterpreterStep = {\n    pc: Number(step.pc),\n    depth: step.depth,\n    opcode: {\n      name: step.opcode,\n    },\n    stack: step.stack,\n  };\n\n  if (step.mem",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingStepToMinimalInterpreterStep.pc",
      "kind": "PropertySignature",
      "signature": "pc: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingStepToMinimalInterpreterStep.depth",
      "kind": "PropertySignature",
      "signature": "depth: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingStepToMinimalInterpreterStep.opcode",
      "kind": "PropertySignature",
      "signature": "opcode: {\n    name: string;\n  };",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingStepToMinimalInterpreterStep.stack",
      "kind": "PropertySignature",
      "signature": "stack: bigint[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingStepToMinimalInterpreterStep.memory",
      "kind": "PropertySignature",
      "signature": "memory?: Uint8Array;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageResultToMinimalEVMResult",
      "kind": "FunctionDeclaration",
      "signature": "export function edrTracingMessageResultToMinimalEVMResult(\n  tracingMessageResult: TracingMessageResult\n): MinimalEVMResult {\n  const { result, contractAddress } = tracingMessageResult.executionResult;\n\n  // only SuccessResult has logs\n  const success = \"logs\" in result;\n\n  const minimalEVMResult: M",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageResultToMinimalEVMResult.execResult",
      "kind": "PropertySignature",
      "signature": "execResult: MinimalExecResult;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageToMinimalMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function edrTracingMessageToMinimalMessage(\n  message: TracingMessage\n): MinimalMessage {\n  return {\n    to: message.to !== undefined ? new Address(message.to) : undefined,\n    codeAddress:\n      message.codeAddress !== undefined\n        ? new Address(message.codeAddress)\n        : undefined,",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageToMinimalMessage.to",
      "kind": "PropertySignature",
      "signature": "to?: Address;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageToMinimalMessage.codeAddress",
      "kind": "PropertySignature",
      "signature": "codeAddress?: Address;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageToMinimalMessage.value",
      "kind": "PropertySignature",
      "signature": "value: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageToMinimalMessage.data",
      "kind": "PropertySignature",
      "signature": "data: Uint8Array;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageToMinimalMessage.caller",
      "kind": "PropertySignature",
      "signature": "caller: Address;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageToMinimalMessage.gasLimit",
      "kind": "PropertySignature",
      "signature": "gasLimit: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "edrTracingMessageToMinimalMessage.isStaticCall",
      "kind": "PropertySignature",
      "signature": "isStaticCall: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "assertHardhatNetworkInvariant",
      "kind": "FunctionDeclaration",
      "signature": "export function assertHardhatNetworkInvariant(\n  invariant: boolean,\n  description: string\n): asserts invariant {\n  if (!invariant) {\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw new InternalError(\n      `Internal Hardhat Network invariant was ",
      "doc": "",
      "tags": []
    },
    {
      "name": "printLine",
      "kind": "FunctionDeclaration",
      "signature": "export function printLine(line: string) {\n  console.log(line);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "replaceLastLine",
      "kind": "FunctionDeclaration",
      "signature": "export function replaceLastLine(newLine: string) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write(\n      // eslint-disable-next-line prefer-template\n      ansiEscapes.cursorHide +\n        ansiEscapes.cursorPrevLine +\n        newLine +\n        ansiEscapes.eraseEndLine +\n        \"\\n\" ",
      "doc": "",
      "tags": []
    },
    {
      "name": "LoggerConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface LoggerConfig {\n  enabled: boolean;\n  printLineFn?: (line: string) => void;\n  replaceLastLineFn?: (line: string) => void;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "AccountState",
      "kind": "InterfaceDeclaration",
      "signature": "export interface AccountState {\n  nonce: string | undefined;\n  balance: string | undefined;\n  // a null value means that the slot was set to 0 (i.e. deleted)\n  storage: ImmutableMap<string, string | null>;\n  code: string | undefined;\n  storageCleared: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeAccountState",
      "kind": "VariableDeclaration",
      "signature": "makeAccountState = ImmutableRecord<AccountState>({\n  nonce: undefined,\n  balance: undefined,\n  storage: ImmutableMap<string, string | null>(),\n  code: undefined,\n  storageCleared: false,\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "makeEmptyAccountState",
      "kind": "VariableDeclaration",
      "signature": "makeEmptyAccountState = ImmutableRecord<AccountState>({\n  nonce: \"0x0\",\n  balance: \"0x0\",\n  storage: ImmutableMap<string, string | null>(),\n  code: \"0x\",\n  storageCleared: true,\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcServerConfig",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcServerConfig {\n  hostname: string;\n  port: number;\n\n  provider: EIP1193Provider;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcServer",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcServer implements IJsonRpcServer {\n  private _config: JsonRpcServerConfig;\n  private _httpServer: Server;\n  private _wsServer: WsT.Server;\n\n  constructor(config: JsonRpcServerConfig) {\n    const { Server: WSServer } = require(\"ws\") as typeof WsT;\n\n    this._config = config;\n\n    ",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcHandler",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcHandler {\n  constructor(private readonly _provider: EIP1193Provider) {}\n\n  public handleHttp = async (req: IncomingMessage, res: ServerResponse) => {\n    this._setCorsHeaders(res);\n    if (req.method === \"OPTIONS\") {\n      this._sendEmptyResponse(res);\n      return;\n    }\n\n    le",
      "doc": "",
      "tags": []
    },
    {
      "name": "JsonRpcClient",
      "kind": "ClassDeclaration",
      "signature": "export class JsonRpcClient {\n  private _cache: Map<string, any> = new Map();\n\n  constructor(\n    private _httpProvider: HttpProvider,\n    private _networkId: number,\n    private _latestBlockNumberOnCreation: bigint,\n    private _maxReorg: bigint,\n    private _forkCachePath?: string\n  ) {}\n\n  public ",
      "doc": "",
      "tags": []
    },
    {
      "name": "willRunWithTypescript",
      "kind": "FunctionDeclaration",
      "signature": "export function willRunWithTypescript(configPath?: string): boolean {\n  const config = resolveConfigPath(configPath);\n  return isNonEsmTypescriptFile(config);\n}",
      "doc": "Returns true if Hardhat will run in using typescript mode.",
      "tags": [
        {
          "tagName": "param",
          "text": "The config path if provider by the user."
        }
      ]
    },
    {
      "name": "isRunningWithTypescript",
      "kind": "FunctionDeclaration",
      "signature": "export function isRunningWithTypescript(config: HardhatConfig): boolean {\n  return isNonEsmTypescriptFile(config.paths.configFile);\n}",
      "doc": "Returns true if a Hardhat is already running with typescript.",
      "tags": []
    },
    {
      "name": "isTypescriptSupported",
      "kind": "FunctionDeclaration",
      "signature": "export function isTypescriptSupported() {\n  if (cachedIsTypescriptSupported === undefined) {\n    try {\n      // We resolve these from Hardhat's installation.\n      require.resolve(\"typescript\");\n      require.resolve(\"ts-node\");\n      cachedIsTypescriptSupported = true;\n    } catch {\n      cachedIsT",
      "doc": "",
      "tags": []
    },
    {
      "name": "loadTsNode",
      "kind": "FunctionDeclaration",
      "signature": "export function loadTsNode(\n  tsConfigPath?: string,\n  shouldTypecheck: boolean = false\n) {\n  try {\n    require.resolve(\"typescript\");\n  } catch {\n    throw new HardhatError(ERRORS.GENERAL.TYPESCRIPT_NOT_INSTALLED);\n  }\n\n  try {\n    require.resolve(\"ts-node\");\n  } catch {\n    throw new HardhatError(",
      "doc": "",
      "tags": []
    },
    {
      "name": "isTypescriptFile",
      "kind": "FunctionDeclaration",
      "signature": "export function isTypescriptFile(path: string): boolean {\n  return /\\.(ts|cts|mts)$/i.test(path);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "isJavascriptFile",
      "kind": "FunctionDeclaration",
      "signature": "export function isJavascriptFile(path: string): boolean {\n  return /\\.(js|cjs|mjs)$/i.test(path);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "createTaskProfile",
      "kind": "FunctionDeclaration",
      "signature": "export function createTaskProfile(name: string): TaskProfile {\n  return {\n    name,\n    start: process.hrtime.bigint(),\n    children: [],\n  };\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "createTaskProfile.name",
      "kind": "PropertySignature",
      "signature": "name: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createTaskProfile.start",
      "kind": "PropertySignature",
      "signature": "start: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createTaskProfile.end",
      "kind": "PropertySignature",
      "signature": "end?: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createTaskProfile.children",
      "kind": "PropertySignature",
      "signature": "children: TaskProfile[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "createTaskProfile.parallel",
      "kind": "PropertySignature",
      "signature": "parallel?: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "completeTaskProfile",
      "kind": "FunctionDeclaration",
      "signature": "export function completeTaskProfile(taskProfile: TaskProfile) {\n  taskProfile.end = process.hrtime.bigint();\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "createParentTaskProfile",
      "kind": "FunctionDeclaration",
      "signature": "export function createParentTaskProfile(taskProfile: TaskProfile): TaskProfile {\n  return createTaskProfile(`super::${taskProfile.name}`);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "createParentTaskProfile.name",
      "kind": "PropertySignature",
      "signature": "name: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createParentTaskProfile.start",
      "kind": "PropertySignature",
      "signature": "start: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createParentTaskProfile.end",
      "kind": "PropertySignature",
      "signature": "end?: bigint;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createParentTaskProfile.children",
      "kind": "PropertySignature",
      "signature": "children: TaskProfile[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "createParentTaskProfile.parallel",
      "kind": "PropertySignature",
      "signature": "parallel?: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "flagParallelChildren",
      "kind": "FunctionDeclaration",
      "signature": "export function flagParallelChildren(\n  profile: TaskProfile,\n  isParentParallel = false\n) {\n  if (isParentParallel) {\n    profile.parallel = true;\n    for (const child of profile.children) {\n      child.parallel = true;\n    }\n  } else {\n    for (const [i, child] of profile.children.entries()) {\n   ",
      "doc": "Sets `parallel` to `true` to any children that was running at the same time\nof another.\n\nWe assume `children[]` is in chronological `start` order.",
      "tags": []
    },
    {
      "name": "TaskProfile",
      "kind": "InterfaceDeclaration",
      "signature": "export interface TaskProfile {\n  name: string;\n  start: bigint;\n  end?: bigint;\n  children: TaskProfile[];\n  parallel?: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "Environment",
      "kind": "ClassDeclaration",
      "signature": "export class Environment implements HardhatRuntimeEnvironment {\n  private static readonly _BLACKLISTED_PROPERTIES: string[] = [\n    \"injectToGlobal\",\n    \"entryTaskProfile\",\n    \"_runTaskDefinition\",\n    \"_extenders\",\n  ];\n\n  public network: Network;\n\n  public artifacts: IArtifacts;\n\n  private reado",
      "doc": "",
      "tags": []
    },
    {
      "name": "isCwdInsideProject",
      "kind": "FunctionDeclaration",
      "signature": "export function isCwdInsideProject() {\n  return (\n    findUp.sync(TS_CONFIG_FILENAME) !== undefined ||\n    findUp.sync(CTS_CONFIG_FILENAME) !== undefined ||\n    findUp.sync(CJS_CONFIG_FILENAME) !== undefined ||\n    findUp.sync(JS_CONFIG_FILENAME) !== undefined\n  );\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getUserConfigPath",
      "kind": "FunctionDeclaration",
      "signature": "export function getUserConfigPath() {\n  const tsConfigPath = findUp.sync(TS_CONFIG_FILENAME);\n  if (tsConfigPath !== undefined) {\n    return tsConfigPath;\n  }\n\n  const ctsConfigPath = findUp.sync(CTS_CONFIG_FILENAME);\n  if (ctsConfigPath !== undefined) {\n    return ctsConfigPath;\n  }\n\n  const cjsCon",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRecommendedGitIgnore",
      "kind": "FunctionDeclaration",
      "signature": "export async function getRecommendedGitIgnore() {\n  const packageRoot = getPackageRoot();\n  const gitIgnorePath = path.join(packageRoot, \"recommended-gitignore.txt\");\n\n  return fsExtra.readFile(gitIgnorePath, \"utf-8\");\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRecommendedGitIgnore.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRecommendedGitIgnore.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRecommendedGitIgnore.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getRecommendedGitIgnore.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "profileToFlamegraph",
      "kind": "FunctionDeclaration",
      "signature": "export function profileToFlamegraph(profile: TaskProfile): Flamegraph {\n  assertHardhatInvariant(\n    profile.end !== undefined,\n    `Formatting invalid task profile for ${profile.name}. No end was recorded.`\n  );\n\n  return {\n    name: profile.name,\n    // We assume this is a safe int, which is ok u",
      "doc": "",
      "tags": []
    },
    {
      "name": "profileToFlamegraph.name",
      "kind": "PropertySignature",
      "signature": "name: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "profileToFlamegraph.value",
      "kind": "PropertySignature",
      "signature": "value: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "profileToFlamegraph.children",
      "kind": "PropertySignature",
      "signature": "children: Flamegraph[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "profileToFlamegraph.parallel",
      "kind": "PropertySignature",
      "signature": "parallel: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createFlamegraphHtmlFile",
      "kind": "FunctionDeclaration",
      "signature": "export function createFlamegraphHtmlFile(flamegraph: Flamegraph): string {\n  const content = getFlamegraphFileContent(foldFramegraph(flamegraph));\n  const path = \"flamegraph.html\";\n\n  fs.writeFileSync(path, content, { encoding: \"utf8\" });\n\n  return path;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "saveFlamegraph",
      "kind": "FunctionDeclaration",
      "signature": "export function saveFlamegraph(profile: TaskProfile): string {\n  flagParallelChildren(profile);\n  const flamegraph = profileToFlamegraph(profile);\n  return createFlamegraphHtmlFile(flamegraph);\n}",
      "doc": "Converts the TaskProfile into a flamegraph, saves it, and returns its path.",
      "tags": []
    },
    {
      "name": "Flamegraph",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Flamegraph {\n  name: string;\n  value: number;\n  children: Flamegraph[];\n  parallel: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHardhatInstalledLocallyOrLinked",
      "kind": "FunctionDeclaration",
      "signature": "export function isHardhatInstalledLocallyOrLinked(configPath?: string) {\n  try {\n    const resolvedPackageJson = require.resolve(\"hardhat/package.json\", {\n      paths: [configPath ?? process.cwd()],\n    });\n\n    const thisPackageJson = getPackageJsonPath();\n\n    // We need to get the realpaths here,",
      "doc": "Returns true if Hardhat is installed locally or linked from its repository,\nby looking for it using the node module resolution logic.\n\nIf a config file is provided, we start looking for it from it. Otherwise,\nwe use the current working directory.",
      "tags": []
    },
    {
      "name": "isLocalDev",
      "kind": "FunctionDeclaration",
      "signature": "export function isLocalDev(): boolean {\n  // TODO: This may give a false positive under yarn PnP\n  return isRunningHardhatCoreTests() || !__filename.includes(\"node_modules\");\n}",
      "doc": "Checks whether we're using Hardhat in development mode (that is, we're working _on_ Hardhat).",
      "tags": []
    },
    {
      "name": "isRunningHardhatCoreTests",
      "kind": "FunctionDeclaration",
      "signature": "export function isRunningHardhatCoreTests(): boolean {\n  return __filename.endsWith(\".ts\");\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "applyErrorMessageTemplate",
      "kind": "FunctionDeclaration",
      "signature": "export function applyErrorMessageTemplate(\n  template: string,\n  values: { [templateVar: string]: any }\n): string {\n  return _applyErrorMessageTemplate(template, values, false);\n}",
      "doc": "This function applies error messages templates like this:\n\n - Template is a string which contains a variable tags. A variable tag is a\n   a variable name surrounded by %. Eg: %plugin1%\n - A variable name is a string of alphanumeric ascii characters.\n - Every variable tag is replaced by its value.\n - %% is replaced by %.\n - Values can't contain variable tags.\n - If a variable is not present in the template, but present in the values\n   object, an error is thrown.",
      "tags": [
        {
          "tagName": "param",
          "text": "The template string."
        },
        {
          "tagName": "param",
          "text": "A map of variable names to their values."
        }
      ]
    },
    {
      "name": "assertHardhatInvariant",
      "kind": "FunctionDeclaration",
      "signature": "export function assertHardhatInvariant(\n  invariant: boolean,\n  message: string\n): asserts invariant {\n  if (!invariant) {\n    throw new HardhatError(ERRORS.GENERAL.ASSERTION_ERROR, { message });\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CustomError",
      "kind": "ClassDeclaration",
      "signature": "export class CustomError extends Error {\n  private _stack: string;\n\n  constructor(message: string, public readonly parent?: Error) {\n    // WARNING: Using super when extending a builtin class doesn't work well\n    // with TS if you are compiling to a version of JavaScript that doesn't have\n    // na",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatError",
      "kind": "ClassDeclaration",
      "signature": "export class HardhatError extends CustomError {\n  public static isHardhatError(other: any): other is HardhatError {\n    return (\n      other !== undefined && other !== null && other._isHardhatError === true\n    );\n  }\n\n  public static isHardhatErrorType(\n    other: any,\n    descriptor: ErrorDescript",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatPluginError",
      "kind": "ClassDeclaration",
      "signature": "export class HardhatPluginError extends CustomError {\n  public static isHardhatPluginError(other: any): other is HardhatPluginError {\n    return (\n      other !== undefined &&\n      other !== null &&\n      other._isHardhatPluginError === true\n    );\n  }\n\n  public readonly pluginName: string;\n\n  priv",
      "doc": "This class is used to throw errors from hardhat plugins made by third parties.",
      "tags": []
    },
    {
      "name": "NomicLabsHardhatPluginError",
      "kind": "ClassDeclaration",
      "signature": "export class NomicLabsHardhatPluginError extends HardhatPluginError {\n  public static isNomicLabsHardhatPluginError(\n    other: any\n  ): other is NomicLabsHardhatPluginError {\n    return (\n      other !== undefined &&\n      other !== null &&\n      other._isNomicLabsHardhatPluginError === true\n    );",
      "doc": "",
      "tags": []
    },
    {
      "name": "getErrorCode",
      "kind": "FunctionDeclaration",
      "signature": "export function getErrorCode(error: ErrorDescriptor): string {\n  return `${ERROR_PREFIX}${error.number}`;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ERROR_PREFIX",
      "kind": "VariableDeclaration",
      "signature": "ERROR_PREFIX = \"HH\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "ErrorDescriptor",
      "kind": "InterfaceDeclaration",
      "signature": "export interface ErrorDescriptor {\n  number: number;\n  // Message can use templates. See applyErrorMessageTemplate\n  message: string;\n  // Title and description can be Markdown\n  title: string;\n  description: string;\n  shouldBeReported: boolean;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "ERROR_RANGES",
      "kind": "VariableDeclaration",
      "signature": "ERROR_RANGES: {\n  [category in keyof typeof ERRORS]: {\n    min: number;\n    max: number;\n    title: string;\n  };\n} = {\n  GENERAL: { min: 1, max: 99, title: \"General errors\" },\n  NETWORK: { min: 100, max: 199, title: \"Network related errors\" },\n  TASK_DEFINITIONS: {\n    min: 200,\n    max: 299,\n    ti",
      "doc": "",
      "tags": []
    },
    {
      "name": "ERRORS",
      "kind": "VariableDeclaration",
      "signature": "ERRORS = {\n  GENERAL: {\n    NOT_INSIDE_PROJECT: {\n      number: 1,\n      message: \"You are not inside a Hardhat project.\",\n      title: \"You are not inside a Hardhat project\",\n      description: `You are trying to run Hardhat outside of a Hardhat project.\n\nYou can learn how to use Hardhat by reading",
      "doc": "",
      "tags": []
    },
    {
      "name": "VarsManager",
      "kind": "ClassDeclaration",
      "signature": "export class VarsManager {\n  private readonly _VERSION = \"hh-vars-1\";\n  private readonly _ENV_VAR_PREFIX = \"HARDHAT_VAR_\";\n  private readonly _storageCache: VarsFile;\n  private readonly _envCache: Record<string, string>;\n\n  constructor(private readonly _varsFilePath: string) {\n    log(\"Creating a ne",
      "doc": "",
      "tags": []
    },
    {
      "name": "VarsManagerSetup",
      "kind": "ClassDeclaration",
      "signature": "export class VarsManagerSetup extends VarsManager {\n  private readonly _getVarsAlreadySet: Set<string>;\n  private readonly _hasVarsAlreadySet: Set<string>;\n  private readonly _getVarsWithDefaultValueAlreadySet: Set<string>;\n\n  private readonly _getVarsToSet: Set<string>;\n  private readonly _hasVarsT",
      "doc": "This class is ONLY used when collecting the required and optional vars that have to be filled by the user",
      "tags": []
    },
    {
      "name": "parseTaskIdentifier",
      "kind": "FunctionDeclaration",
      "signature": "export function parseTaskIdentifier(taskIdentifier: TaskIdentifier): {\n  scope: string | undefined;\n  task: string;\n} {\n  if (typeof taskIdentifier === \"string\") {\n    return {\n      scope: undefined,\n      task: taskIdentifier,\n    };\n  } else {\n    return {\n      scope: taskIdentifier.scope,\n     ",
      "doc": "",
      "tags": []
    },
    {
      "name": "SimpleTaskDefinition",
      "kind": "ClassDeclaration",
      "signature": "export class SimpleTaskDefinition implements TaskDefinition {\n  public get name() {\n    return this._task;\n  }\n  public get scope() {\n    return this._scope;\n  }\n  public get description() {\n    return this._description;\n  }\n  public readonly paramDefinitions: ParamDefinitionsMap = {};\n  public read",
      "doc": "This class creates a task definition, which consists of:\n* a name, that should be unique and will be used to call the task.\n* a description. This is optional.\n* the action that the task will execute.\n* a set of parameters that can be used by the action.",
      "tags": []
    },
    {
      "name": "OverriddenTaskDefinition",
      "kind": "ClassDeclaration",
      "signature": "export class OverriddenTaskDefinition implements TaskDefinition {\n  private _description?: string;\n  private _action?: ActionType<TaskArguments>;\n\n  constructor(\n    public readonly parentTaskDefinition: TaskDefinition,\n    public readonly isSubtask: boolean = false\n  ) {\n    this.isSubtask = isSubt",
      "doc": "Allows you to override a previously defined task.\n\nWhen overriding a task you can:\n * flag it as a subtask\n * set a new description\n * set a new action",
      "tags": []
    },
    {
      "name": "SimpleScopeDefinition",
      "kind": "ClassDeclaration",
      "signature": "export class SimpleScopeDefinition implements ScopeDefinition {\n  public tasks: TasksMap = {};\n\n  constructor(\n    public readonly name: string,\n    private _description: string | undefined,\n    private _addTask: AddTaskFunction,\n    private _addSubtask: AddTaskFunction\n  ) {}\n\n  public get descript",
      "doc": "",
      "tags": []
    },
    {
      "name": "TasksDSL",
      "kind": "ClassDeclaration",
      "signature": "export class TasksDSL {\n  public readonly internalTask = this.subtask;\n\n  private readonly _tasks: TasksMap = {};\n  private readonly _scopes: ScopesMap = {};\n\n  /**\n   * Creates a task, overriding any previous task with the same name.\n   *\n   * @remarks The action must await every async call made wi",
      "doc": "This class defines the DSL used in Hardhat config files\nfor creating and overriding tasks.",
      "tags": []
    },
    {
      "name": "ProviderWrapper",
      "kind": "ClassDeclaration",
      "signature": "export abstract class ProviderWrapper\n  extends EventEmitterWrapper\n  implements EIP1193Provider\n{\n  constructor(protected readonly _wrappedProvider: EIP1193Provider) {\n    super(_wrappedProvider);\n  }\n\n  public abstract request(args: RequestArguments): Promise<unknown>;\n\n  /**\n   * Extract the para",
      "doc": "A wrapper class that makes it easy to implement the EIP1193 (Javascript Ethereum Provider) standard.\nIt comes baked in with all EventEmitter methods needed,\nwhich will be added to the provider supplied in the constructor.\nIt also provides the interface for the standard .request() method as an abstract method.",
      "tags": []
    },
    {
      "name": "derivePrivateKeys",
      "kind": "FunctionDeclaration",
      "signature": "export function derivePrivateKeys(\n  mnemonic: string,\n  hdpath: string,\n  initialIndex: number,\n  count: number,\n  passphrase: string\n): Buffer[] {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new HardhatError(ERRORS.NETWORK.INVALID_HD_PATH, { path: hdpath });\n  }\n\n  if (!hdpath.endsWith",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys._URI",
      "kind": "PropertySignature",
      "signature": "_URI: URI;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "derivePrivateKeys._A",
      "kind": "PropertySignature",
      "signature": "_A: T;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "derivePrivateKeys.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig",
      "kind": "FunctionDeclaration",
      "signature": "export function normalizeHardhatNetworkAccountsConfig(\n  accountsConfig: HardhatNetworkAccountsConfig\n): HardhatNetworkAccountConfig[] {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n\n  const { bytesToHex } = require(\"@ethereumjs/util\");\n\n  return derivePrivateKeys(\n    accou",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig._URI",
      "kind": "PropertySignature",
      "signature": "_URI: URI;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig._A",
      "kind": "PropertySignature",
      "signature": "_A: T;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeHardhatNetworkAccountsConfig.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProviderFactory",
      "kind": "TypeAliasDeclaration",
      "signature": "export type ProviderFactory = () => Promise<EthereumProvider>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "Listener",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Listener = (...args: any[]) => void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "LazyInitializationProviderAdapter",
      "kind": "ClassDeclaration",
      "signature": "export class LazyInitializationProviderAdapter implements EthereumProvider {\n  protected provider: EthereumProvider | undefined;\n  private _emitter: EventEmitter = new EventEmitter();\n  private _initializingPromise: Promise<EthereumProvider> | undefined;\n\n  constructor(private _providerFactory: Prov",
      "doc": "A class that delays the (async) creation of its internal provider until the first call\nto a JSON RPC method via request/send/sendAsync or the init method is called.",
      "tags": []
    },
    {
      "name": "isErrorResponse",
      "kind": "FunctionDeclaration",
      "signature": "export function isErrorResponse(\n  response: any\n): response is FailedJsonRpcResponse {\n  return typeof response.error !== \"undefined\";\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HttpProvider",
      "kind": "ClassDeclaration",
      "signature": "export class HttpProvider extends EventEmitter implements EIP1193Provider {\n  private _nextRequestId = 1;\n  private _dispatcher: Undici.Dispatcher;\n  private _path: string;\n  private _authHeader: string | undefined;\n\n  constructor(\n    private readonly _url: string,\n    private readonly _networkName",
      "doc": "",
      "tags": []
    },
    {
      "name": "FixedGasProvider",
      "kind": "ClassDeclaration",
      "signature": "export class FixedGasProvider extends ProviderWrapper {\n  constructor(provider: EIP1193Provider, private readonly _gasLimit: number) {\n    super(provider);\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    if (args.method === \"eth_sendTransaction\") {\n      const params = th",
      "doc": "",
      "tags": []
    },
    {
      "name": "FixedGasPriceProvider",
      "kind": "ClassDeclaration",
      "signature": "export class FixedGasPriceProvider extends ProviderWrapper {\n  constructor(provider: EIP1193Provider, private readonly _gasPrice: number) {\n    super(provider);\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    if (args.method === \"eth_sendTransaction\") {\n      const params",
      "doc": "",
      "tags": []
    },
    {
      "name": "AutomaticGasProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AutomaticGasProvider extends MultipliedGasEstimationProvider {\n  constructor(\n    provider: EIP1193Provider,\n    gasMultiplier: number = DEFAULT_GAS_MULTIPLIER\n  ) {\n    super(provider, gasMultiplier);\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    if (args.",
      "doc": "",
      "tags": []
    },
    {
      "name": "AutomaticGasPriceProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AutomaticGasPriceProvider extends ProviderWrapper {\n  // We pay the max base fee that can be required if the next\n  // EIP1559_BASE_FEE_MAX_FULL_BLOCKS_PREFERENCE are full.\n  public static readonly EIP1559_BASE_FEE_MAX_FULL_BLOCKS_PREFERENCE: bigint =\n    3n;\n\n  // See eth_feeHistory fo",
      "doc": "",
      "tags": []
    },
    {
      "name": "ProviderError",
      "kind": "ClassDeclaration",
      "signature": "export class ProviderError extends CustomError implements ProviderRpcError {\n  public static isProviderError(other: any): other is ProviderError {\n    return (\n      other !== undefined && other !== null && other._isProviderError === true\n    );\n  }\n  public code: number;\n  public data?: unknown;\n\n ",
      "doc": "",
      "tags": []
    },
    {
      "name": "InvalidJsonInputError",
      "kind": "ClassDeclaration",
      "signature": "export class InvalidJsonInputError extends ProviderError {\n  public static readonly CODE = -32700;\n\n  constructor(message: string, parent?: Error) {\n    super(message, InvalidJsonInputError.CODE, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InvalidRequestError",
      "kind": "ClassDeclaration",
      "signature": "export class InvalidRequestError extends ProviderError {\n  public static readonly CODE = -32600;\n\n  constructor(message: string, parent?: Error) {\n    super(message, InvalidRequestError.CODE, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "MethodNotFoundError",
      "kind": "ClassDeclaration",
      "signature": "export class MethodNotFoundError extends ProviderError {\n  public static readonly CODE = -32601;\n\n  constructor(message: string, parent?: Error) {\n    super(message, MethodNotFoundError.CODE, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InvalidArgumentsError",
      "kind": "ClassDeclaration",
      "signature": "export class InvalidArgumentsError extends ProviderError {\n  public static readonly CODE = -32602;\n\n  constructor(message: string, parent?: Error) {\n    super(message, InvalidArgumentsError.CODE, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InternalError",
      "kind": "ClassDeclaration",
      "signature": "export class InternalError extends ProviderError {\n  public static readonly CODE = -32603;\n\n  constructor(message: string, parent?: Error) {\n    super(message, InternalError.CODE, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InvalidInputError",
      "kind": "ClassDeclaration",
      "signature": "export class InvalidInputError extends ProviderError {\n  public static readonly CODE = -32000;\n\n  constructor(message: string, parent?: Error) {\n    super(message, InvalidInputError.CODE, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "TransactionExecutionError",
      "kind": "ClassDeclaration",
      "signature": "export class TransactionExecutionError extends ProviderError {\n  public static readonly CODE = -32003;\n\n  // TODO: This should have the transaction id\n  // TODO: Normalize this constructor\n  constructor(parentOrMsg: Error | string) {\n    if (typeof parentOrMsg === \"string\") {\n      super(parentOrMsg",
      "doc": "",
      "tags": []
    },
    {
      "name": "MethodNotSupportedError",
      "kind": "ClassDeclaration",
      "signature": "export class MethodNotSupportedError extends ProviderError {\n  public static readonly CODE = -32004;\n\n  constructor(method: string, parent?: Error) {\n    super(\n      `Method ${method} is not supported`,\n      MethodNotSupportedError.CODE,\n      parent\n    );\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InvalidResponseError",
      "kind": "ClassDeclaration",
      "signature": "export class InvalidResponseError extends ProviderError {\n  public static readonly CODE = -32999;\n\n  constructor(message: string, parent?: Error) {\n    super(message, InvalidResponseError.CODE, parent);\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHDAccountsConfig",
      "kind": "FunctionDeclaration",
      "signature": "export function isHDAccountsConfig(\n  accounts?: HttpNetworkAccountsUserConfig\n): accounts is HDAccountsUserConfig {\n  return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProvider",
      "kind": "FunctionDeclaration",
      "signature": "export async function createProvider(\n  config: HardhatConfig,\n  networkName: string,\n  artifacts?: Artifacts,\n  extenders: ProviderExtender[] = []\n): Promise<EthereumProvider> {\n  let eip1193Provider: EIP1193Provider;\n  const networkConfig = config.networks[networkName];\n  const paths = config.path",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProvider.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProvider.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProvider.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProvider.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "applyProviderWrappers",
      "kind": "FunctionDeclaration",
      "signature": "export function applyProviderWrappers(\n  provider: EIP1193Provider,\n  netConfig: Partial<NetworkConfig>,\n  extenders: ProviderExtender[]\n): EIP1193Provider {\n  // These dependencies are lazy-loaded because they are really big.\n  const LocalAccountsProvider = importProvider<\n    typeof import(\"./acco",
      "doc": "",
      "tags": []
    },
    {
      "name": "applyProviderWrappers.request",
      "kind": "MethodSignature",
      "signature": "request(args: RequestArguments): Promise<unknown>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "applyProviderWrappers.__@captureRejectionSymbol@434",
      "kind": "MethodDeclaration",
      "signature": "[EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "applyProviderWrappers.addListener",
      "kind": "MethodSignature",
      "signature": "addListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Alias for `emitter.on(eventName, listener)`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.on",
      "kind": "MethodSignature",
      "signature": "on<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Adds the `listener` function to the end of the listeners array for the event\nnamed `eventName`. No checks are made to see if the `listener` has already\nbeen added. Multiple calls passing the same combination of `eventName` and\n`listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.101"
        },
        {
          "tagName": "param",
          "text": "The name of the event."
        },
        {
          "tagName": "param",
          "text": "The callback function"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.once",
      "kind": "MethodSignature",
      "signature": "once<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.0"
        },
        {
          "tagName": "param",
          "text": "The name of the event."
        },
        {
          "tagName": "param",
          "text": "The callback function"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.removeListener",
      "kind": "MethodSignature",
      "signature": "removeListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.off",
      "kind": "MethodSignature",
      "signature": "off<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Alias for `emitter.removeListener()`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v10.0.0"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.removeAllListeners",
      "kind": "MethodSignature",
      "signature": "removeAllListeners(eventName?: Key<unknown, T>): this;",
      "doc": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.setMaxListeners",
      "kind": "MethodSignature",
      "signature": "setMaxListeners(n: number): this;",
      "doc": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.5"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.getMaxListeners",
      "kind": "MethodSignature",
      "signature": "getMaxListeners(): number;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v1.0.0"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.listeners",
      "kind": "MethodSignature",
      "signature": "listeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;",
      "doc": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.rawListeners",
      "kind": "MethodSignature",
      "signature": "rawListeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;",
      "doc": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v9.4.0"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.emit",
      "kind": "MethodSignature",
      "signature": "emit<K>(eventName: Key<K, T>, ...args: Args<K, T>): boolean;",
      "doc": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.26"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.listenerCount",
      "kind": "MethodSignature",
      "signature": "listenerCount<K>(eventName: Key<K, T>, listener?: Listener2<K, T>): number;",
      "doc": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
      "tags": [
        {
          "tagName": "since",
          "text": "v3.2.0"
        },
        {
          "tagName": "param",
          "text": "The name of the event being listened for"
        },
        {
          "tagName": "param",
          "text": "The event handler function"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.prependListener",
      "kind": "MethodSignature",
      "signature": "prependListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        },
        {
          "tagName": "param",
          "text": "The name of the event."
        },
        {
          "tagName": "param",
          "text": "The callback function"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.prependOnceListener",
      "kind": "MethodSignature",
      "signature": "prependOnceListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;",
      "doc": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        },
        {
          "tagName": "param",
          "text": "The name of the event."
        },
        {
          "tagName": "param",
          "text": "The callback function"
        }
      ]
    },
    {
      "name": "applyProviderWrappers.eventNames",
      "kind": "MethodSignature",
      "signature": "eventNames(): Array<(string | symbol) & Key2<unknown, T>>;",
      "doc": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        }
      ]
    },
    {
      "name": "ProviderWrapperWithChainId",
      "kind": "ClassDeclaration",
      "signature": "export abstract class ProviderWrapperWithChainId extends ProviderWrapper {\n  private _chainId: number | undefined;\n\n  protected async _getChainId(): Promise<number> {\n    if (this._chainId === undefined) {\n      try {\n        this._chainId = await this._getChainIdFromEthChainId();\n      } catch {\n  ",
      "doc": "",
      "tags": []
    },
    {
      "name": "ChainIdValidatorProvider",
      "kind": "ClassDeclaration",
      "signature": "export class ChainIdValidatorProvider extends ProviderWrapperWithChainId {\n  private _alreadyValidated = false;\n\n  constructor(\n    provider: EIP1193Provider,\n    private readonly _expectedChainId: number\n  ) {\n    super(provider);\n  }\n\n  public async request(args: RequestArguments): Promise<unknown",
      "doc": "",
      "tags": []
    },
    {
      "name": "BackwardsCompatibilityProviderAdapter",
      "kind": "ClassDeclaration",
      "signature": "export class BackwardsCompatibilityProviderAdapter\n  extends EventEmitterWrapper\n  implements EthereumProvider\n{\n  constructor(private readonly _provider: EIP1193Provider) {\n    super(_provider);\n    // We bind everything here because some test suits break otherwise\n    this.sendAsync = this.sendAsy",
      "doc": "Hardhat predates the EIP1193 (Javascript Ethereum Provider) standard. It was\nbuilt following a draft of that spec, but then it changed completely. We\nstill need to support the draft api, but internally we use EIP1193. So we\nuse BackwardsCompatibilityProviderAdapter to wrap EIP1193 providers before\nexposing them to the user.",
      "tags": []
    },
    {
      "name": "JsonRpcTransactionData",
      "kind": "InterfaceDeclaration",
      "signature": "export interface JsonRpcTransactionData {\n  from?: string;\n  to?: string;\n  gas?: string | number;\n  gasPrice?: string | number;\n  value?: string | number;\n  data?: string;\n  nonce?: string | number;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "LocalAccountsProvider",
      "kind": "ClassDeclaration",
      "signature": "export class LocalAccountsProvider extends ProviderWrapperWithChainId {\n  private _addressToPrivateKey: Map<string, Buffer> = new Map();\n\n  constructor(\n    provider: EIP1193Provider,\n    localAccountsHexPrivateKeys: string[]\n  ) {\n    super(provider);\n\n    this._initializePrivateKeys(localAccountsH",
      "doc": "",
      "tags": []
    },
    {
      "name": "HDWalletProvider",
      "kind": "ClassDeclaration",
      "signature": "export class HDWalletProvider extends LocalAccountsProvider {\n  constructor(\n    provider: EIP1193Provider,\n    mnemonic: string,\n    hdpath: string = \"m/44'/60'/0'/0/\",\n    initialIndex: number = 0,\n    count: number = 10,\n    passphrase: string = \"\"\n  ) {\n    // NOTE: If mnemonic has space or newl",
      "doc": "",
      "tags": []
    },
    {
      "name": "AutomaticSenderProvider",
      "kind": "ClassDeclaration",
      "signature": "export class AutomaticSenderProvider extends SenderProvider {\n  private _firstAccount: string | undefined;\n\n  protected async _getSender(): Promise<string | undefined> {\n    if (this._firstAccount === undefined) {\n      const accounts = (await this._wrappedProvider.request({\n        method: \"eth_acc",
      "doc": "",
      "tags": []
    },
    {
      "name": "FixedSenderProvider",
      "kind": "ClassDeclaration",
      "signature": "export class FixedSenderProvider extends SenderProvider {\n  constructor(provider: EIP1193Provider, private readonly _sender: string) {\n    super(provider);\n  }\n\n  protected async _getSender(): Promise<string | undefined> {\n    return this._sender;\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_PARAM_DEFINITIONS",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_PARAM_DEFINITIONS: HardhatParamDefinitions = {\n  network: {\n    name: \"network\",\n    defaultValue: undefined,\n    description: \"The network to connect to.\",\n    type: types.string,\n    isOptional: true,\n    isFlag: false,\n    isVariadic: false,\n  },\n  showStackTraces: {\n    name: \"showStackT",
      "doc": "",
      "tags": []
    },
    {
      "name": "paramNameToEnvVariable",
      "kind": "FunctionDeclaration",
      "signature": "export function paramNameToEnvVariable(paramName: string): string {\n  // We create it starting from the result of ArgumentsParser.paramNameToCLA\n  // so it's easier to explain and understand their equivalences.\n  return ArgumentsParser.paramNameToCLA(paramName)\n    .replace(ArgumentsParser.PARAM_PRE",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvVariablesMap",
      "kind": "FunctionDeclaration",
      "signature": "export function getEnvVariablesMap(hardhatArguments: HardhatArguments): {\n  [envVar: string]: string;\n} {\n  const values: { [envVar: string]: string } = {};\n\n  for (const [name, value] of Object.entries(hardhatArguments)) {\n    if (value === undefined) {\n      continue;\n    }\n\n    values[paramNameTo",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments",
      "kind": "FunctionDeclaration",
      "signature": "export function getEnvHardhatArguments(\n  paramDefinitions: HardhatParamDefinitions,\n  envVariables: ProcessEnv\n): HardhatArguments {\n  const envArgs: any = {};\n\n  for (const paramName of unsafeObjectKeys(paramDefinitions)) {\n    const definition = paramDefinitions[paramName];\n    const envVarName =",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.network",
      "kind": "PropertySignature",
      "signature": "network?: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.showStackTraces",
      "kind": "PropertySignature",
      "signature": "showStackTraces: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.version",
      "kind": "PropertySignature",
      "signature": "version: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.help",
      "kind": "PropertySignature",
      "signature": "help: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.emoji",
      "kind": "PropertySignature",
      "signature": "emoji: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.config",
      "kind": "PropertySignature",
      "signature": "config?: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.verbose",
      "kind": "PropertySignature",
      "signature": "verbose: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.maxMemory",
      "kind": "PropertySignature",
      "signature": "maxMemory?: number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.tsconfig",
      "kind": "PropertySignature",
      "signature": "tsconfig?: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.flamegraph",
      "kind": "PropertySignature",
      "signature": "flamegraph?: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getEnvHardhatArguments.typecheck",
      "kind": "PropertySignature",
      "signature": "typecheck?: boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "string",
      "kind": "VariableDeclaration",
      "signature": "string: CLIArgumentType<string> = {\n  name: \"string\",\n  parse: (argName, strValue) => strValue,\n  /**\n   * Check if argument value is of type \"string\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   ",
      "doc": "",
      "tags": []
    },
    {
      "name": "boolean",
      "kind": "VariableDeclaration",
      "signature": "boolean: CLIArgumentType<boolean> = {\n  name: \"boolean\",\n  parse: (argName, strValue) => {\n    if (strValue.toLowerCase() === \"true\") {\n      return true;\n    }\n    if (strValue.toLowerCase() === \"false\") {\n      return false;\n    }\n\n    throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE",
      "doc": "",
      "tags": []
    },
    {
      "name": "int",
      "kind": "VariableDeclaration",
      "signature": "int: CLIArgumentType<number> = {\n  name: \"int\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === null\n    ) {\n      throw ",
      "doc": "",
      "tags": []
    },
    {
      "name": "bigint",
      "kind": "VariableDeclaration",
      "signature": "bigint: CLIArgumentType<bigint> = {\n  name: \"bigint\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:n)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === null\n    ) {\n      throw ",
      "doc": "",
      "tags": []
    },
    {
      "name": "float",
      "kind": "VariableDeclaration",
      "signature": "float: CLIArgumentType<number> = {\n  name: \"float\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === n",
      "doc": "",
      "tags": []
    },
    {
      "name": "inputFile",
      "kind": "VariableDeclaration",
      "signature": "inputFile: CLIArgumentType<string> = {\n  name: \"inputFile\",\n  parse(argName: string, strValue: string): string {\n    try {\n      fs.accessSync(strValue, fsExtra.constants.R_OK);\n      const stats = fs.lstatSync(strValue);\n\n      if (stats.isDirectory()) {\n        // This is caught and encapsulated i",
      "doc": "",
      "tags": []
    },
    {
      "name": "json",
      "kind": "VariableDeclaration",
      "signature": "json: CLIArgumentType<any> = {\n  name: \"json\",\n  parse(argName: string, strValue: string): any {\n    try {\n      return JSON.parse(strValue);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT,\n          {\n      ",
      "doc": "",
      "tags": []
    },
    {
      "name": "any",
      "kind": "VariableDeclaration",
      "signature": "any: ArgumentType<any> = {\n  name: \"any\",\n  validate(_argName: string, _argumentValue: any) {},\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcQuantityToNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function rpcQuantityToNumber(quantity: string): number {\n  return Number(rpcQuantityToBigInt(quantity));\n}",
      "doc": "Transforms a QUANTITY into a number. It should only be used if you are 100% sure that the value\nfits in a number.",
      "tags": []
    },
    {
      "name": "rpcQuantityToBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function rpcQuantityToBigInt(quantity: string): bigint {\n  // We validate it in case a value gets here through a cast or any\n  if (!isRpcQuantityString(quantity)) {\n    throw new HardhatError(ERRORS.NETWORK.INVALID_RPC_QUANTITY_VALUE, {\n      value: quantity,\n    });\n  }\n\n  return BigInt(quan",
      "doc": "",
      "tags": []
    },
    {
      "name": "numberToRpcQuantity",
      "kind": "FunctionDeclaration",
      "signature": "export function numberToRpcQuantity(n: number | bigint): string {\n  assertHardhatInvariant(\n    typeof n === \"number\" || typeof n === \"bigint\",\n    \"Expected number\"\n  );\n\n  return `0x${n.toString(16)}`;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "numberToRpcStorageSlot",
      "kind": "FunctionDeclaration",
      "signature": "export function numberToRpcStorageSlot(n: number | bigint): string {\n  assertHardhatInvariant(\n    typeof n === \"number\" || typeof n === \"bigint\",\n    \"Expected number\"\n  );\n\n  return `0x${BigIntUtils.toEvmWord(n)}`;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function rpcDataToNumber(data: string): number {\n  return Number(rpcDataToBigInt(data));\n}",
      "doc": "Transforms a DATA into a number. It should only be used if you are 100% sure that the data\nrepresents a value fits in a number.",
      "tags": []
    },
    {
      "name": "rpcDataToBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function rpcDataToBigInt(data: string): bigint {\n  return data === \"0x\" ? 0n : BigInt(data);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "bufferToRpcData",
      "kind": "FunctionDeclaration",
      "signature": "export function bufferToRpcData(\n  buffer: Uint8Array,\n  padToBytes: number = 0\n): string {\n  let s = bufferToHex(buffer);\n  if (padToBytes > 0 && s.length < padToBytes * 2 + 2) {\n    s = `0x${\"0\".repeat(padToBytes * 2 + 2 - s.length)}${s.slice(2)}`;\n  }\n  return s;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer",
      "kind": "FunctionDeclaration",
      "signature": "export function rpcDataToBuffer(data: string): Buffer {\n  // We validate it in case a value gets here through a cast or any\n  if (!isRpcDataString(data)) {\n    throw new HardhatError(ERRORS.NETWORK.INVALID_RPC_DATA_VALUE, {\n      value: data,\n    });\n  }\n\n  return Buffer.from(toBytes(data));\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?: number, end?: number): Buffer<ArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nThis method is not compatible with the `Uint8Array.prototype.slice()`,\nwhich is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconst copiedBuf = Uint8Array.prototype.slice.call(buf);\ncopiedBuf[0]++;\nconsole.log(copiedBuf.toString());\n// Prints: cuffer\n\nconsole.log(buf.toString());\n// Prints: buffer\n\n// With buf.slice(), the original buffer is modified.\nconst notReallyCopiedBuf = buf.slice();\nnotReallyCopiedBuf[0]++;\nconsole.log(notReallyCopiedBuf.toString());\n// Prints: cuffer\nconsole.log(buf.toString());\n// Also prints: cuffer (!)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.3.0"
        },
        {
          "tagName": "deprecated",
          "text": "Use `subarray` instead."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.subarray",
      "kind": "MethodSignature",
      "signature": "subarray(start?: number, end?: number): Buffer<TArrayBuffer>;",
      "doc": "Returns a new `Buffer` that references the same memory as the original, but\noffset and cropped by the `start` and `end` indices.\n\nSpecifying `end` greater than `buf.length` will return the same result as\nthat of `end` equal to `buf.length`.\n\nThis method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).\n\nModifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.subarray(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: !bc\n```\n\nSpecifying negative indexes causes the slice to be generated relative to the\nend of `buf` rather than the beginning.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.subarray(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.subarray(0, 5).)\n\nconsole.log(buf.subarray(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.subarray(0, 4).)\n\nconsole.log(buf.subarray(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.subarray(1, 4).)\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v3.0.0"
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will start."
        },
        {
          "tagName": "param",
          "text": "Where the new `Buffer` will end (not inclusive)."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.write",
      "kind": "MethodSignature",
      "signature": "write(string: string, encoding?: BufferEncoding): number;",
      "doc": "Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did\nnot contain enough space to fit the entire string, only part of `string` will be\nwritten. However, partially encoded characters will not be written.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.alloc(256);\n\nconst len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n\nconsole.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n// Prints: 12 bytes:  +  = \n\nconst buffer = Buffer.alloc(10);\n\nconst length = buffer.write('abcd', 8);\n\nconsole.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);\n// Prints: 2 bytes : ab\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "String to write to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write `string`."
        },
        {
          "tagName": "param",
          "text": "Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`)."
        },
        {
          "tagName": "param",
          "text": "The character encoding of `string`."
        },
        {
          "tagName": "return",
          "text": "Number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.toString",
      "kind": "MethodSignature",
      "signature": "toString(encoding?: BufferEncoding, start?: number, end?: number): string;",
      "doc": "[object Object],[object Object],[object Object]",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "The character encoding to use."
        },
        {
          "tagName": "param",
          "text": "The byte offset to start decoding at."
        },
        {
          "tagName": "param",
          "text": "The byte offset to stop decoding at (not inclusive)."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.toJSON",
      "kind": "MethodSignature",
      "signature": "toJSON(): {\n                type: \"Buffer\";\n                data: number[];\n            };",
      "doc": "Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls\nthis function when stringifying a `Buffer` instance.\n\n`Buffer.from()` accepts objects in the format returned from this method.\nIn particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value &#x26;&#x26; value.type === 'Buffer' ?\n    Buffer.from(value) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: <Buffer 01 02 03 04 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.9.2"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.equals",
      "kind": "MethodSignature",
      "signature": "equals(otherBuffer: Uint8Array): boolean;",
      "doc": "Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.compare",
      "kind": "MethodSignature",
      "signature": "compare(\n                target: Uint8Array,\n                targetStart?: number,\n                targetEnd?: number,\n                sourceStart?: number,\n                sourceEnd?: number,\n            ): -1 | 0 | 1;",
      "doc": "Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.\nComparison is based on the actual sequence of bytes in each `Buffer`.\n\n* `0` is returned if `target` is the same as `buf`\n* `1` is returned if `target` should come _before_`buf` when sorted.\n* `-1` is returned if `target` should come _after_`buf` when sorted.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]\n// (This result is equal to: [buf1, buf3, buf2].)\n```\n\nThe optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used to limit the comparison to specific ranges within `target` and `buf` respectively.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n```\n\n`ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`, `targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.13"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} with which to compare `buf`."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to end comparison (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to begin comparison."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to end comparison (not inclusive)."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.copy",
      "kind": "MethodSignature",
      "signature": "copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;",
      "doc": "Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.\n\n[`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available\nfor all TypedArrays, including Node.js `Buffer`s, although it takes\ndifferent function arguments.\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.\nbuf1.copy(buf2, 8, 16, 20);\n// This is equivalent to:\n// buf2.set(buf1.subarray(16, 20), 8);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n```\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 is the decimal ASCII value for 'a'.\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.1.90"
        },
        {
          "tagName": "param",
          "text": "A `Buffer` or {@link Uint8Array} to copy into."
        },
        {
          "tagName": "param",
          "text": "The offset within `target` at which to begin writing."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` from which to begin copying."
        },
        {
          "tagName": "param",
          "text": "The offset within `buf` at which to stop copying (not inclusive)."
        },
        {
          "tagName": "return",
          "text": "The number of bytes copied."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeBigInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64BE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeBigInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigInt64LE(0x0102030405060708n, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64BE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.\n\nThis function is also available under the `writeBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64BE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de ca fa fe ca ce fa de>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeBigUint64BE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64BE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUInt64LE(value: bigint, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeBigUInt64LE(0xdecafafecacefaden, 0);\n\nconsole.log(buf);\n// Prints: <Buffer de fa ce ca fe fa ca de>\n```\n\nThis function is also available under the `writeBigUint64LE` alias.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeBigUint64LE",
      "kind": "MethodSignature",
      "signature": "writeBigUint64LE(value: bigint, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUIntLE",
      "kind": "MethodSignature",
      "signature": "writeUIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUintLE",
      "kind": "MethodSignature",
      "signature": "writeUintLE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUIntBE",
      "kind": "MethodSignature",
      "signature": "writeUIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than an unsigned integer.\n\nThis function is also available under the `writeUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUintBE",
      "kind": "MethodSignature",
      "signature": "writeUintBE(value: number, offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeIntLE",
      "kind": "MethodSignature",
      "signature": "writeIntLE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\nwhen `value` is anything other than a signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer ab 90 78 56 34 12>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeIntBE",
      "kind": "MethodSignature",
      "signature": "writeIntBE(value: number, offset: number, byteLength: number): number;",
      "doc": "Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a\nsigned integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: <Buffer 12 34 56 78 90 ab>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readBigUInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64BE(offset?: number): bigint;",
      "doc": "Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64BE(0));\n// Prints: 4294967295n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readBigUint64BE",
      "kind": "MethodSignature",
      "signature": "readBigUint64BE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64BE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readBigUInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigUInt64LE(offset?: number): bigint;",
      "doc": "Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readBigUint64LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n\nconsole.log(buf.readBigUInt64LE(0));\n// Prints: 18446744069414584320n\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readBigUint64LE",
      "kind": "MethodSignature",
      "signature": "readBigUint64LE(offset?: number): bigint;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readBigUInt64LE"
        },
        {
          "tagName": "since",
          "text": "v14.10.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readBigInt64BE",
      "kind": "MethodSignature",
      "signature": "readBigInt64BE(offset?: number): bigint;",
      "doc": "Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readBigInt64LE",
      "kind": "MethodSignature",
      "signature": "readBigInt64LE(offset?: number): bigint;",
      "doc": "Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed\nvalues.",
      "tags": [
        {
          "tagName": "since",
          "text": "v12.0.0, v10.20.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUIntLE",
      "kind": "MethodSignature",
      "signature": "readUIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned, little-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintLE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUintLE",
      "kind": "MethodSignature",
      "signature": "readUintLE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntLE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUIntBE",
      "kind": "MethodSignature",
      "signature": "readUIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned big-endian integer supporting\nup to 48 bits of accuracy.\n\nThis function is also available under the `readUintBE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUintBE",
      "kind": "MethodSignature",
      "signature": "readUintBE(offset: number, byteLength: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUIntBE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readIntLE",
      "kind": "MethodSignature",
      "signature": "readIntLE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a little-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readIntBE",
      "kind": "MethodSignature",
      "signature": "readIntBE(offset: number, byteLength: number): number;",
      "doc": "Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a big-endian, two's complement signed value\nsupporting up to 48 bits of accuracy.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE.\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUInt8",
      "kind": "MethodSignature",
      "signature": "readUInt8(offset?: number): number;",
      "doc": "Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUint8",
      "kind": "MethodSignature",
      "signature": "readUint8(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUInt16LE",
      "kind": "MethodSignature",
      "signature": "readUInt16LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 16-bit integer from `buf` at the specified `offset`.\n\nThis function is also available under the `readUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUint16LE",
      "kind": "MethodSignature",
      "signature": "readUint16LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUInt16BE",
      "kind": "MethodSignature",
      "signature": "readUInt16BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUint16BE",
      "kind": "MethodSignature",
      "signature": "readUint16BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUInt32LE",
      "kind": "MethodSignature",
      "signature": "readUInt32LE(offset?: number): number;",
      "doc": "Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUint32LE",
      "kind": "MethodSignature",
      "signature": "readUint32LE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUInt32BE",
      "kind": "MethodSignature",
      "signature": "readUInt32BE(offset?: number): number;",
      "doc": "Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.\n\nThis function is also available under the `readUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readUint32BE",
      "kind": "MethodSignature",
      "signature": "readUint32BE(offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.readUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readInt8",
      "kind": "MethodSignature",
      "signature": "readInt8(offset?: number): number;",
      "doc": "Reads a signed 8-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readInt16LE",
      "kind": "MethodSignature",
      "signature": "readInt16LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readInt16BE",
      "kind": "MethodSignature",
      "signature": "readInt16BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readInt32LE",
      "kind": "MethodSignature",
      "signature": "readInt32LE(offset?: number): number;",
      "doc": "Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readInt32BE",
      "kind": "MethodSignature",
      "signature": "readInt32BE(offset?: number): number;",
      "doc": "Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.\n\nIntegers read from a `Buffer` are interpreted as two's complement signed values.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readFloatLE",
      "kind": "MethodSignature",
      "signature": "readFloatLE(offset?: number): number;",
      "doc": "Reads a 32-bit, little-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readFloatBE",
      "kind": "MethodSignature",
      "signature": "readFloatBE(offset?: number): number;",
      "doc": "Reads a 32-bit, big-endian float from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readDoubleLE",
      "kind": "MethodSignature",
      "signature": "readDoubleLE(offset?: number): number;",
      "doc": "Reads a 64-bit, little-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.readDoubleBE",
      "kind": "MethodSignature",
      "signature": "readDoubleBE(offset?: number): number;",
      "doc": "Reads a 64-bit, big-endian double from `buf` at the specified `offset`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.reverse",
      "kind": "MethodSignature",
      "signature": "reverse(): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.swap16",
      "kind": "MethodSignature",
      "signature": "swap16(): this;",
      "doc": "Interprets `buf` as an array of unsigned 16-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: <Buffer 02 01 04 03 06 05 08 07>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```\n\nOne convenient use of `buf.swap16()` is to perform a fast in-place conversion\nbetween UTF-16 little-endian and UTF-16 big-endian:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\nbuf.swap16(); // Convert to big-endian UTF-16 text.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.swap32",
      "kind": "MethodSignature",
      "signature": "swap32(): this;",
      "doc": "Interprets `buf` as an array of unsigned 32-bit integers and swaps the\nbyte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: <Buffer 04 03 02 01 08 07 06 05>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.10.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.swap64",
      "kind": "MethodSignature",
      "signature": "swap64(): this;",
      "doc": "Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.\nThrows `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: <Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: <Buffer 08 07 06 05 04 03 02 01>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.3.0"
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUInt8",
      "kind": "MethodSignature",
      "signature": "writeUInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a\nvalid unsigned 8-bit integer. Behavior is undefined when `value` is anything\nother than an unsigned 8-bit integer.\n\nThis function is also available under the `writeUint8` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: <Buffer 03 04 23 42>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUint8",
      "kind": "MethodSignature",
      "signature": "writeUint8(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt8"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUInt16LE",
      "kind": "MethodSignature",
      "signature": "writeUInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 16-bit integer.\n\nThis function is also available under the `writeUint16LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer ad de ef be>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUint16LE",
      "kind": "MethodSignature",
      "signature": "writeUint16LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUInt16BE",
      "kind": "MethodSignature",
      "signature": "writeUInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 16-bit integer.\n\nThis function is also available under the `writeUint16BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: <Buffer de ad be ef>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUint16BE",
      "kind": "MethodSignature",
      "signature": "writeUint16BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt16BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUInt32LE",
      "kind": "MethodSignature",
      "signature": "writeUInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is\nanything other than an unsigned 32-bit integer.\n\nThis function is also available under the `writeUint32LE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer ce fa ed fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUint32LE",
      "kind": "MethodSignature",
      "signature": "writeUint32LE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32LE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUInt32BE",
      "kind": "MethodSignature",
      "signature": "writeUInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an\nunsigned 32-bit integer.\n\nThis function is also available under the `writeUint32BE` alias.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: <Buffer fe ed fa ce>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeUint32BE",
      "kind": "MethodSignature",
      "signature": "writeUint32BE(value: number, offset?: number): number;",
      "doc": "",
      "tags": [
        {
          "tagName": "alias",
          "text": "Buffer.writeUInt32BE"
        },
        {
          "tagName": "since",
          "text": "v14.9.0, v12.19.0"
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeInt8",
      "kind": "MethodSignature",
      "signature": "writeInt8(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset`. `value` must be a valid\nsigned 8-bit integer. Behavior is undefined when `value` is anything other than\na signed 8-bit integer.\n\n`value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: <Buffer 02 fe>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeInt16LE",
      "kind": "MethodSignature",
      "signature": "writeInt16LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16LE(0x0304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 04 03>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeInt16BE",
      "kind": "MethodSignature",
      "signature": "writeInt16BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is\nanything other than a signed 16-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt16BE(0x0102, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeInt32LE",
      "kind": "MethodSignature",
      "signature": "writeInt32LE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32LE(0x05060708, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 08 07 06 05>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeInt32BE",
      "kind": "MethodSignature",
      "signature": "writeInt32BE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is\nanything other than a signed 32-bit integer.\n\nThe `value` is interpreted and written as a two's complement signed integer.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt32BE(0x01020304, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 01 02 03 04>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.5"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeFloatLE",
      "kind": "MethodSignature",
      "signature": "writeFloatLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer bb fe 4a 4f>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeFloatBE",
      "kind": "MethodSignature",
      "signature": "writeFloatBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is\nundefined when `value` is anything other than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 4f 4a fe bb>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeDoubleLE",
      "kind": "MethodSignature",
      "signature": "writeDoubleLE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.writeDoubleBE",
      "kind": "MethodSignature",
      "signature": "writeDoubleBE(value: number, offset?: number): number;",
      "doc": "Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything\nother than a JavaScript number.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: <Buffer 40 5e dd 2f 1a 9f be 77>\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.11.15"
        },
        {
          "tagName": "param",
          "text": "Number to be written to `buf`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
        },
        {
          "tagName": "return",
          "text": "`offset` plus the number of bytes written."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.fill",
      "kind": "MethodSignature",
      "signature": "fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;",
      "doc": "Fills `buf` with the specified `value`. If the `offset` and `end` are not given,\nthe entire `buf` will be filled:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with the ASCII character 'h'.\n\nconst b = Buffer.allocUnsafe(50).fill('h');\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n\n// Fill a buffer with empty string\nconst c = Buffer.allocUnsafe(5).fill('');\n\nconsole.log(c.fill(''));\n// Prints: <Buffer 00 00 00 00 00>\n```\n\n`value` is coerced to a `uint32` value if it is not a string, `Buffer`, or\ninteger. If the resulting integer is greater than `255` (decimal), `buf` will be\nfilled with `value &#x26; 255`.\n\nIf the final write of a `fill()` operation falls on a multi-byte character,\nthen only the bytes of that character that fit into `buf` are written:\n\n```js\nimport { Buffer } from 'node:buffer';\n\n// Fill a `Buffer` with character that takes up two bytes in UTF-8.\n\nconsole.log(Buffer.allocUnsafe(5).fill('\\u0222'));\n// Prints: <Buffer c8 a2 c8 a2 c8>\n```\n\nIf `value` contains invalid characters, it is truncated; if no valid\nfill data remains, an exception is thrown:\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill('a'));\n// Prints: <Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Throws an exception.\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v0.5.0"
        },
        {
          "tagName": "param",
          "text": "The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`."
        },
        {
          "tagName": "param",
          "text": "Number of bytes to skip before starting to fill `buf`."
        },
        {
          "tagName": "param",
          "text": "Where to stop filling `buf` (not inclusive)."
        },
        {
          "tagName": "param",
          "text": "The encoding for `value` if `value` is a string."
        },
        {
          "tagName": "return",
          "text": "A reference to `buf`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "If `value` is:\n\n* a string, `value` is interpreted according to the character encoding in `encoding`.\n* a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.\nTo compare a partial `Buffer`, use `buf.subarray`.\n* a number, `value` will be interpreted as an unsigned 8-bit integer\nvalue between `0` and `255`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.indexOf('this'));\n// Prints: 0\nconsole.log(buf.indexOf('is'));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from('a buffer')));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.indexOf(Buffer.from('a buffer example')));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n// Prints: 6\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. If the result\nof coercion is `NaN` or `0`, then the entire buffer will be searched. This\nbehavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer` and `byteOffset` is less\nthan `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v1.5.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;",
      "doc": "Identical to `buf.indexOf()`, except the last occurrence of `value` is found\nrather than the first occurrence.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this buffer is a buffer');\n\nconsole.log(buf.lastIndexOf('this'));\n// Prints: 0\nconsole.log(buf.lastIndexOf('buffer'));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from('buffer')));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.lastIndexOf(Buffer.from('yolo')));\n// Prints: -1\nconsole.log(buf.lastIndexOf('buffer', 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf('buffer', 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n// Prints: 4\n```\n\nIf `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.\n\nIf `byteOffset` is not a number, it will be coerced to a number. Any arguments\nthat coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.\nThis behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte.\n// Prints: 2, equivalent to searching for 99 or 'c'.\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN.\n// Prints: 1, searching the whole buffer.\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n\n// Passing a byteOffset that coerces to 0.\n// Prints: -1, equivalent to passing 0.\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n```\n\nIf `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.",
      "tags": [
        {
          "tagName": "since",
          "text": "v6.0.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`."
        },
        {
          "tagName": "return",
          "text": "The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.includes",
      "kind": "MethodSignature",
      "signature": "includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;",
      "doc": "Equivalent to `buf.indexOf() !== -1`.\n\n```js\nimport { Buffer } from 'node:buffer';\n\nconst buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.includes('this'));\n// Prints: true\nconsole.log(buf.includes('is'));\n// Prints: true\nconsole.log(buf.includes(Buffer.from('a buffer')));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for 'a')\nconsole.log(buf.includes(Buffer.from('a buffer example')));\n// Prints: false\nconsole.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes('this', 4));\n// Prints: false\n```",
      "tags": [
        {
          "tagName": "since",
          "text": "v5.3.0"
        },
        {
          "tagName": "param",
          "text": "What to search for."
        },
        {
          "tagName": "param",
          "text": "Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`."
        },
        {
          "tagName": "param",
          "text": "If `value` is a string, this is its encoding."
        },
        {
          "tagName": "return",
          "text": "`true` if `value` was found in `buf`, `false` otherwise."
        }
      ]
    },
    {
      "name": "rpcDataToBuffer.BYTES_PER_ELEMENT",
      "kind": "PropertySignature",
      "signature": "readonly BYTES_PER_ELEMENT:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.buffer",
      "kind": "PropertySignature",
      "signature": "readonly buffer:TArrayBuffer;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.byteLength",
      "kind": "PropertySignature",
      "signature": "readonly byteLength:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.byteOffset",
      "kind": "PropertySignature",
      "signature": "readonly byteOffset:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.every",
      "kind": "MethodSignature",
      "signature": "every(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.filter",
      "kind": "MethodSignature",
      "signature": "filter(predicate:(value:number,index:number,array:this)=>any,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.find",
      "kind": "MethodSignature",
      "signature": "find(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:number,index:number,obj:this)=>boolean,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:number,index:number,array:this)=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.length",
      "kind": "PropertySignature",
      "signature": "readonly length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.map",
      "kind": "MethodSignature",
      "signature": "map(callbackfn:(value:number,index:number,array:this)=>number,thisArg?:any):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:this)=>number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.set",
      "kind": "MethodSignature",
      "signature": "set(array:ArrayLike<number>,offset?:number):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:number,b:number)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,number]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):number|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends number>(predicate:(value:number,index:number,array:this,)=>value is S,thisArg?:any,):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:number,index:number,array:this)=>unknown,thisArg?:any,):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:number,b:number)=>number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:number):Uint8Array<ArrayBuffer>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDataToBuffer.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:\"Uint8Array\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcQuantity",
      "kind": "VariableDeclaration",
      "signature": "rpcQuantity = new t.Type<bigint>(\n  \"QUANTITY\",\n  BigIntUtils.isBigInt,\n  (u, c) => (isRpcQuantityString(u) ? t.success(BigInt(u)) : t.failure(u, c)),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcData",
      "kind": "VariableDeclaration",
      "signature": "rpcData = new t.Type<Buffer>(\n  \"DATA\",\n  Buffer.isBuffer,\n  (u, c) =>\n    isRpcDataString(u) ? t.success(Buffer.from(toBytes(u))) : t.failure(u, c),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcParity",
      "kind": "VariableDeclaration",
      "signature": "rpcParity = new t.Type<Buffer>(\n  \"PARITY\",\n  Buffer.isBuffer,\n  (u, c) =>\n    isRpcParityString(u) ? t.success(Buffer.from(toBytes(u))) : t.failure(u, c),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcHash",
      "kind": "VariableDeclaration",
      "signature": "rpcHash = new t.Type<Buffer>(\n  \"HASH\",\n  (v): v is Buffer => Buffer.isBuffer(v) && v.length === HASH_LENGTH_BYTES,\n  (u, c) =>\n    isRpcHashString(u) ? t.success(Buffer.from(toBytes(u))) : t.failure(u, c),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcStorageSlot",
      "kind": "VariableDeclaration",
      "signature": "rpcStorageSlot = new t.Type<bigint>(\n  \"Storage slot\",\n  BigIntUtils.isBigInt,\n  validateStorageSlot,\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcStorageSlotHexString",
      "kind": "VariableDeclaration",
      "signature": "rpcStorageSlotHexString = new t.Type<string>(\n  \"Storage slot hex string\",\n  (x): x is string => typeof x === \"string\",\n  (u, c) =>\n    validateRpcStorageSlotHexString(u) ? t.success(u) : t.failure(u, c),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcAddress",
      "kind": "VariableDeclaration",
      "signature": "rpcAddress = new t.Type<Buffer>(\n  \"ADDRESS\",\n  (v): v is Buffer => Buffer.isBuffer(v) && v.length === ADDRESS_LENGTH_BYTES,\n  (u, c) =>\n    isRpcAddressString(u)\n      ? t.success(Buffer.from(toBytes(u)))\n      : t.failure(u, c),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcUnsignedInteger",
      "kind": "VariableDeclaration",
      "signature": "rpcUnsignedInteger = new t.Type<number>(\n  \"Unsigned integer\",\n  isInteger,\n  (u, c) => (isInteger(u) && u >= 0 ? t.success(u) : t.failure(u, c)),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcQuantityAsNumber",
      "kind": "VariableDeclaration",
      "signature": "rpcQuantityAsNumber = new t.Type<bigint>(\n  \"Integer\",\n  BigIntUtils.isBigInt,\n  (u, c) => (isInteger(u) ? t.success(BigInt(u)) : t.failure(u, c)),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcFloat",
      "kind": "VariableDeclaration",
      "signature": "rpcFloat = new t.Type<number>(\n  \"Float number\",\n  isNumber,\n  (u, c) => (typeof u === \"number\" ? t.success(u) : t.failure(u, c)),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcAuthorizationList",
      "kind": "VariableDeclaration",
      "signature": "rpcAuthorizationList = t.array(rpcAuthorizationListTuple)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcAuthorizationListTuple",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcAuthorizationListTuple = t.TypeOf<\n  typeof rpcAuthorizationListTuple\n>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcAuthorizationList",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcAuthorizationList = t.TypeOf<typeof rpcAuthorizationList>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcAccessList",
      "kind": "VariableDeclaration",
      "signature": "rpcAccessList = t.array(rpcAccessListTuple)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcAccessListTuple",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcAccessListTuple = t.TypeOf<typeof rpcAccessListTuple>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcAccessList",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcAccessList = t.TypeOf<typeof rpcAccessList>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcTransaction",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcTransaction = t.TypeOf<typeof rpcTransaction>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcTransaction",
      "kind": "VariableDeclaration",
      "signature": "rpcTransaction = t.type(\n  {\n    blockHash: nullable(rpcHash),\n    blockNumber: nullable(rpcQuantity),\n    from: rpcAddress,\n    gas: rpcQuantity,\n    gasPrice: rpcQuantity, // NOTE: Its meaning was changed by EIP-1559\n    hash: rpcHash,\n    input: rpcData,\n    nonce: rpcQuantity,\n    // This is als",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcTransactionReceipt",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcTransactionReceipt = t.TypeOf<typeof rpcTransactionReceipt>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcTransactionReceipt",
      "kind": "VariableDeclaration",
      "signature": "rpcTransactionReceipt = t.type(\n  {\n    transactionHash: rpcHash,\n    transactionIndex: rpcQuantity,\n    blockHash: rpcHash,\n    blockNumber: rpcQuantity,\n    from: rpcAddress,\n    to: nullable(rpcAddress),\n    cumulativeGasUsed: rpcQuantity,\n    gasUsed: rpcQuantity,\n    contractAddress: nullable(r",
      "doc": "",
      "tags": []
    },
    {
      "name": "HardhatMetadata",
      "kind": "InterfaceDeclaration",
      "signature": "export interface HardhatMetadata {\n  // A string identifying the version of Hardhat, for debugging purposes,\n  // not meant to be displayed to users.\n  clientVersion: string;\n\n  // The chain's id. Used to sign transactions.\n  chainId: number;\n\n  // A 0x-prefixed hex-encoded 32 bytes id which uniquel",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcLog",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcLog = t.TypeOf<typeof rpcLog>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcLog",
      "kind": "VariableDeclaration",
      "signature": "rpcLog = t.type(\n  {\n    logIndex: nullable(rpcQuantity),\n    transactionIndex: nullable(rpcQuantity),\n    transactionHash: nullable(rpcHash),\n    blockHash: nullable(rpcHash),\n    blockNumber: nullable(rpcQuantity),\n    address: rpcAddress,\n    data: rpcData,\n    topics: t.array(rpcData, \"RpcData A",
      "doc": "",
      "tags": []
    },
    {
      "name": "decodeJsonRpcResponse",
      "kind": "FunctionDeclaration",
      "signature": "export function decodeJsonRpcResponse<T>(value: unknown, codec: t.Type<T>): T {\n  const result = codec.decode(value);\n\n  if (result.isLeft()) {\n    throw new InvalidResponseError(\n      `Invalid JSON-RPC response's result.\n\nErrors: ${PathReporter.report(result).join(\", \")}`\n    );\n  }\n\n  return resu",
      "doc": "This function decodes an RPC out type, throwing InvalidResponseError if it's not valid.",
      "tags": []
    },
    {
      "name": "RpcBlock",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcBlock = t.TypeOf<typeof rpcBlock>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcBlock",
      "kind": "VariableDeclaration",
      "signature": "rpcBlock = t.type(\n  {\n    ...baseBlockResponse,\n    transactions: t.array(rpcHash, \"HASH Array\"),\n  },\n  \"RpcBlock\"\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcBlockWithTransactions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcBlockWithTransactions = t.TypeOf<\n  typeof rpcBlockWithTransactions\n>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcBlockWithTransactions",
      "kind": "VariableDeclaration",
      "signature": "rpcBlockWithTransactions = t.type(\n  {\n    ...baseBlockResponse,\n    transactions: t.array(rpcTransaction, \"RpcTransaction Array\"),\n  },\n  \"RpcBlockWithTransactions\"\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "validateParams",
      "kind": "FunctionDeclaration",
      "signature": "export function validateParams<\n  TypesT extends ReadonlyArray<t.Type<any, any, any>>\n>(\n  params: any[],\n  ...types: TypesT\n): {\n  [i in keyof TypesT]: TypesT[i] extends t.Type<infer TypeT, any, any>\n    ? TypeT\n    : never;\n} {\n  if (types === undefined && params.length > 0) {\n    throw new Invali",
      "doc": "This function validates a list of params, throwing InvalidArgumentsError\nif the validation fails, and returning their already-parsed types if\nthe validation succeeds.\n\nTODO: The type can probably be improved, removing the anys",
      "tags": []
    },
    {
      "name": "rpcTransactionRequest",
      "kind": "VariableDeclaration",
      "signature": "rpcTransactionRequest = t.type(\n  {\n    from: rpcAddress,\n    to: optionalOrNullable(rpcAddress),\n    gas: optionalOrNullable(rpcQuantity),\n    gasPrice: optionalOrNullable(rpcQuantity),\n    value: optionalOrNullable(rpcQuantity),\n    nonce: optionalOrNullable(rpcQuantity),\n    data: optionalOrNulla",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcTransactionRequestInput",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RpcTransactionRequestInput {\n  from: string;\n  to?: string;\n  gas?: string;\n  gasPrice?: string;\n  value?: string;\n  nonce?: string;\n  data?: string;\n  accessList?: Array<{\n    address: string;\n    storageKeys: string[];\n  }>;\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcTransactionRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcTransactionRequest = t.TypeOf<typeof rpcTransactionRequest>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcSubscribe",
      "kind": "InterfaceDeclaration",
      "signature": "export interface RpcSubscribe {\n  request: RpcFilterRequest;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcSubscribeRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcSubscribeRequest = t.TypeOf<typeof rpcSubscribeRequest>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcSubscribeRequest",
      "kind": "VariableDeclaration",
      "signature": "rpcSubscribeRequest = t.keyof(\n  {\n    newHeads: null,\n    newPendingTransactions: null,\n    logs: null,\n  },\n  \"RpcSubscribe\"\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcCompilerInput",
      "kind": "VariableDeclaration",
      "signature": "rpcCompilerInput = t.type(\n  {\n    language: t.string,\n    sources: t.any,\n    settings: t.any,\n  },\n  \"RpcCompilerInput\"\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcCompilerInput",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcCompilerInput = t.TypeOf<typeof rpcCompilerInput>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcCompilerOutput",
      "kind": "VariableDeclaration",
      "signature": "rpcCompilerOutput = t.type(\n  {\n    sources: t.any,\n    contracts: t.any,\n  },\n  \"RpcCompilerOutput\"\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcCompilerOutput",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcCompilerOutput = t.TypeOf<typeof rpcCompilerOutput>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcLogTopics",
      "kind": "VariableDeclaration",
      "signature": "rpcLogTopics = t.array(\n  t.union([t.null, rpcHash, t.array(t.union([t.null, rpcHash]))])\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcLogTopics",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcLogTopics = t.TypeOf<typeof rpcLogTopics>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalRpcLogTopics",
      "kind": "VariableDeclaration",
      "signature": "optionalRpcLogTopics = optionalOrNullable(rpcLogTopics)",
      "doc": "",
      "tags": []
    },
    {
      "name": "OptionalRpcLogTopics",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OptionalRpcLogTopics = t.TypeOf<typeof optionalRpcLogTopics>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcLogAddress",
      "kind": "VariableDeclaration",
      "signature": "rpcLogAddress = t.union([rpcAddress, t.array(rpcAddress)])",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcLogAddress",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcLogAddress = t.TypeOf<typeof rpcLogAddress>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalRpcLogAddress",
      "kind": "VariableDeclaration",
      "signature": "optionalRpcLogAddress = optionalOrNullable(rpcLogAddress)",
      "doc": "",
      "tags": []
    },
    {
      "name": "OptionalRpcLogAddress",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OptionalRpcLogAddress = t.TypeOf<typeof optionalRpcLogAddress>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcForkConfig",
      "kind": "VariableDeclaration",
      "signature": "rpcForkConfig = optional(\n  t.type(\n    {\n      jsonRpcUrl: t.string,\n      blockNumber: optional(t.number),\n      httpHeaders: optional(t.record(t.string, t.string, \"httpHeaders\")),\n    },\n    \"RpcForkConfig\"\n  )\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcForkConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcForkConfig = t.TypeOf<typeof rpcForkConfig>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcHardhatNetworkConfig",
      "kind": "VariableDeclaration",
      "signature": "rpcHardhatNetworkConfig = t.type(\n  {\n    forking: optional(rpcForkConfig),\n  },\n  \"HardhatNetworkConfig\"\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcHardhatNetworkConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcHardhatNetworkConfig = t.TypeOf<typeof rpcHardhatNetworkConfig>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalRpcHardhatNetworkConfig",
      "kind": "VariableDeclaration",
      "signature": "optionalRpcHardhatNetworkConfig = optional(\n  rpcHardhatNetworkConfig\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcIntervalMining",
      "kind": "VariableDeclaration",
      "signature": "rpcIntervalMining = t.union([\n  rpcUnsignedInteger,\n  rpcIntervalMiningRange,\n])",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcIntervalMining",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcIntervalMining = t.TypeOf<typeof rpcIntervalMining>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcFilterRequest",
      "kind": "VariableDeclaration",
      "signature": "rpcFilterRequest = t.type(\n  {\n    fromBlock: optionalRpcOldBlockTag,\n    toBlock: optionalRpcOldBlockTag,\n    address: optionalRpcLogAddress,\n    topics: optionalRpcLogTopics,\n    blockHash: optionalOrNullable(rpcHash),\n  },\n  \"RpcFilterRequest\"\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcFilterRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcFilterRequest = t.TypeOf<typeof rpcFilterRequest>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalRpcFilterRequest",
      "kind": "VariableDeclaration",
      "signature": "optionalRpcFilterRequest = optionalOrNullable(rpcFilterRequest)",
      "doc": "",
      "tags": []
    },
    {
      "name": "OptionalRpcFilterRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OptionalRpcFilterRequest = t.TypeOf<\n  typeof optionalRpcFilterRequest\n>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcDebugTracingConfig",
      "kind": "VariableDeclaration",
      "signature": "rpcDebugTracingConfig = optionalOrNullable(\n  t.type(\n    {\n      tracer: optionalOrNullable(t.string),\n      disableStorage: optionalOrNullable(t.boolean),\n      disableMemory: optionalOrNullable(t.boolean),\n      disableStack: optionalOrNullable(t.boolean),\n    },\n    \"RpcDebugTracingConfig\"\n  )\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcDebugTracingConfig",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcDebugTracingConfig = t.TypeOf<typeof rpcDebugTracingConfig>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcCallRequest",
      "kind": "VariableDeclaration",
      "signature": "rpcCallRequest = t.type(\n  {\n    from: optionalOrNullable(rpcAddress),\n    to: optionalOrNullable(rpcAddress),\n    gas: optionalOrNullable(rpcQuantity),\n    gasPrice: optionalOrNullable(rpcQuantity),\n    value: optionalOrNullable(rpcQuantity),\n    data: optionalOrNullable(rpcData),\n    accessList: o",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcCallRequest",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcCallRequest = t.TypeOf<typeof rpcCallRequest>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "stateProperties",
      "kind": "VariableDeclaration",
      "signature": "stateProperties = t.record(\n  rpcStorageSlotHexString,\n  rpcStorageSlot\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "stateOverrideOptions",
      "kind": "VariableDeclaration",
      "signature": "stateOverrideOptions = t.type(\n  {\n    balance: optionalOrNullable(rpcQuantity),\n    nonce: optionalOrNullable(rpcQuantity),\n    code: optionalOrNullable(rpcData),\n    state: optionalOrNullable(stateProperties),\n    stateDiff: optionalOrNullable(stateProperties),\n  },\n  \"stateOverrideOptions\"\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "stateOverrideSet",
      "kind": "VariableDeclaration",
      "signature": "stateOverrideSet = t.record(address, stateOverrideOptions)",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalStateOverrideSet",
      "kind": "VariableDeclaration",
      "signature": "optionalStateOverrideSet = optionalOrNullable(stateOverrideSet)",
      "doc": "",
      "tags": []
    },
    {
      "name": "StateProperties",
      "kind": "TypeAliasDeclaration",
      "signature": "export type StateProperties = t.TypeOf<typeof stateProperties>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "StateOverrideOptions",
      "kind": "TypeAliasDeclaration",
      "signature": "export type StateOverrideOptions = t.TypeOf<typeof stateOverrideOptions>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "StateOverrideSet",
      "kind": "TypeAliasDeclaration",
      "signature": "export type StateOverrideSet = t.TypeOf<typeof stateOverrideSet>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "OptionalStateOverrideSet",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OptionalStateOverrideSet = t.TypeOf<\n  typeof optionalStateOverrideSet\n>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcNewBlockTagObjectWithNumber",
      "kind": "VariableDeclaration",
      "signature": "rpcNewBlockTagObjectWithNumber = t.type({\n  blockNumber: rpcQuantity,\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcNewBlockTagObjectWithHash",
      "kind": "VariableDeclaration",
      "signature": "rpcNewBlockTagObjectWithHash = t.type({\n  blockHash: rpcData,\n  requireCanonical: optionalOrNullable(t.boolean),\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcBlockTagName",
      "kind": "VariableDeclaration",
      "signature": "rpcBlockTagName = t.keyof({\n  earliest: null,\n  latest: null,\n  pending: null,\n  safe: null,\n  finalized: null,\n})",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcNewBlockTag",
      "kind": "VariableDeclaration",
      "signature": "rpcNewBlockTag = t.union([\n  rpcQuantity,\n  rpcNewBlockTagObjectWithNumber,\n  rpcNewBlockTagObjectWithHash,\n  rpcBlockTagName,\n])",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcNewBlockTag",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcNewBlockTag = t.TypeOf<typeof rpcNewBlockTag>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalRpcNewBlockTag",
      "kind": "VariableDeclaration",
      "signature": "optionalRpcNewBlockTag = optionalOrNullable(rpcNewBlockTag)",
      "doc": "",
      "tags": []
    },
    {
      "name": "OptionalRpcNewBlockTag",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OptionalRpcNewBlockTag = t.TypeOf<typeof optionalRpcNewBlockTag>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "rpcOldBlockTag",
      "kind": "VariableDeclaration",
      "signature": "rpcOldBlockTag = t.union([rpcQuantity, rpcBlockTagName])",
      "doc": "",
      "tags": []
    },
    {
      "name": "RpcOldBlockTag",
      "kind": "TypeAliasDeclaration",
      "signature": "export type RpcOldBlockTag = t.TypeOf<typeof rpcOldBlockTag>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "optionalRpcOldBlockTag",
      "kind": "VariableDeclaration",
      "signature": "optionalRpcOldBlockTag = optionalOrNullable(rpcOldBlockTag)",
      "doc": "",
      "tags": []
    },
    {
      "name": "OptionalRpcOldBlockTag",
      "kind": "TypeAliasDeclaration",
      "signature": "export type OptionalRpcOldBlockTag = t.TypeOf<typeof optionalRpcOldBlockTag>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "DEFAULT_SOLC_VERSION",
      "kind": "VariableDeclaration",
      "signature": "DEFAULT_SOLC_VERSION = \"0.7.3\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_DEFAULT_GAS_PRICE",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_DEFAULT_GAS_PRICE = \"auto\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_DEFAULT_MAX_PRIORITY_FEE_PER_GAS",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_DEFAULT_MAX_PRIORITY_FEE_PER_GAS = 1e9",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_DEFAULT_INITIAL_BASE_FEE_PER_GAS",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_DEFAULT_INITIAL_BASE_FEE_PER_GAS = 1e9",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_NETWORK_MNEMONIC",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_NETWORK_MNEMONIC =\n  \"test test test test test test test test test test test junk\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "DEFAULT_HARDHAT_NETWORK_BALANCE",
      "kind": "VariableDeclaration",
      "signature": "DEFAULT_HARDHAT_NETWORK_BALANCE = \"10000000000000000000000\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "defaultDefaultNetwork",
      "kind": "VariableDeclaration",
      "signature": "defaultDefaultNetwork = HARDHAT_NETWORK_NAME",
      "doc": "",
      "tags": []
    },
    {
      "name": "defaultLocalhostNetworkParams",
      "kind": "VariableDeclaration",
      "signature": "defaultLocalhostNetworkParams = {\n  url: \"http://127.0.0.1:8545\",\n  timeout: 40000,\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "defaultHdAccountsConfigParams",
      "kind": "VariableDeclaration",
      "signature": "defaultHdAccountsConfigParams = {\n  initialIndex: 0,\n  count: 20,\n  path: \"m/44'/60'/0'/0\",\n  passphrase: \"\",\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "defaultHardhatNetworkHdAccountsConfigParams",
      "kind": "VariableDeclaration",
      "signature": "defaultHardhatNetworkHdAccountsConfigParams = {\n  ...defaultHdAccountsConfigParams,\n  mnemonic: HARDHAT_NETWORK_MNEMONIC,\n  accountsBalance: DEFAULT_HARDHAT_NETWORK_BALANCE,\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "DEFAULT_GAS_MULTIPLIER",
      "kind": "VariableDeclaration",
      "signature": "DEFAULT_GAS_MULTIPLIER = 1",
      "doc": "",
      "tags": []
    },
    {
      "name": "defaultHardhatNetworkParams",
      "kind": "VariableDeclaration",
      "signature": "defaultHardhatNetworkParams: Omit<\n  HardhatNetworkConfig,\n  \"gas\" | \"initialDate\"\n> = {\n  hardfork: HardforkName.PRAGUE,\n  blockGasLimit: 30_000_000,\n  gasPrice: HARDHAT_NETWORK_DEFAULT_GAS_PRICE,\n  chainId: 31337,\n  throwOnTransactionFailures: true,\n  throwOnCallFailures: true,\n  allowUnlimitedCon",
      "doc": "",
      "tags": []
    },
    {
      "name": "defaultHttpNetworkParams",
      "kind": "VariableDeclaration",
      "signature": "defaultHttpNetworkParams = {\n  accounts: \"remote\" as \"remote\",\n  gas: \"auto\" as \"auto\",\n  gasPrice: \"auto\" as \"auto\",\n  gasMultiplier: DEFAULT_GAS_MULTIPLIER,\n  httpHeaders: {},\n  timeout: 20000,\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "defaultMochaOptions",
      "kind": "VariableDeclaration",
      "signature": "defaultMochaOptions: Mocha.MochaOptions = {\n  timeout: 40000,\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "defaultSolcOutputSelection",
      "kind": "VariableDeclaration",
      "signature": "defaultSolcOutputSelection = {\n  \"*\": {\n    \"*\": [\n      \"abi\",\n      \"evm.bytecode\",\n      \"evm.deployedBytecode\",\n      \"evm.methodIdentifiers\",\n      \"metadata\",\n    ],\n    \"\": [\"ast\"],\n  },\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure",
      "kind": "FunctionDeclaration",
      "signature": "export function failure(es: ValidationError[]): string[] {\n  return es.map(getMessage);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure._URI",
      "kind": "PropertySignature",
      "signature": "_URI: URI;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "failure._A",
      "kind": "PropertySignature",
      "signature": "_A: T;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "failure.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "failure.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "success",
      "kind": "FunctionDeclaration",
      "signature": "export function success(): string[] {\n  return [];\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "success._URI",
      "kind": "PropertySignature",
      "signature": "_URI: URI;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "success._A",
      "kind": "PropertySignature",
      "signature": "_A: T;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "success.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "success.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "validateConfig",
      "kind": "FunctionDeclaration",
      "signature": "export function validateConfig(config: any) {\n  const errors = getValidationErrors(config);\n\n  if (errors.length === 0) {\n    return;\n  }\n\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n\n  throw new HardhatError(ERRORS.GENERAL.INVALID_CONFIG, { errors: errorList });\n}",
      "doc": "Validates the config, throwing a HardhatError if invalid.",
      "tags": [
        {
          "tagName": "param",
          "text": ""
        }
      ]
    },
    {
      "name": "getValidationErrors",
      "kind": "FunctionDeclaration",
      "signature": "export function getValidationErrors(config: any): string[] {\n  const errors: string[] = [];\n\n  // These can't be validated with io-ts\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[HARDHAT_NETWORK_NAME];\n    if (hardhatNetwork !== unde",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors._URI",
      "kind": "PropertySignature",
      "signature": "_URI: URI;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "getValidationErrors._A",
      "kind": "PropertySignature",
      "signature": "_A: T;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "getValidationErrors.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getValidationErrors.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "validateResolvedConfig",
      "kind": "FunctionDeclaration",
      "signature": "export function validateResolvedConfig(resolvedConfig: HardhatConfigT) {\n  const solcConfigs = [\n    ...resolvedConfig.solidity.compilers,\n    ...Object.values(resolvedConfig.solidity.overrides),\n  ];\n  const runs = solcConfigs\n    .filter(({ settings }) => settings?.optimizer?.runs !== undefined)\n ",
      "doc": "",
      "tags": []
    },
    {
      "name": "DotPathReporter",
      "kind": "VariableDeclaration",
      "signature": "DotPathReporter: Reporter<string[]> = {\n  report: (validation) => validation.fold(failure, success),\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "hexString",
      "kind": "VariableDeclaration",
      "signature": "hexString = new t.Type<string>(\n  \"hex string\",\n  isHexString,\n  (u, c) => (isHexString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "address",
      "kind": "VariableDeclaration",
      "signature": "address = new t.Type<string>(\n  \"address\",\n  isAddress,\n  (u, c) => (isAddress(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "decimalString",
      "kind": "VariableDeclaration",
      "signature": "decimalString = new t.Type<string>(\n  \"decimal string\",\n  isDecimalString,\n  (u, c) => (isDecimalString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n)",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveConfig",
      "kind": "FunctionDeclaration",
      "signature": "export function resolveConfig(\n  userConfigPath: string,\n  userConfig: HardhatUserConfig\n): HardhatConfig {\n  const cloneDeep = require(\"lodash/cloneDeep\") as LoDashStatic[\"cloneDeep\"];\n  userConfig = cloneDeep(userConfig);\n\n  return {\n    ...userConfig,\n    defaultNetwork: userConfig.defaultNetwork",
      "doc": "This functions resolves the hardhat config, setting its defaults and\nnormalizing its types if necessary.",
      "tags": [
        {
          "tagName": "param",
          "text": "the user config filepath"
        },
        {
          "tagName": "param",
          "text": "the user config object"
        },
        {
          "tagName": "returns",
          "text": "the resolved config"
        }
      ]
    },
    {
      "name": "resolveConfig.defaultNetwork",
      "kind": "PropertySignature",
      "signature": "defaultNetwork: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveConfig.paths",
      "kind": "PropertySignature",
      "signature": "paths: ProjectPathsConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveConfig.networks",
      "kind": "PropertySignature",
      "signature": "networks: NetworksConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveConfig.solidity",
      "kind": "PropertySignature",
      "signature": "solidity: SolidityConfig;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveConfig.mocha",
      "kind": "PropertySignature",
      "signature": "mocha: Mocha.MochaOptions;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProjectPaths",
      "kind": "FunctionDeclaration",
      "signature": "export function resolveProjectPaths(\n  userConfigPath: string,\n  userPaths: ProjectPathsUserConfig = {}\n): ProjectPathsConfig {\n  const configFile = getRealPathSync(userConfigPath);\n  const configDir = path.dirname(configFile);\n\n  const root = resolvePathFrom(configDir, \"\", userPaths.root);\n\n  retur",
      "doc": "This function resolves the ProjectPathsConfig object from the user-provided config\nand its path. The logic of this is not obvious and should well be document.\nThe good thing is that most users will never use this.\n\nExplanation:\n   - paths.configFile is not overridable\n   - If a path is absolute it is used \"as is\".\n   - If the root path is relative, it's resolved from paths.configFile's dir.\n   - If any other path is relative, it's resolved from paths.root.\n   - Plugin-defined paths are not resolved, but encouraged to follow the same pattern.",
      "tags": []
    },
    {
      "name": "resolveProjectPaths.root",
      "kind": "PropertySignature",
      "signature": "root: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProjectPaths.configFile",
      "kind": "PropertySignature",
      "signature": "configFile: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProjectPaths.cache",
      "kind": "PropertySignature",
      "signature": "cache: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProjectPaths.artifacts",
      "kind": "PropertySignature",
      "signature": "artifacts: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProjectPaths.sources",
      "kind": "PropertySignature",
      "signature": "sources: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveProjectPaths.tests",
      "kind": "PropertySignature",
      "signature": "tests: string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "importCsjOrEsModule",
      "kind": "FunctionDeclaration",
      "signature": "export function importCsjOrEsModule(filePath: string): any {\n  try {\n    const imported = require(filePath);\n    return imported.default !== undefined ? imported.default : imported;\n  } catch (e: any) {\n    // An ESM project that has a Hardhat config with a .js extension will fail to be loaded,\n    ",
      "doc": "",
      "tags": []
    },
    {
      "name": "resolveConfigPath",
      "kind": "FunctionDeclaration",
      "signature": "export function resolveConfigPath(configPath: string | undefined) {\n  if (configPath === undefined) {\n    configPath = getUserConfigPath();\n  } else {\n    if (!path.isAbsolute(configPath)) {\n      configPath = path.join(process.cwd(), configPath);\n      configPath = path.normalize(configPath);\n    }",
      "doc": "",
      "tags": []
    },
    {
      "name": "loadConfigAndTasks",
      "kind": "FunctionDeclaration",
      "signature": "export function loadConfigAndTasks(\n  hardhatArguments?: Partial<HardhatArguments>,\n  {\n    showEmptyConfigWarning = false,\n    showSolidityConfigWarnings = false,\n  }: {\n    showEmptyConfigWarning?: boolean;\n    showSolidityConfigWarnings?: boolean;\n  } = {\n    showEmptyConfigWarning: false,\n    sh",
      "doc": "",
      "tags": []
    },
    {
      "name": "analyzeModuleNotFoundError",
      "kind": "FunctionDeclaration",
      "signature": "export function analyzeModuleNotFoundError(error: any, configPath: string) {\n  const stackTraceParser =\n    require(\"stacktrace-parser\") as typeof StackTraceParserT;\n\n  if (error.code !== \"MODULE_NOT_FOUND\") {\n    return;\n  }\n  const stackTrace = stackTraceParser.parse(error.stack);\n  const throwing",
      "doc": "Receives an Error and checks if it's a MODULE_NOT_FOUND and the reason that\ncaused it.\n\nIf it can infer the reason, it throws an appropriate error. Otherwise it does\nnothing.",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers",
      "kind": "FunctionDeclaration",
      "signature": "export function getConfiguredCompilers(\n  solidityConfig: HardhatConfig[\"solidity\"]\n): SolcConfig[] {\n  const compilerVersions = solidityConfig.compilers;\n  const overrideVersions = Object.values(solidityConfig.overrides);\n  return [...compilerVersions, ...overrideVersions];\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.length",
      "kind": "PropertySignature",
      "signature": "length:number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.toString",
      "kind": "MethodSignature",
      "signature": "toString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString():string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.pop",
      "kind": "MethodSignature",
      "signature": "pop():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.push",
      "kind": "MethodSignature",
      "signature": "push(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.concat",
      "kind": "MethodSignature",
      "signature": "concat(...items:ConcatArray<T>[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.join",
      "kind": "MethodSignature",
      "signature": "join(separator?:string):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.reverse",
      "kind": "MethodSignature",
      "signature": "reverse():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.shift",
      "kind": "MethodSignature",
      "signature": "shift():T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.slice",
      "kind": "MethodSignature",
      "signature": "slice(start?:number,end?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.sort",
      "kind": "MethodSignature",
      "signature": "sort(compareFn?:(a:T,b:T)=>number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.splice",
      "kind": "MethodSignature",
      "signature": "splice(start:number,deleteCount?:number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.unshift",
      "kind": "MethodSignature",
      "signature": "unshift(...items:T[]):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.indexOf",
      "kind": "MethodSignature",
      "signature": "indexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.lastIndexOf",
      "kind": "MethodSignature",
      "signature": "lastIndexOf(searchElement:T,fromIndex?:number):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.every",
      "kind": "MethodSignature",
      "signature": "every<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):this is S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.some",
      "kind": "MethodSignature",
      "signature": "some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.forEach",
      "kind": "MethodSignature",
      "signature": "forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.map",
      "kind": "MethodSignature",
      "signature": "map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.filter",
      "kind": "MethodSignature",
      "signature": "filter<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.reduce",
      "kind": "MethodSignature",
      "signature": "reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.reduceRight",
      "kind": "MethodSignature",
      "signature": "reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.find",
      "kind": "MethodSignature",
      "signature": "find<S extends T>(predicate:(value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.findIndex",
      "kind": "MethodSignature",
      "signature": "findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.fill",
      "kind": "MethodSignature",
      "signature": "fill(value:T,start?:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.copyWithin",
      "kind": "MethodSignature",
      "signature": "copyWithin(target:number,start:number,end?:number):this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.entries",
      "kind": "MethodSignature",
      "signature": "entries():ArrayIterator<[number,T]>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.keys",
      "kind": "MethodSignature",
      "signature": "keys():ArrayIterator<number>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.values",
      "kind": "MethodSignature",
      "signature": "values():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.includes",
      "kind": "MethodSignature",
      "signature": "includes(searchElement:T,fromIndex?:number):boolean;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.flatMap",
      "kind": "MethodSignature",
      "signature": "flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This,):U[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.flat",
      "kind": "MethodSignature",
      "signature": "flat<A,D extends number=1>(this:A,depth?:D,):FlatArray<A,D>[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.at",
      "kind": "MethodSignature",
      "signature": "at(index:number):T|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.findLast",
      "kind": "MethodSignature",
      "signature": "findLast<S extends T>(predicate:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S|undefined;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.findLastIndex",
      "kind": "MethodSignature",
      "signature": "findLastIndex(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any):number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.toReversed",
      "kind": "MethodSignature",
      "signature": "toReversed():T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.toSorted",
      "kind": "MethodSignature",
      "signature": "toSorted(compareFn?:(a:T,b:T)=>number):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.toSpliced",
      "kind": "MethodSignature",
      "signature": "toSpliced(start:number,deleteCount:number,...items:T[]):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.with",
      "kind": "MethodSignature",
      "signature": "with(index:number,value:T):T[];",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers._URI",
      "kind": "PropertySignature",
      "signature": "_URI: URI;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers._A",
      "kind": "PropertySignature",
      "signature": "_A: T;",
      "doc": "phantom property added by `fp-ts`",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.__@iterator@100",
      "kind": "MethodSignature",
      "signature": "[Symbol.iterator]():ArrayIterator<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getConfiguredCompilers.__@unscopables@102",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.unscopables]:{[K in keyof any[]]?:boolean;};",
      "doc": "",
      "tags": []
    },
    {
      "name": "task",
      "kind": "FunctionDeclaration",
      "signature": "export function task<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  description?: string,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;",
      "doc": "Creates a task, overriding any previous task with the same name.",
      "tags": [
        {
          "tagName": "remarks",
          "text": "The action must await every async call made within it."
        },
        {
          "tagName": "param",
          "text": "The task's name."
        },
        {
          "tagName": "param",
          "text": "The task's description."
        },
        {
          "tagName": "param",
          "text": "The task's action."
        },
        {
          "tagName": "returns",
          "text": "A task definition."
        }
      ]
    },
    {
      "name": "task.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task",
      "kind": "FunctionDeclaration",
      "signature": "export function task<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  action: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;",
      "doc": "Creates a task without description, overriding any previous task\nwith the same name.",
      "tags": [
        {
          "tagName": "remarks",
          "text": "The action must await every async call made within it."
        },
        {
          "tagName": "param",
          "text": "The task's name."
        },
        {
          "tagName": "param",
          "text": "The task's action."
        },
        {
          "tagName": "returns",
          "text": "A task definition."
        }
      ]
    },
    {
      "name": "task.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task",
      "kind": "FunctionDeclaration",
      "signature": "export function task<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition {\n  const ctx = HardhatContext.getHardhatContext();\n  const dsl = ctx.tasksDSL;\n\n  if (descript",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "task.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask",
      "kind": "FunctionDeclaration",
      "signature": "export function subtask<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  description?: string,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;",
      "doc": "Creates a subtask, overriding any previous task with the same name.",
      "tags": [
        {
          "tagName": "remarks",
          "text": "The subtasks won't be displayed in the CLI help messages."
        },
        {
          "tagName": "remarks",
          "text": "The action must await every async call made within it."
        },
        {
          "tagName": "param",
          "text": "The task's name."
        },
        {
          "tagName": "param",
          "text": "The task's description."
        },
        {
          "tagName": "param",
          "text": "The task's action."
        },
        {
          "tagName": "returns",
          "text": "A task definition."
        }
      ]
    },
    {
      "name": "subtask.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask",
      "kind": "FunctionDeclaration",
      "signature": "export function subtask<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  action: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;",
      "doc": "Creates a subtask without description, overriding any previous\ntask with the same name.",
      "tags": [
        {
          "tagName": "remarks",
          "text": "The subtasks won't be displayed in the CLI help messages."
        },
        {
          "tagName": "remarks",
          "text": "The action must await every async call made within it."
        },
        {
          "tagName": "param",
          "text": "The task's name."
        },
        {
          "tagName": "param",
          "text": "The task's action."
        },
        {
          "tagName": "returns",
          "text": "A task definition."
        }
      ]
    },
    {
      "name": "subtask.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask",
      "kind": "FunctionDeclaration",
      "signature": "export function subtask<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition {\n  const ctx = HardhatContext.getHardhatContext();\n  const dsl = ctx.tasksDSL;\n\n  if (descr",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.setAction",
      "kind": "MethodSignature",
      "signature": "setAction(action: ActionType<TaskArguments>): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addParam",
      "kind": "MethodSignature",
      "signature": "addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addPositionalParam",
      "kind": "MethodSignature",
      "signature": "addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addOptionalVariadicPositionalParam",
      "kind": "MethodSignature",
      "signature": "addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "subtask.addFlag",
      "kind": "MethodSignature",
      "signature": "addFlag(name: string, description?: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scope",
      "kind": "FunctionDeclaration",
      "signature": "export function scope(\n  name: string,\n  description?: string\n): ConfigurableScopeDefinition {\n  const ctx = HardhatContext.getHardhatContext();\n  const dsl = ctx.tasksDSL;\n\n  return dsl.scope(name, description);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "scope.setDescription",
      "kind": "MethodSignature",
      "signature": "setDescription(description: string): this;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scope.task",
      "kind": "PropertySignature",
      "signature": "task: AddConfigurableTaskFunction;",
      "doc": "",
      "tags": []
    },
    {
      "name": "scope.subtask",
      "kind": "PropertySignature",
      "signature": "subtask: AddConfigurableTaskFunction;",
      "doc": "",
      "tags": []
    },
    {
      "name": "extendEnvironment",
      "kind": "FunctionDeclaration",
      "signature": "export function extendEnvironment(extender: EnvironmentExtender) {\n  const ctx = HardhatContext.getHardhatContext();\n  ctx.environmentExtenders.push(extender);\n}",
      "doc": "Register an environment extender what will be run after the\nHardhat Runtime Environment is initialized.",
      "tags": [
        {
          "tagName": "param",
          "text": "A function that receives the Hardhat Runtime\nEnvironment."
        }
      ]
    },
    {
      "name": "extendConfig",
      "kind": "FunctionDeclaration",
      "signature": "export function extendConfig(extender: ConfigExtender) {\n  const ctx = HardhatContext.getHardhatContext();\n  ctx.configExtenders.push(extender);\n}",
      "doc": "Register a config extender what will be run after the\nHardhat Runtime Environment is initialized.",
      "tags": [
        {
          "tagName": "param",
          "text": "A function that receives the resolved config\nto be modified and the config provided by the user"
        }
      ]
    },
    {
      "name": "extendProvider",
      "kind": "FunctionDeclaration",
      "signature": "export function extendProvider(extender: ProviderExtender) {\n  const ctx = HardhatContext.getHardhatContext();\n  ctx.providerExtenders.push(extender);\n}",
      "doc": "Register a provider extender what will be run after the\nHardhat Runtime Environment is initialized.",
      "tags": [
        {
          "tagName": "param",
          "text": "A function that receives the current provider\nand returns a new one."
        }
      ]
    },
    {
      "name": "internalTask",
      "kind": "VariableDeclaration",
      "signature": "internalTask = subtask",
      "doc": "",
      "tags": []
    },
    {
      "name": "types",
      "kind": "VariableDeclaration",
      "signature": "types = argumentTypes",
      "doc": "",
      "tags": []
    },
    {
      "name": "vars",
      "kind": "VariableDeclaration",
      "signature": "vars = {\n  has: hasVar,\n  get: getVar,\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "showNewVersionNotification",
      "kind": "FunctionDeclaration",
      "signature": "export async function showNewVersionNotification() {\n  const cache = await readCache();\n\n  const lastCheckDate = new Date(cache.lastCheck);\n  const now = new Date();\n  const oneDay = 1000 * 60 * 60 * 24;\n\n  if (now.getTime() - lastCheckDate.getTime() < oneDay) {\n    return;\n  }\n\n  const hardhatVersi",
      "doc": "",
      "tags": []
    },
    {
      "name": "showNewVersionNotification.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "showNewVersionNotification.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "showNewVersionNotification.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "showNewVersionNotification.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "handleVars",
      "kind": "FunctionDeclaration",
      "signature": "export async function handleVars(\n  allUnparsedCLAs: string[],\n  configPath: string | undefined\n): Promise<number> {\n  const { taskDefinition, taskArguments } =\n    await getTaskDefinitionAndTaskArguments(allUnparsedCLAs);\n\n  switch (taskDefinition.name) {\n    case \"set\":\n      return set(taskArgume",
      "doc": "",
      "tags": []
    },
    {
      "name": "handleVars.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "handleVars.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "handleVars.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "handleVars.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "Dependencies",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Dependencies {\n  [name: string]: string;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "PackageManager",
      "kind": "TypeAliasDeclaration",
      "signature": "export type PackageManager = \"npm\" | \"yarn\" | \"pnpm\";",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmRecommendedDepsInstallation",
      "kind": "FunctionDeclaration",
      "signature": "export async function confirmRecommendedDepsInstallation(\n  depsToInstall: Dependencies,\n  packageManager: PackageManager\n): Promise<boolean> {\n  const { default: enquirer } = await import(\"enquirer\");\n\n  let responses: {\n    shouldInstallPlugin: boolean;\n  };\n\n  try {\n    responses = await enquirer",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmRecommendedDepsInstallation.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmRecommendedDepsInstallation.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmRecommendedDepsInstallation.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmRecommendedDepsInstallation.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmProjectCreation",
      "kind": "FunctionDeclaration",
      "signature": "export async function confirmProjectCreation(): Promise<{\n  projectRoot: string;\n  shouldAddGitIgnore: boolean;\n}> {\n  const enquirer = require(\"enquirer\");\n  return enquirer.prompt([\n    {\n      name: \"projectRoot\",\n      type: \"input\",\n      initial: process.cwd(),\n      message: \"Hardhat project ",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmProjectCreation.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmProjectCreation.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmProjectCreation.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmProjectCreation.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmTelemetryConsent",
      "kind": "FunctionDeclaration",
      "signature": "export async function confirmTelemetryConsent(): Promise<boolean | undefined> {\n  return confirmationPromptWithTimeout(\n    \"telemetryConsent\",\n    \"Help us improve Hardhat with anonymous crash reports & basic usage data?\"\n  );\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmTelemetryConsent.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmTelemetryConsent.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmTelemetryConsent.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmTelemetryConsent.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmHHVSCodeInstallation",
      "kind": "FunctionDeclaration",
      "signature": "export async function confirmHHVSCodeInstallation(): Promise<\n  boolean | undefined\n> {\n  return confirmationPromptWithTimeout(\n    \"shouldInstallExtension\",\n    \"Would you like to install the Hardhat for Visual Studio Code extension? It adds advanced editing assistance for Solidity to VSCode\"\n  );\n",
      "doc": "true = install ext\nfalse = don't install and don't ask again\nundefined = we couldn't confirm if the extension is installed or not",
      "tags": []
    },
    {
      "name": "confirmHHVSCodeInstallation.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmHHVSCodeInstallation.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmHHVSCodeInstallation.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "confirmHHVSCodeInstallation.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "showSoliditySurveyMessage",
      "kind": "FunctionDeclaration",
      "signature": "export function showSoliditySurveyMessage() {\n  if (new Date() > new Date(\"2025-01-31 23:39\")) {\n    // the survey has finished\n    return;\n  }\n\n  console.log();\n  console.log(\n    picocolors.cyan(\n      \"Please take a moment to complete the 2024 Solidity Survey: https://hardhat.org/solidity-survey-",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProject",
      "kind": "FunctionDeclaration",
      "signature": "export async function createProject() {\n  printAsciiLogo();\n\n  await printWelcomeMessage();\n\n  let packageJson: PackageJson | undefined;\n  if (await fsExtra.pathExists(\"package.json\")) {\n    packageJson = await fsExtra.readJson(\"package.json\");\n  }\n  const isEsm = packageJson?.type === \"module\";\n\n  ",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProject.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProject.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProject.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "createProject.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "EMPTY_HARDHAT_CONFIG",
      "kind": "VariableDeclaration",
      "signature": "EMPTY_HARDHAT_CONFIG = `/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n  solidity: \"0.8.28\",\n};\n`",
      "doc": "",
      "tags": []
    },
    {
      "name": "isNodeVersionToWarnOn",
      "kind": "FunctionDeclaration",
      "signature": "export function isNodeVersionToWarnOn(nodeVersion: string): boolean {\n  const supportedVersions = SUPPORTED_NODE_VERSIONS.join(\" || \");\n\n  // If the version is supported, no need to warn and short circuit\n  if (semver.satisfies(nodeVersion, supportedVersions)) {\n    return false;\n  }\n\n  if (_onOddNu",
      "doc": "Determine if the node version should trigger an unsupported\nwarning.\n\nThe current rule is that an unsupported warning will be shown if\n\n1. An odd numbered version of Node.js is used - as this will never go to LTS\n2. The version is less than the minimum supported version\n\nWe intentionally do not warn on newer **even** versions of Node.js.",
      "tags": []
    },
    {
      "name": "isHardhatVSCodeInstalled",
      "kind": "FunctionDeclaration",
      "signature": "export function isHardhatVSCodeInstalled(): InstallationState {\n  try {\n    const { stdout, status } = spawnSync(\"code\", [\"--list-extensions\"], {\n      encoding: \"utf8\",\n    });\n\n    if (status !== 0) {\n      return InstallationState.VSCODE_FAILED_OR_NOT_INSTALLED;\n    }\n\n    return stdout.includes(",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHardhatVSCodeInstalled.toString",
      "kind": "MethodSignature",
      "signature": "toString(radix?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHardhatVSCodeInstalled.toFixed",
      "kind": "MethodSignature",
      "signature": "toFixed(fractionDigits?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHardhatVSCodeInstalled.toExponential",
      "kind": "MethodSignature",
      "signature": "toExponential(fractionDigits?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHardhatVSCodeInstalled.toPrecision",
      "kind": "MethodSignature",
      "signature": "toPrecision(precision?:number):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHardhatVSCodeInstalled.valueOf",
      "kind": "MethodSignature",
      "signature": "valueOf():number;",
      "doc": "",
      "tags": []
    },
    {
      "name": "isHardhatVSCodeInstalled.toLocaleString",
      "kind": "MethodSignature",
      "signature": "toLocaleString(locales?:string|string[],options?:Intl.NumberFormatOptions):string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "installHardhatVSCode",
      "kind": "FunctionDeclaration",
      "signature": "export function installHardhatVSCode(): boolean {\n  try {\n    const { status } = spawnSync(\n      \"code\",\n      [\"--install-extension\", HARDHAT_VSCODE_ID],\n      {\n        encoding: \"utf8\",\n      }\n    );\n\n    return status === 0;\n  } catch (e) {\n    return false;\n  }\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "InstallationState",
      "kind": "EnumDeclaration",
      "signature": "export enum InstallationState {\n  VSCODE_FAILED_OR_NOT_INSTALLED,\n  EXTENSION_INSTALLED,\n  EXTENSION_NOT_INSTALLED,\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "enableEmoji",
      "kind": "FunctionDeclaration",
      "signature": "export function enableEmoji() {\n  emojiEnabled = true;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "emoji",
      "kind": "FunctionDeclaration",
      "signature": "export function emoji(msgIfEnabled: string, msgIfDisabled: string = \"\") {\n  return emojiEnabled ? msgIfEnabled : msgIfDisabled;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SUPPORTED_NODE_VERSIONS",
      "kind": "VariableDeclaration",
      "signature": "SUPPORTED_NODE_VERSIONS = [\"^20.0.0\", \"^22.0.0\", \"^24.0.0\"]",
      "doc": "",
      "tags": []
    },
    {
      "name": "BannerManager",
      "kind": "ClassDeclaration",
      "signature": "export class BannerManager {\n  private static _instance: BannerManager | undefined;\n\n  private constructor(\n    private _bannerConfig: BannerConfig | undefined,\n    private _lastDisplayTime: number,\n    private _lastRequestTime: number\n  ) {}\n\n  public static async getInstance(): Promise<BannerManag",
      "doc": "",
      "tags": []
    },
    {
      "name": "complete",
      "kind": "FunctionDeclaration",
      "signature": "export async function complete({\n  line,\n  point,\n}: CompletionEnv): Promise<Suggestion[] | typeof HARDHAT_COMPLETE_FILES> {\n  const completionData = await getCompletionData();\n\n  if (completionData === undefined) {\n    return [];\n  }\n\n  const { networks, tasks, scopes } = completionData;\n\n  const w",
      "doc": "",
      "tags": []
    },
    {
      "name": "complete.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "complete.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "complete.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "complete.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "HARDHAT_COMPLETE_FILES",
      "kind": "VariableDeclaration",
      "signature": "HARDHAT_COMPLETE_FILES = \"__hardhat_complete_files__\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "REQUIRED_HH_VERSION_RANGE",
      "kind": "VariableDeclaration",
      "signature": "REQUIRED_HH_VERSION_RANGE = \"^1.0.0\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestTelemetryConsent",
      "kind": "FunctionDeclaration",
      "signature": "export async function requestTelemetryConsent() {\n  const telemetryConsent = await confirmTelemetryConsent();\n\n  if (telemetryConsent === undefined) {\n    return;\n  }\n\n  writeTelemetryConsent(telemetryConsent);\n\n  const reportTelemetryConsentPath = join(\n    __dirname,\n    \"..\",\n    \"util\",\n    \"rep",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestTelemetryConsent.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestTelemetryConsent.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestTelemetryConsent.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "requestTelemetryConsent.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "Analytics",
      "kind": "ClassDeclaration",
      "signature": "export class Analytics {\n  public static async getInstance(telemetryConsent: boolean | undefined) {\n    const analytics: Analytics = new Analytics(\n      await getClientId(),\n      telemetryConsent,\n      getUserType()\n    );\n\n    return analytics;\n  }\n\n  private readonly _clientId: string;\n  privat",
      "doc": "",
      "tags": []
    },
    {
      "name": "HelpPrinter",
      "kind": "ClassDeclaration",
      "signature": "export class HelpPrinter {\n  constructor(\n    private readonly _programName: string,\n    private readonly _executableName: string,\n    private readonly _version: string,\n    private readonly _hardhatParamDefinitions: HardhatParamDefinitions,\n    private readonly _tasks: TasksMap,\n    private readonl",
      "doc": "",
      "tags": []
    },
    {
      "name": "ArgumentsParser",
      "kind": "ClassDeclaration",
      "signature": "export class ArgumentsParser {\n  public static readonly PARAM_PREFIX = \"--\";\n\n  public static paramNameToCLA(paramName: string): string {\n    return (\n      ArgumentsParser.PARAM_PREFIX +\n      paramName\n        .split(/(?=[A-Z])/g)\n        .map((s) => s.toLowerCase())\n        .join(\"-\")\n    );\n  }\n",
      "doc": "",
      "tags": []
    },
    {
      "name": "requireNapiRsModule",
      "kind": "FunctionDeclaration",
      "signature": "export function requireNapiRsModule(id: string): unknown {\n  try {\n    return require(id);\n  } catch (e: any) {\n    if (e.code === \"MODULE_NOT_FOUND\") {\n      throw new HardhatError(ERRORS.GENERAL.CORRUPTED_LOCKFILE);\n    }\n\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/onl",
      "doc": "",
      "tags": []
    },
    {
      "name": "CustomError",
      "kind": "ClassDeclaration",
      "signature": "export class CustomError extends Error {\n  private _stack: string;\n\n  constructor(message: string, public readonly parent?: Error) {\n    // WARNING: Using super when extending a builtin class doesn't work well\n    // with TS if you are compiling to a version of JavaScript that doesn't have\n    // na",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeToBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function normalizeToBigInt(\n  source:\n    | number\n    | bigint\n    | BNType\n    | EthersBigNumberType\n    | BigNumberJsType\n    | string\n): bigint {\n  switch (typeof source) {\n    case \"object\":\n      if (isBigNumber(source)) {\n        return BigInt(source.toString());\n      } else {\n       ",
      "doc": "",
      "tags": []
    },
    {
      "name": "isBigNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function isBigNumber(source: any): boolean {\n  return (\n    typeof source === \"bigint\" ||\n    isEthersBigNumber(source) ||\n    isBN(source) ||\n    isBigNumberJsBigNumber(source)\n  );\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatNumberType",
      "kind": "FunctionDeclaration",
      "signature": "export function formatNumberType(\n  n: string | bigint | BNType | EthersBigNumberType | BigNumberJsType\n): string {\n  if (typeof n === \"object\") {\n    if (isBN(n)) {\n      return \"BN\";\n    } else if (isEthersBigNumber(n)) {\n      return \"ethers.BigNumber\";\n    } else if (isBigNumberJsBigNumber(n)) {",
      "doc": "",
      "tags": []
    },
    {
      "name": "normalizeToBigInt",
      "kind": "FunctionDeclaration",
      "signature": "export function normalizeToBigInt(\n  source:\n    | number\n    | bigint\n    | BNType\n    | EthersBigNumberType\n    | BigNumberJsType\n    | string\n): bigint {\n  switch (typeof source) {\n    case \"object\":\n      if (isBigNumber(source)) {\n        return BigInt(source.toString());\n      } else {\n       ",
      "doc": "",
      "tags": []
    },
    {
      "name": "isBigNumber",
      "kind": "FunctionDeclaration",
      "signature": "export function isBigNumber(source: any): boolean {\n  return (\n    typeof source === \"bigint\" ||\n    isEthersBigNumber(source) ||\n    isBN(source) ||\n    isBigNumberJsBigNumber(source)\n  );\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "formatNumberType",
      "kind": "FunctionDeclaration",
      "signature": "export function formatNumberType(\n  n: string | bigint | BNType | EthersBigNumberType | BigNumberJsType\n): string {\n  if (typeof n === \"object\") {\n    if (isBN(n)) {\n      return \"BN\";\n    } else if (isEthersBigNumber(n)) {\n      return \"ethers.BigNumber\";\n    } else if (isBigNumberJsBigNumber(n)) {",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_CHECK",
      "kind": "VariableDeclaration",
      "signature": "TASK_CHECK = \"check\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_CLEAN",
      "kind": "VariableDeclaration",
      "signature": "TASK_CLEAN = \"clean\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_CLEAN_GLOBAL",
      "kind": "VariableDeclaration",
      "signature": "TASK_CLEAN_GLOBAL = \"clean:global\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE = \"compile\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_GET_COMPILATION_TASKS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_GET_COMPILATION_TASKS =\n  \"compile:get-compilation-tasks\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY = \"compile:solidity\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS =\n  \"compile:solidity:get-source-paths\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES =\n  \"compile:solidity:get-source-names\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_READ_FILE",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_READ_FILE = \"compile:solidity:read-file\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_TRANSFORM_IMPORT_NAME",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_TRANSFORM_IMPORT_NAME =\n  \"compile:solidity:transform-import-name\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_GET_REMAPPINGS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_GET_REMAPPINGS = \"compile:solidity:get-remappings\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH =\n  \"compile:solidity:get-dependency-graph\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS =\n  \"compile:solidity:get-compilation-jobs\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE =\n  \"compile:solidity:get-compilation-job-for-file\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS =\n  \"compile:solidity:filter-compilation-jobs\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS =\n  \"compile:solidity:merge-compilation-jobs\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE =\n  \"compile:solidity:log:nothing-to-compile\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_COMPILE_JOB",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_COMPILE_JOB = \"compile:solidity:compile-job\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START =\n  \"compile:solidity:log:run-compiler-start\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END =\n  \"compile:solidity:log:run-compiler-end\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_COMPILE_JOBS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_COMPILE_JOBS =\n  \"compile:solidity:compile-jobs\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT =\n  \"compile:solidity:get-compiler-input\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_COMPILE",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_COMPILE = \"compile:solidity:compile\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_COMPILE_SOLC",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_COMPILE_SOLC =\n  \"compile:solidity:solc:compile\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD =\n  \"compile:solidity:solc:get-build\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START =\n  \"compile:solidity:log:download-compiler-start\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END =\n  \"compile:solidity:log:download-compiler-end\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_RUN_SOLCJS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_RUN_SOLCJS = \"compile:solidity:solcjs:run\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_RUN_SOLC",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_RUN_SOLC = \"compile:solidity:solc:run\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_CHECK_ERRORS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_CHECK_ERRORS =\n  \"compile:solidity:check-errors\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS =\n  \"compile:solidity:log:compilation-errors\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS =\n  \"compile:solidity:emit-artifacts\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT =\n  \"compile:solidity:get-artifact-from-compilation-output\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES =\n  \"compile:solidity:handle-compilation-jobs-failures\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS =\n  \"compile:solidity:get-compilation-jobs-failure-reasons\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT =\n  \"compile:solidity:log:compilation-result\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS",
      "kind": "VariableDeclaration",
      "signature": "TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS =\n  \"compile:remove-obsolete-artifacts\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_CONSOLE",
      "kind": "VariableDeclaration",
      "signature": "TASK_CONSOLE = \"console\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_FLATTEN",
      "kind": "VariableDeclaration",
      "signature": "TASK_FLATTEN = \"flatten\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_FLATTEN_GET_FLATTENED_SOURCE",
      "kind": "VariableDeclaration",
      "signature": "TASK_FLATTEN_GET_FLATTENED_SOURCE =\n  \"flatten:get-flattened-sources\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA",
      "kind": "VariableDeclaration",
      "signature": "TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA =\n  \"flatten:get-flattened-sources-and-metadata\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_FLATTEN_GET_DEPENDENCY_GRAPH",
      "kind": "VariableDeclaration",
      "signature": "TASK_FLATTEN_GET_DEPENDENCY_GRAPH = \"flatten:get-dependency-graph\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_HELP",
      "kind": "VariableDeclaration",
      "signature": "TASK_HELP = \"help\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_RUN",
      "kind": "VariableDeclaration",
      "signature": "TASK_RUN = \"run\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_NODE",
      "kind": "VariableDeclaration",
      "signature": "TASK_NODE = \"node\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_NODE_GET_PROVIDER",
      "kind": "VariableDeclaration",
      "signature": "TASK_NODE_GET_PROVIDER = \"node:get-provider\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_NODE_CREATE_SERVER",
      "kind": "VariableDeclaration",
      "signature": "TASK_NODE_CREATE_SERVER = \"node:create-server\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_NODE_SERVER_CREATED",
      "kind": "VariableDeclaration",
      "signature": "TASK_NODE_SERVER_CREATED = \"node:server-created\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_NODE_SERVER_READY",
      "kind": "VariableDeclaration",
      "signature": "TASK_NODE_SERVER_READY = \"node:server-ready\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_TEST",
      "kind": "VariableDeclaration",
      "signature": "TASK_TEST = \"test\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS",
      "kind": "VariableDeclaration",
      "signature": "TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS =\n  \"test:show-fork-recommendations\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_TEST_RUN_MOCHA_TESTS",
      "kind": "VariableDeclaration",
      "signature": "TASK_TEST_RUN_MOCHA_TESTS = \"test:run-mocha-tests\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_TEST_GET_TEST_FILES",
      "kind": "VariableDeclaration",
      "signature": "TASK_TEST_GET_TEST_FILES = \"test:get-test-files\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "TASK_TEST_SETUP_TEST_ENVIRONMENT",
      "kind": "VariableDeclaration",
      "signature": "TASK_TEST_SETUP_TEST_ENVIRONMENT = \"test:setup-test-environment\"",
      "doc": "",
      "tags": []
    },
    {
      "name": "watchCompilerOutput",
      "kind": "FunctionDeclaration",
      "signature": "export async function watchCompilerOutput(\n  provider: EIP1193Provider,\n  paths: ProjectPathsConfig\n): Promise<Watcher> {\n  const chokidar = await import(\"chokidar\");\n\n  const buildInfoDir = path.join(paths.artifacts, BUILD_INFO_DIR_NAME);\n\n  const addCompilationResult = async (buildInfo: string) =>",
      "doc": "",
      "tags": []
    },
    {
      "name": "watchCompilerOutput.then",
      "kind": "MethodSignature",
      "signature": "then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "watchCompilerOutput.catch",
      "kind": "MethodSignature",
      "signature": "catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "watchCompilerOutput.finally",
      "kind": "MethodSignature",
      "signature": "finally(onfinally?:(()=>void)|undefined|null):Promise<T>;",
      "doc": "",
      "tags": []
    },
    {
      "name": "watchCompilerOutput.__@toStringTag@13",
      "kind": "PropertySignature",
      "signature": "readonly[Symbol.toStringTag]:string;",
      "doc": "",
      "tags": []
    },
    {
      "name": "Watcher",
      "kind": "TypeAliasDeclaration",
      "signature": "export type Watcher = FSWatcher;",
      "doc": "",
      "tags": []
    },
    {
      "name": "getSolidityFilesCachePath",
      "kind": "FunctionDeclaration",
      "signature": "export function getSolidityFilesCachePath(paths: ProjectPathsConfig): string {\n  return path.join(paths.cache, SOLIDITY_FILES_CACHE_FILENAME);\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "CacheEntry",
      "kind": "InterfaceDeclaration",
      "signature": "export interface CacheEntry {\n  lastModificationDate: number;\n  contentHash: string;\n  sourceName: string;\n  solcConfig: SolcConfig;\n  imports: string[];\n  versionPragmas: string[];\n  artifacts: string[];\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "Cache",
      "kind": "InterfaceDeclaration",
      "signature": "export interface Cache {\n  _format: string;\n  files: Record<string, CacheEntry>;\n}",
      "doc": "",
      "tags": []
    },
    {
      "name": "SolidityFilesCache",
      "kind": "ClassDeclaration",
      "signature": "export class SolidityFilesCache {\n  public static createEmpty(): SolidityFilesCache {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  public static async readFromFile(\n    solidityFilesCachePath: string\n  ): Promise<SolidityFilesCache> {\n    let cac",
      "doc": "",
      "tags": []
    }
  ]
}
