meta:
  spec_name: monad-protocol-docs
  spec_version: 0.3.0
  library_name: Monad Protocol Documentation
  library_version: v0.10.x
  language: solidity
  homepage: https://docs.monad.xyz/
  generated: 2025-09-03
  tags: [blockchain, L1, EVM, high-performance, solidity, parallel execution, asynchronous execution]
  purpose: >
    A comprehensive guide for developers building on Monad, a high-performance, Ethereum-compatible L1 blockchain. This pack covers network details, key architectural differences from Ethereum (such as parallel execution and gas limit billing), transaction handling, and best practices for developing efficient decentralized applications.
  guiding_principles:
    - >
      **EVM Equivalence, Enhanced Performance:** Monad maintains full EVM bytecode equivalence (Pectra fork). Existing Solidity/Vyper contracts deploy seamlessly, but benefit from significantly higher throughput (10,000 TPS) and faster finality (800ms).
    - >
      **CRITICAL: Understand Gas Limit Billing:** Unlike Ethereum, Monad charges the `gas_limit` specified in a transaction, not the `gas_used`. This is crucial for DOS prevention in asynchronous execution. Always set accurate gas limits.
    - >
      **Parallelism is Transparent:** Developers do not need to modify contracts for parallel execution. Monad ensures the final state matches serial execution, handling dependencies internally.
    - >
      **Optimize Data Retrieval:** Utilize batch requests (like Multicall or batched JSON-RPC) for `eth_call` operations to reduce latency. Avoid serial requests.
    - >
      **Leverage Indexers for Historical State:** Due to high throughput, full nodes prune historical state aggressively. Use indexers (The Graph, Goldsky, Envio, etc.) for querying extensive historical data or derived state.
    - >
      **Manage Nonces Locally for High Frequency:** If sending transactions rapidly from the same account, track nonces locally rather than relying on `eth_getTransactionCount`, which only updates post-finalization.
    - >
      **Embrace Fast Finality:** Blocks finalize in 800ms (2 blocks). Speculative finality occurs in 400ms (1 block). Design UIs to reflect this rapid confirmation time.
  design_notes: >
    This knowledge pack is derived from the official Monad documentation (docs.monad.xyz). As Monad is a protocol rather than an SDK, 'symbols' represent key network parameters, architectural constants, configuration details, and documented behavioral differences from Ethereum. Definitions utilize JSON/YAML for configuration and text for conceptual parameters.

# ===================================================================
# 1 • Network Information and Configuration
# ===================================================================
groups:
  - group: Network Information
    description: Details required to connect to and interact with the Monad Testnet.
    symbols:
      - symbol: Testnet Configuration
        kind: configuration
        summary: The essential parameters for connecting to the Monad Public Testnet.
        definition:
          code: |
            {
              "Network Name": "Monad Testnet",
              "Chain ID": 10143,
              "Currency Symbol": "MON",
              "Block Explorer": "https://testnet.monadexplorer.com",
              "Faucet": "https://faucet.monad.xyz"
            }
          lang: json
        guidance:
          - Use these parameters when adding Monad Testnet to wallets (like MetaMask or Phantom) or configuring SDKs (like viem or ethers.js).
          - Ensure the Chain ID (10143) is correctly specified to prevent transaction replay attacks (as per EIP-155).
        example:
          description: Configuring a viem chain definition for Monad Testnet.
          code: |
            import { defineChain } from 'viem'

            export const monadTestnet = defineChain({
              id: 10143,
              name: 'Monad Testnet',
              nativeCurrency: {
                decimals: 18,
                name: 'Monad',
                symbol: 'MON',
              },
              rpcUrls: {
                default: { http: ['https://testnet-rpc.monad.xyz'] },
              },
              blockExplorers: {
                default: { name: 'MonadExplorer', url: 'https://testnet.monadexplorer.com' },
              },
            })
          lang: javascript

      - symbol: Public RPC Endpoints
        kind: resource
        summary: List of public RPC endpoints available for the Monad Testnet.
        definition:
          code: |
            - Provider: QuickNode
              HTTP: https://testnet-rpc.monad.xyz
              WSS: wss://testnet-rpc.monad.xyz
              Rate Limits: 25 reqs/sec
              Batch Limit: 100

            - Provider: Ankr
              HTTP: https://rpc.ankr.com/monad_testnet
              Rate Limits: 300 reqs/10 sec
              Batch Limit: 100
              Notes: debug_* methods are not allowed

            - Provider: Monad Foundation
              HTTP: https://rpc-testnet.monadinfra.com
              WSS: wss://rpc-testnet.monadinfra.com
              Rate Limits: 20 reqs/sec
              Batch Limit: Not allowed
              Notes: eth_getLogs and debug_* methods are not allowed
          lang: yaml
        guidance:
          - Select an RPC based on required methods (e.g., `debug_*`), rate limits, and batching support.
          - For high-volume applications, it is recommended to use a private, dedicated RPC endpoint.
          - WebSocket endpoints (wss://) are required for real-time event subscriptions (e.g., `eth_subscribe`).

      - symbol: Canonical Contract Deployments
        kind: configuration
        summary: Addresses of commonly used, canonical contracts deployed on Monad Testnet.
        definition:
          code: |
            {
              "CreateX": "0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed",
              "Foundry Deterministic Deployer": "0x4e59b44847b379578588920ca78fbf26c0b4956c",
              "EntryPoint v0.6 (EIP-4337)": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
              "EntryPoint v0.7 (EIP-4337)": "0x0000000071727De22E5E9d8BAf0edAc6f37da032",
              "Multicall3": "0xcA11bde05977b3631167028862bE2a173976CA11",
              "Permit2": "0x000000000022d473030f116ddee9f6b43ac78ba3",
              "SafeSingletonFactory": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
              "WrappedMonad (WMON)": "0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701"
            }
          lang: json
        guidance:
          - Use these addresses directly in your application for standardized functionalities like Multicall, WMON, or Account Abstraction.
          - Multicall3 is highly recommended for batching `eth_call` requests to improve application performance (see Common Workflows).

# ===================================================================
# 2 • Transactions and Gas
# ===================================================================
  - group: Transactions and Gas
    description: Details on transaction structure, gas mechanics, and pricing on Monad.
    symbols:
      - symbol: Gas Limit Billing (Key Difference)
        kind: concept
        summary: Monad charges the transaction's `gas_limit`, not the actual `gas_used`.
        definition:
          code: |
            Total tokens deducted = value + (gas_price * gas_limit)
          lang: text
        guidance:
          - This is a critical difference from Ethereum. It is implemented as a DOS-prevention measure necessary for asynchronous execution.
          - Developers must ensure gas limits are set accurately. Overestimating the gas limit results in higher costs for the user.
          - If the gas cost is static (e.g., a simple transfer is 21,000 gas), hardcode the `gas_limit` instead of relying on `eth_estimateGas`.
          - Be cautious of wallets (like MetaMask) that default to very high limits if `eth_estimateGas` reverts; this leads to high costs on Monad.

      - symbol: Gas Parameters and Limits
        kind: configuration
        summary: Key constants related to gas usage and block capacity.
        definition:
          code: |
            {
              "Block Gas Limit": "150 Million gas",
              "Per-Transaction Gas Limit": "30 Million gas",
              "Opcode Pricing": "Matches Ethereum (Pectra fork)",
              "EIP-1559": "Supported",
              "Testnet Base Fee (Static)": "50 gwei (50 * 10^-9 MON)"
            }
          lang: json
        guidance:
          - The high block gas limit (150M) enables significantly more computation per block compared to Ethereum.
          - The Testnet base fee is currently static at 50 gwei. It will become dynamic in the future, following EIP-1559 mechanics.
          - Transactions are generally ordered by a Priority Gas Auction (descending total gas price).

      - symbol: Supported Transaction Types
        kind: configuration
        summary: The types of Ethereum transaction envelopes supported by Monad.
        definition:
          code: |
            Supported:
              - Type 0: Legacy
              - Type 1: EIP-2930 (Access Lists)
              - Type 2: EIP-1559 (Default)

            Planned (Before Mainnet):
              - Type 4: EIP-7702

            Not Supported:
              - Type 3: EIP-4844 (Blob transactions)
          lang: yaml
        guidance:
          - Type 2 (EIP-1559) is the standard and recommended transaction type.
          - Access lists (EIP-2930) are supported but not required. Monad handles state access optimizations internally.

      - symbol: Mempool Behavior (Local vs Global)
        kind: concept
        summary: Monad utilizes local mempools instead of a global, gossiped mempool.
        definition:
          code: |
            Monad does not maintain a global mempool. Each validator maintains a local mempool. RPC nodes forward transactions strategically to upcoming leaders.
          lang: text
        guidance:
          - This design is crucial for high performance but means there is no universal view of pending transactions.
          - The WebSocket subscription `newPendingTransactions` is not supported.
          - This architecture generally does not affect smart contract design, but developers managing high-frequency transactions should manage nonces locally.

# ===================================================================
# 3 • EVM and Execution Environment
# ===================================================================
  - group: EVM and Execution
    description: Specifications of the Monad Virtual Machine and its execution characteristics.
    symbols:
      - symbol: EVM Compatibility and Specifications
        kind: configuration
        summary: Monad maintains full EVM bytecode equivalence with specific enhancements.
        definition:
          code: |
            {
              "EVM Equivalence": "Full bytecode compatibility (Pectra fork level)",
              "Opcodes": "All opcodes supported as of Pectra fork",
              "Max Contract Size": "128 kb",
              "Precompiles": "0x01 through 0x0a supported. (EIP-2537 BLS12-381 planned before mainnet)"
            }
          lang: json
        guidance:
          - Existing Solidity, Vyper, or other EVM-targeting contracts can be deployed on Monad without modification.
          - The max contract size is significantly increased from Ethereum's 24.5kb limit, allowing for more complex contracts.
          - Standard development tools (Hardhat, Foundry, etc.) are fully compatible.

      - symbol: Parallel Execution
        kind: concept
        summary: Monad executes transactions in parallel while maintaining the outcome of serial execution.
        definition:
          code: |
            Monad uses optimistic parallel execution. Transactions are computed in parallel, generating pending results. These results are committed serially, validating inputs. If an input conflict occurs (an earlier transaction modified a read state), the transaction is re-executed.
          lang: text
        guidance:
          - Developers do NOT need to change their code to benefit from parallelism. The system handles dependency management.
          - State contention is evaluated on a slot-by-slot basis, not contract-by-contract. (e.g., Two separate USDC transfers do not conflict, despite using the same contract).
          - Parallel execution is strictly an implementation detail; the developer experience remains identical to serial EVM execution.

      - symbol: Historical State Access (Key Limitation)
        kind: limitation
        summary: Full nodes prune historical state aggressively and do not serve arbitrary historical state data.
        definition:
          code: |
            Monad full nodes provide access to all historic ledger data (blocks, transactions, receipts, events, traces). They do NOT provide access to arbitrary historic state (e.g., `eth_call` at an old block height).
          lang: text
        guidance:
          - Due to the high data throughput of Monad, storing all historical states is prohibitively expensive.
          - Methods like `eth_call` or `eth_getBalance` referencing old block numbers will likely fail (error: "historical state that is not available").
          - To access historical data, ensure contracts emit events for necessary state changes.
          - Utilize specialized indexers (The Graph, Goldsky, Envio, etc.) to compute and query derived historical state off-chain.

      - symbol: Timing and Timestamps
        kind: configuration
        summary: Block frequency and the behavior of the TIMESTAMP opcode.
        definition:
          code: |
            {
              "Block Frequency": "400 ms",
              "TIMESTAMP opcode granularity": "1 Second (Unix Timestamp)"
            }
          lang: json
        guidance:
          - The `TIMESTAMP` opcode (Solidity: `block.timestamp`) behaves as in Ethereum, returning seconds.
          - Due to the 400ms block time, 2-3 consecutive blocks will likely share the same timestamp value.
          - Do not rely on `block.timestamp` for fine-grained time measurements or as a source of uniqueness between blocks. Use `block.number` for ordering.

# ===================================================================
# 4 • Consensus and Finality
# ===================================================================
  - group: Consensus and Finality
    description: Overview of Monad's consensus mechanism (MonadBFT) and the stages of block finality.
    symbols:
      - symbol: MonadBFT
        kind: concept
        summary: Monad's high-performance, pipelined BFT consensus mechanism.
        definition:
          code: |
            MonadBFT is a customized BFT consensus mechanism optimized for performance, featuring resilience to tail forking and enabling rapid finality.
          lang: text
        guidance:
          - MonadBFT enables the rapid block times (400ms) and fast finality (800ms).

      - symbol: Asynchronous Execution
        kind: concept
        summary: Decoupling consensus (agreeing on order) from execution (computing the state).
        definition:
          code: |
            Validators vote first (consensus) and execute later. Execution happens locally after the transaction order is finalized. A delayed merkle root (3 blocks later) confirms the execution results across the network.
          lang: text
        guidance:
          - This allows Monad to maximize the time budget for execution without delaying consensus.
          - Most developers do not need to account for this.
          - Applications with significant off-chain financial logic (bridges, centralized exchanges) may prefer to wait for the `Verified` phase (state root finality).

      - symbol: Block States and Finality Timeline
        kind: concept
        summary: The lifecycle stages of a block from proposal to verification.
        definition:
          code: |
            T+0 (0ms): Proposed
            T+1 (400ms): Voted (Speculative Finality) - Receipts available. Safe for most UIs.
            T+2 (800ms): Finalized (Full Finality) - Transaction order is immutable (no reorgs).
            T+5 (2000ms): Verified (State Root Finality) - Execution results (state) confirmed by consensus.
          lang: text
        guidance:
          - `Voted` (Speculative Finality) is very reliable and suitable for updating user interfaces quickly. Reversion is extremely rare.
          - `Finalized` means the transaction order cannot change.
          - `Verified` confirms that the network agrees on the resulting state after execution.

# ===================================================================
# X • Optional Sections
# ===================================================================

common_workflows:
  - title: Optimizing Data Reads with Multicall
    description: Using Multicall3 to aggregate multiple `eth_call` requests into a single RPC call for efficiency. This reduces latency by avoiding serial network round trips.
    example:
      code: |
        // Assuming 'publicClient' (viem) and 'erc20Abi' are defined
        const MULTICALL3_ADDRESS = "0xcA11bde05977b3631167028862bE2a173976CA11";
        const WMON_ADDRESS = "0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701";
        const USER_ADDRESS = "0x..."; // Replace with actual user address

        async function fetchTokenData() {
          const results = await publicClient.multicall({
            contracts: [
              {
                address: WMON_ADDRESS,
                abi: erc20Abi,
                functionName: 'balanceOf',
                args: [USER_ADDRESS]
              },
              {
                address: WMON_ADDRESS,
                abi: erc20Abi,
                functionName: 'symbol'
              }
            ],
            multicallAddress: MULTICALL3_ADDRESS
          });

          // Check status before accessing result
          if (results[0].status === 'success') console.log("Balance:", results[0].result);
          if (results[1].status === 'success') console.log("Symbol:", results[1].result);
        }
      lang: javascript

  - title: Sending Transactions Concurrently (Nonce Management)
    description: Submitting multiple transactions in parallel by manually managing nonces locally. This is required for high-frequency submissions as `eth_getTransactionCount` only updates post-finalization.
    example:
      code: |
        // Assuming 'walletClient', 'publicClient', 'account', and 'chain' (Monad Testnet) are defined
        import { parseEther } from 'viem';

        const BATCH_SIZE = 5;
        const DESTINATION = '0x...'; // Destination address

        async function sendConcurrentTransactions() {
          // Fetch the current confirmed nonce once
          const nonce = await publicClient.getTransactionCount({ address: account.address });

          // Prepare promises for concurrent submission
          const transactionsPromises = Array(BATCH_SIZE)
            .fill(null)
            .map(async (_, i) => {
              return await walletClient.sendTransaction({
                to: DESTINATION,
                value: parseEther('0.001'),
                gas: BigInt(21000), // Hardcode gas limit (use 'gas' in viem for gasLimit)
                // Testnet base fee is 50 gwei. Setting maxFeePerGas slightly higher.
                maxFeePerGas: BigInt(52000000000),
                chain: chain,
                nonce: nonce + Number(i), // Increment nonce locally
              });
            });

          // Submit all transactions concurrently
          const hashes = await Promise.all(transactionsPromises);
          console.log("Transaction Hashes:", hashes);
        }
      lang: javascript

  - title: Hardcoding Gas Limits for Static Calls
    description: Best practice for transactions with known, static gas costs (like simple transfers). This improves UX and avoids estimation issues.
    example:
      code: |
        // On Monad, you are charged the Gas Limit. Avoid calling eth_estimateGas if the cost is known.

        const SIMPLE_TRANSFER_GAS = 21000n;

        const tx_hash = await walletClient.sendTransaction({
          account: senderAddress,
          to: recipientAddress,
          value: parseEther('0.1'),
          gas: SIMPLE_TRANSFER_GAS, // Set the limit directly
          // ... other parameters
        });
      lang: javascript

troubleshooting_cheatsheet:
  - symptom: "`eth_call` or `eth_getBalance` fails with "historical state that is not available" when using an old block number."
    cause: Monad full nodes prune historical state aggressively due to high throughput. They only retain recent states.
    fix: Reformulate the query to use a recent block number. If historical state is required, use an indexer service (e.g., The Graph, Goldsky, Envio) or rely on historical event logs.
  - symptom: "Transactions cost significantly more than expected based on `gas_used`."
    cause: Monad charges the `gas_limit` specified in the transaction, not the `gas_used`.
    fix: Ensure your application or wallet is setting an accurate `gas_limit`. If the gas usage is constant, hardcode the limit instead of using `eth_estimateGas`.
  - symptom: "Wallet sets an extremely high gas limit when `eth_estimateGas` reverts (e.g., trying to mint a sold-out NFT)."
    cause: Some wallets default to high limits when estimation fails. On Monad, this results in high costs because the limit is charged.
    fix: If possible, hardcode the gas limit for the transaction in the frontend before passing it to the wallet, preventing the wallet from using its fallback estimation logic.
  - symptom: "Nonce errors (`replacement transaction underpriced` or `nonce too low`) when sending multiple transactions rapidly."
    cause: `eth_getTransactionCount` only updates after the previous transaction is finalized (800ms). Relying on it for rapid submissions causes nonce reuse.
    fix: Manage nonces locally within your application. Fetch the nonce once, then increment it manually for subsequent transactions in the batch (see Common Workflows).

faq:
  - question: Are there any differences in opcode pricing compared to Ethereum?
    answer: No, every opcode costs the same number of units of gas as it does on Ethereum (as of the Pectra fork).
  - question: Do I need to change my code to take advantage of Monad's parallelism?
    answer: No. Transactions interacting with your smart contract behave exactly as if they were executed serially. Parallel execution is strictly an implementation detail handled by the protocol.
  - question: Why does Monad charge the Gas Limit instead of Gas Used?
    answer: Monad uses Asynchronous Execution (validators vote before executing). If the protocol charged `gas_used`, an attacker could submit a transaction with a large `gas_limit` that consumes very little gas. This would take up significant block space without paying for it, opening up a DOS vector.
  - question: How fast is finality on Monad?
    answer: Full finality (immutable transaction order) occurs in 800ms (2 blocks). Speculative finality (safe for most UIs) occurs in 400ms (1 block). State root finality (execution results confirmed by consensus) occurs in 2000ms (5 blocks).
  - question: Is EIP-4844 (Blob transactions) supported?
    answer: No, Transaction Type 3 (EIP-4844) is not supported on Monad L1.

external_resources:
  - label: Official Documentation Homepage
    url: https://docs.monad.xyz/
  - label: Monad Testnet Explorer
    url: https://testnet.monadexplorer.com
  - label: Testnet Faucet
    url: https://faucet.monad.xyz
  - label: Developer Essentials Summary
    url: https://docs.monad.xyz/developer-essentials/summary
  - label: Monad Architecture Deep Dive
    url: https://docs.monad.xyz/monad-arch
  - label: Monad Developer Discord
    url: https://discord.gg/monaddev
  - label: Tooling and Infrastructure Providers
    url: https://docs.monad.xyz/tooling-and-infra/
