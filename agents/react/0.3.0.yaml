meta:
  spec_name: react
  spec_version: "0.3.0"
  library_version: "^18.3.0"
  generated: "2025-08-12"
  language: javascript
  homepage: https://react.dev
  tags: [react, frontend, hooks, library, typescript]
  purpose: >
    Concise, actionable reference for React’s public API—hooks, helpers,
    and core element factories—structured for LLM consumption. Includes
    raw TypeScript definitions (the contract) alongside expert guidance
    (the best practices).
  guiding_principles:
    - Emphasise practical usage patterns over exhaustive edge cases.
    - Ensure the `definition` block provides the accurate TypeScript contract.
    - Keep summaries one‑line; move nuance into guidance bullets.
    - Provide runnable, import‑complete examples that compile in modern React environments (Vite, Next.js).
    - Highlight performance implications and common foot‑guns (keys, memoisation, stale closures).
    - Cross‑reference related exports inside guidance to encourage discovery.
    - Prefer current idioms (ESM, function components, hooks) and clearly mark legacy APIs.
  design_notes: |
    Source files: TypeScript declaration files from @types/react (approx v18.3.0)
    plus official React documentation. Exports grouped by mental model: element
    factories, component helpers, core hooks, performance hooks, and advanced hooks.
    Definitions are slightly compressed from source to remove excessive comments
    and less common overloads, focusing on the primary usage signature.

groups:
  - name: element-creation
    exports: [createElement, cloneElement, Fragment]
    symbols:
      createElement:
        kind: function
        summary: Programmatically create a React element from type, props, and children.
        definition:
          lang: typescript
          code: |
            function createElement<P extends {}>(
                type: FunctionComponent<P> | ComponentClass<P> | string,
                props?: Attributes & P | null,
                ...children: ReactNode[]
            ): ReactElement<P>;
        guidance:
          - Prefer JSX (`<div />`) for readability—`createElement` is primarily for meta‑frameworks, dynamic component factories, or non-JSX environments.
          - Always supply a stable `key` prop when creating elements inside arrays to preserve state and identity between renders.
          - The `type` argument can be a string (HTML tag) or a React component (Function or Class).
        example:
          lang: javascript
          code: |
            import React from 'react';

            const el = React.createElement(
              'button',
              { onClick: () => alert('Hi') },
              'Click me'
            );

            export default () => el;

      cloneElement:
        kind: function
        summary: Copy an existing element with new props and/or children.
        definition:
          lang: typescript
          code: |
            function cloneElement<P>(
                element: ReactElement<P>,
                props?: Partial<P> & Attributes,
                ...children: ReactNode[]
            ): ReactElement<P>;
        guidance:
          - Use to inject or override props (like refs or callbacks) into children you don’t fully control (e.g., elements passed via `props.children`).
          - Cloned elements retain the original `key` and `ref`. Passing a new `key` or `ref` in the props will replace the original ones.
          - Use sparingly; often, simpler patterns like prop drilling or context are clearer.
        example:
          lang: javascript
          code: |
            import React, { cloneElement } from 'react';

            function AddClass({ child }) {
              // Adds 'highlight' class to the child element
              // Ensure child is a valid ReactElement before calling
              if (React.isValidElement(child)) {
                return cloneElement(child, { className: 'highlight' });
              }
              return child;
            }

      Fragment:
        kind: component
        summary: Group multiple children without adding an extra DOM node.
        definition:
          lang: typescript
          code: |
            const Fragment: FunctionComponent<{ children?: ReactNode | undefined }>;
        guidance:
          - The shorthand `<> ... </>` syntax is preferred and compiles to `React.Fragment`.
          - Use the explicit `<Fragment>` component only when you need to provide a `key`.
          - Keys are necessary when mapping an array to a list of fragments.
        example:
          lang: javascript
          code: |
            import { Fragment } from 'react';

            const List = ({ items }) => (
              <ul>
                {items.map((item) => (
                  // Key is required on the Fragment when mapping
                  <Fragment key={item.id}>
                    <li>{item.label}</li>
                    <li>{item.detail}</li>
                  </Fragment>
                ))}
              </ul>
            );

  - name: component-helpers
    exports: [Children, memo, forwardRef, lazy, Suspense]
    symbols:
      Children:
        kind: object
        summary: Utilities for safely iterating, counting, and manipulating the opaque `props.children` data structure.
        definition:
          lang: typescript
          code: |
            interface ReactChildren {
                map<T, C>(children: C | ReadonlyArray<C>, fn: (child: C, index: number) => T): Array<...>;
                forEach<C>(children: C | ReadonlyArray<C>, fn: (child: C, index: number) => void): void;
                count(children: any): number;
                only<C>(children: C): C;
                toArray(children: ReactNode | ReactNode[]): Array<...>;
            }
            const Children: ReactChildren;
        guidance:
          - Essential because `props.children` is opaque; it can be an array, a single element, null, or boolean. `Children` utilities handle these variations gracefully.
          - Use `Children.map` instead of `children.map()` when children might not be an array.
          - `Children.toArray` is useful for flattening nested children and ensuring unique keys before rendering.
        example:
          lang: javascript
          code: |
            import { Children } from 'react';

            function Upper({ children }) {
              // Safely iterates over children and transforms strings
              return Children.map(children, (c) =>
                typeof c === 'string' ? c.toUpperCase() : c
              );
            }

      memo:
        kind: function
        summary: Higher-Order Component (HOC) that memoizes a component to skip re-rendering when props are shallowly equal.
        definition:
          lang: typescript
          code: |
            function memo<P extends object>(
                Component: FunctionComponent<P>,
                propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean
            ): NamedExoticComponent<P>;
        guidance:
          - Apply to components that frequently render with the same props.
          - This only performs a shallow comparison of props by default.
          - To optimize, ensure parent components pass stable references (use `useCallback` for functions, `useMemo` for objects/arrays).
          - Optionally provide a custom comparison function as the second argument for deep equality checks or to ignore specific props.
        example:
          lang: javascript
          code: |
            import React, { memo } from 'react';

            // Row will only re-render if item.text or item.id changes
            const Row = memo(
              ({ item }) => <div>{item.text}</div>,
              // Optional custom comparison
              (prev, next) => prev.item.id === next.item.id
            );

            export default Row;

      forwardRef:
        kind: function
        summary: HOC that allows function components to receive a `ref` and pass it down to a child component (usually a DOM element).
        definition:
          lang: typescript
          code: |
            function forwardRef<T, P = {}>(
                render: ForwardRefRenderFunction<T, P>
            ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;
        guidance:
          - Necessary because function components cannot hold refs directly by default.
          - The `render` function receives `props` and `ref` as arguments.
          - Ensure the `ref` is attached to the target DOM element or component instance.
          - Combine with `useImperativeHandle` to expose specific methods on the ref rather than the raw DOM node.
        example:
          lang: javascript
          code: |
            import React, { forwardRef, useRef } from 'react';

            // FancyInput can now accept a ref from its parent
            const FancyInput = forwardRef((props, ref) => {
              return <input ref={ref} {...props} />;
            });

            // Usage:
            // const inputRef = useRef(null);
            // <FancyInput ref={inputRef} />

      lazy:
        kind: function
        summary: Enables code-splitting by loading a component lazily via dynamic `import()`.
        definition:
          lang: typescript
          code: |
            function lazy<T extends ComponentType<any>>(
                factory: () => Promise<{ default: T }>
            ): LazyExoticComponent<T>;
        guidance:
          - The component must be a default export in the imported module. Named exports are not currently supported by `React.lazy`.
          - Must be rendered inside a `<Suspense>` boundary to handle the loading state while the module is fetched.
          - Ideal for route-based code splitting or loading heavy components (like charts or modals) only when needed.
        example:
          lang: javascript
          code: |
            import { lazy, Suspense } from 'react';

            // Lazy load the Chart component
            const Chart = lazy(() => import('./Chart'));

            export default function Dashboard() {
              return (
                <Suspense fallback={<p>Loading Chart...</p>}>
                  <Chart />
                </Suspense>
              );
            }

      Suspense:
        kind: component
        summary: Declarative boundary that orchestrates loading states for lazy components and data fetching (React 18+).
        definition:
          lang: typescript
          code: |
            const Suspense: ExoticComponent<SuspenseProps>;
            interface SuspenseProps {
                children?: ReactNode;
                // The content to display while the children are loading.
                fallback?: NonNullable<ReactNode> | null;
            }
        guidance:
          - Displays the `fallback` prop until all its children have finished loading or fetching data.
          - Nest `Suspense` boundaries to create a loading sequence (e.g., skeleton UI).
          - In React 18+, integrates with concurrent features and data fetching frameworks (like Relay or the `use()` hook).
        example:
          lang: javascript
          code: |
            import { Suspense } from 'react';
            import ProfileDetails from './ProfileDetails';
            import ProfileTimeline from './ProfileTimeline';

            export default () => (
              <Suspense fallback={<div>Fetching profile…</div>}>
                <ProfileDetails />
                <Suspense fallback={<div>Fetching timeline...</div>}>
                  <ProfileTimeline />
                </Suspense>
              </Suspense>
            );

  - name: core-hooks
    exports: [useState, useEffect, useContext, useReducer, useRef]
    symbols:
      useState:
        kind: hook
        summary: Declares a state variable that React preserves between renders.
        definition:
          lang: typescript
          code: |
            function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];
            // Overload for potentially undefined state:
            function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];
        guidance:
          - Returns an array: the current state value and a setter function.
          - Use "Lazy initialization" by passing a function (`useState(() => expensiveCalculation())`) to compute the initial state only once on mount.
          - Use "Functional updates" (`setCount(c => c + 1)`) when the new state depends on the previous state, ensuring correctness even if state updates are batched.
        example:
          lang: javascript
          code: |
            import { useState } from 'react';

            export default function Counter() {
              const [count, setCount] = useState(0);

              const increment = () => {
                // Use functional update form
                setCount(c => c + 1);
              };

              return <button onClick={increment}>{count}</button>;
            }

      useEffect:
        kind: hook
        summary: Synchronizes a component with an external system (network, DOM manipulation, subscriptions).
        definition:
          lang: typescript
          code: |
            function useEffect(effect: EffectCallback, deps?: DependencyList): void;
        guidance:
          - Runs after the component renders and the screen is updated.
          - The dependency array (`deps`) controls when the effect re-runs. If empty (`[]`), it runs only on mount and unmount.
          - **Crucial:** Include all reactive values (props, state, derived values) used inside the effect in the dependency array. Rely on `eslint-plugin-react-hooks` to enforce this.
          - Return a cleanup function to disconnect or unsubscribe when the component unmounts or before the effect runs again.
        example:
          lang: javascript
          code: |
            import { useEffect, useState } from 'react';

            function UserProfile({ userId }) {
              const [user, setUser] = useState(null);

              useEffect(() => {
                // Effect runs when userId changes
                fetch(`/api/user/${userId}`).then(res => res.json()).then(setUser);

                // Cleanup function (e.g., aborting fetch if needed)
                return () => { /* cleanup logic */ };
              }, [userId]); // Dependency array

              return <div>{user ? user.name : 'Loading...'}</div>;
            }

      useContext:
        kind: hook
        summary: Reads the value from the nearest `Provider` for a given Context.
        definition:
          lang: typescript
          code: |
            function useContext<T>(context: Context<T>): T;
        guidance:
          - Use for passing data deep into the component tree without manual "prop drilling".
          - The argument must be the Context object itself (created via `createContext`).
          - Components using `useContext` will re-render whenever the context value changes.
          - To optimize performance, memoize the value object provided to the `Provider` (using `useMemo`) if it contains non-primitive values.
        example:
          lang: javascript
          code: |
            import { createContext, useContext } from 'react';

            // Create the context object
            const ThemeContext = createContext('light');

            function ThemedButton() {
              // Consume the context value
              const theme = useContext(ThemeContext);
              return <button className={`btn-${theme}`}>Click</button>;
            }

      useReducer:
        kind: hook
        summary: Alternative to `useState` for managing complex state logic using a reducer function.
        definition:
          lang: typescript
          code: |
            function useReducer<R extends Reducer<any, any>>(
                reducer: R,
                initialState: ReducerState<R>,
                initializer?: undefined
            ): [ReducerState<R>, Dispatch<ReducerAction<R>>];
            // (Overloads exist for lazy initialization using an initializer function)
        guidance:
          - Prefer `useReducer` when state transitions are complex, involve multiple sub-values, or when the next state depends predictably on the previous state and an action.
          - Returns the current state and a `dispatch` function.
          - The reducer function should be pure (no side effects) and return the new state.
        example:
          lang: javascript
          code: |
            import { useReducer } from 'react';

            const initialState = { count: 0 };

            function reducer(state, action) {
              switch (action.type) {
                case 'increment':
                  return { count: state.count + 1 };
                default:
                  throw new Error();
              }
            }

            function Counter() {
              const [state, dispatch] = useReducer(reducer, initialState);
              return (
                <>
                  Count: {state.count}
                  <button onClick={() => dispatch({ type: 'increment' })}>+</button>
                </>
              );
            }

      useRef:
        kind: hook
        summary: Creates a mutable container whose `.current` property persists for the component’s lifetime and does not trigger re-renders.
        definition:
          lang: typescript
          code: |
            // For mutable values
            function useRef<T>(initialValue: T): MutableRefObject<T>;
            // For DOM elements (initialized with null)
            function useRef<T>(initialValue: T|null): RefObject<T>;
        guidance:
          - Primarily used to access DOM elements imperatively (e.g., focusing an input).
          - Also used to store any mutable value (like timeout IDs or previous state) that shouldn't cause a re-render when changed.
          - Modifying `ref.current` is a side effect and should generally happen inside `useEffect` or event handlers, not during rendering.
        example:
          lang: javascript
          code: |
            import { useRef, useEffect } from 'react';

            function FocusOnMount() {
              const inputRef = useRef(null);

              useEffect(() => {
                // Access the DOM element via .current and focus it
                inputRef.current?.focus();
              }, []);

              return <input ref={inputRef} />;
            }

  - name: performance-hooks
    exports: [useCallback, useMemo, useLayoutEffect, useTransition, startTransition]
    symbols:
      useCallback:
        kind: hook
        summary: Memoizes a callback function, returning a stable reference until dependencies change.
        definition:
          lang: typescript
          code: |
            function useCallback<T extends (...args: any[]) => any>(
                callback: T,
                deps: DependencyList
            ): T;
        guidance:
          - Essential for optimization when passing callbacks to child components wrapped in `memo`. It prevents the child from re-rendering unnecessarily due to a new function reference.
          - The dependency array rules are the same as `useEffect`. Include all reactive values used inside the callback.
          - Do not overuse; only apply when it prevents expensive re-renders or stabilizes dependencies for other hooks.
        example:
          lang: javascript
          code: |
            import { useState, useCallback, memo } from 'react';

            const Child = memo(({ onClick }) => {
              console.log("Child rendering");
              return <button onClick={onClick}>Click</button>
            });

            function Parent() {
              const [count, setCount] = useState(0);

              // Memoize the handler so Child doesn't re-render when Parent count changes
              const handleClick = useCallback(() => {
                console.log("Button clicked");
              }, []);

              return (
                <div>
                  <p>Parent Count: {count} <button onClick={() => setCount(c => c + 1)}>+</button></p>
                  <Child onClick={handleClick} />
                </div>
              );
            }

      useMemo:
        kind: hook
        summary: Memoizes the result of an expensive calculation, recomputing it only when dependencies change.
        definition:
          lang: typescript
          code: |
            function useMemo<T>(factory: () => T, deps: DependencyList | undefined): T;
        guidance:
          - Use for expensive operations like filtering, sorting large arrays, or complex data transformations.
          - Also used to maintain stable object or array references to pass as props to memoized children or as dependencies to other hooks (like `useEffect`).
          - If the calculation is cheap, `useMemo` adds overhead and should be avoided.
        example:
          lang: javascript
          code: |
            import { useMemo } from 'react';

            function SortedList({ list, sortFn }) {
              // Only re-sort if the list or the sort function changes
              const sortedList = useMemo(() => {
                console.log("Running sort...");
                return [...list].sort(sortFn);
              }, [list, sortFn]);

              return (
                <ul>
                  {sortedList.map(item => <li key={item}>{item}</li>)}
                </ul>
              );
            }

      useLayoutEffect:
        kind: hook
        summary: Similar to `useEffect`, but runs synchronously after all DOM mutations but before the browser paints.
        definition:
          lang: typescript
          code: |
            function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void;
        guidance:
          - Use sparingly. Prefer `useEffect` for most side effects as it is asynchronous.
          - Necessary when you need to read layout from the DOM (e.g., getBoundingClientRect) and synchronously update the DOM based on that measurement to prevent visual flickering.
          - Blocks the browser paint; heavy computations here can cause performance issues (jank).
        example:
          lang: javascript
          code: |
            import { useLayoutEffect, useRef, useState } from 'react';

            function MeasureElement() {
              const ref = useRef(null);
              const [width, setWidth] = useState(0);

              useLayoutEffect(() => {
                // Measure the DOM node synchronously after render, before paint
                if (ref.current) {
                  setWidth(ref.current.offsetWidth);
                }
              }, []);

              return <div ref={ref}>My width is: {width}px</div>;
            }

      useTransition:
        kind: hook
        since: "18.0.0"
        summary: Allows marking state updates as non-urgent "transitions" to keep the UI responsive during expensive updates.
        definition:
          lang: typescript
          code: |
            function useTransition(): [boolean, TransitionStartFunction];
            // TransitionStartFunction signature: (scope: () => void) => void
        guidance:
          - Returns `isPending` (a boolean indicating if the transition is active) and `startTransition` (a function to trigger the transition).
          - Wrap the less urgent state update inside `startTransition`. React will prioritize urgent updates (like typing in an input).
          - Ideal for heavy rendering tasks like filtering large lists or navigating between complex views.
        example:
          lang: javascript
          code: |
            import { useState, useTransition } from 'react';

            function SearchComponent({ data }) {
              const [query, setQuery] = useState('');
              const [inputValue, setInputValue] = useState('');
              const [isPending, startTransition] = useTransition();

              const handleChange = (e) => {
                const value = e.target.value;
                // Urgent update: Update the input field immediately
                setInputValue(value);

                // Non-urgent update: Update the query for filtering
                startTransition(() => {
                  setQuery(value);
                });
              };

              return (
                <>
                  <input value={inputValue} onChange={handleChange} />
                  {isPending ? <p>Filtering...</p> : <List query={query} data={data} />}
                </>
              );
            }

      startTransition:
        kind: function
        since: "18.0.0"
        summary: The standalone function version of `useTransition` for use outside of components or when the hook is not convenient.
        definition:
          lang: typescript
          code: |
            function startTransition(scope: () => void): void;
        guidance:
          - Used to trigger non-urgent updates imperatively, for example, in data fetching libraries or event handlers defined outside React components.
          - Wrap the state setting logic inside the provided callback.
          - Does not provide an `isPending` state; use `useTransition` if you need to track the pending status.
        example:
          lang: javascript
          code: |
            import { startTransition } from 'react';

            // Example utility function
            function navigateTo(url, setHistory) {
              // Mark the history update as a transition
              startTransition(() => {
                setHistory(prev => [...prev, url]);
              });
            }

  - name: advanced-hooks
    exports: [useSyncExternalStore, useId, useDeferredValue]
    symbols:
      useSyncExternalStore:
        kind: hook
        since: "18.0.0"
        summary: Subscribes to an external mutable store (like Redux, Zustand, or browser APIs) in a way that is safe for concurrent rendering.
        definition:
          lang: typescript
          code: |
            function useSyncExternalStore<Snapshot>(
                subscribe: (onStoreChange: () => void) => () => void,
                getSnapshot: () => Snapshot,
                getServerSnapshot?: () => Snapshot
            ): Snapshot;
        guidance:
          - Primarily intended for library authors, not typically used in application code.
          - `subscribe` must register the callback and return an unsubscribe function.
          - `getSnapshot` must return the current, immutable snapshot of the store data. It must return the same value unless the store changes to avoid unnecessary re-renders.
        example:
          lang: javascript
          code: |
            import { useSyncExternalStore } from 'react';

            // Example: Subscribing to the browser's online status

            function subscribe(callback) {
              window.addEventListener('online', callback);
              window.addEventListener('offline', callback);
              return () => {
                window.removeEventListener('online', callback);
                window.removeEventListener('offline', callback);
              };
            }

            function getSnapshot() {
              return navigator.onLine;
            }

            function OnlineStatus() {
              const isOnline = useSyncExternalStore(subscribe, getSnapshot);
              return <span>{isOnline ? '✅ Online' : '❌ Offline'}</span>;
            }

      useId:
        kind: hook
        since: "18.0.0"
        summary: Generates a unique, stable ID that is consistent across server (SSR/SSG) and client renders.
        definition:
          lang: typescript
          code: |
            function useId(): string;
        guidance:
          - Solves the problem of ID mismatches during hydration when generating IDs randomly.
          - Essential for accessibility attributes that link elements (e.g., `aria-labelledby`, `htmlFor`).
          - Do NOT use the generated ID for keys in lists. Use data IDs for keys.
          - To generate multiple related IDs, append a suffix to the base ID (e.g., `${id}-label`, `${id}-input`).
        example:
          lang: javascript
          code: |
            import { useId } from 'react';

            function InputField({ label }) {
              const id = useId();
              return (
                <div>
                  {/* Link label and input using the stable ID */}
                  <label htmlFor={id}>{label}</label>
                  <input id={id} type="text" />
                </div>
              );
            }

      useDeferredValue:
        kind: hook
        since: "18.0.0"
        summary: Defers updating a value until the current render is complete, allowing the UI to remain responsive.
        definition:
          lang: typescript
          code: |
            function useDeferredValue<T>(value: T): T;
        guidance:
          - Similar to debouncing or throttling, but integrated into React's concurrent rendering model.
          - Useful when a value changes frequently (like user input) and causes expensive re-renders (like filtering a large list).
          - The deferred value "lags behind" the actual value during updates.
          - Use the original value for immediate feedback (like the input field text) and the deferred value for the expensive operation.
        example:
          lang: javascript
          code: |
            import { useState, useDeferredValue, useMemo } from 'react';

            function Search({ items }) {
              const [text, setText] = useState('');
              // Defer the text value used for filtering
              const deferredText = useDeferredValue(text);

              // Memoize the expensive filtering based on the deferred value
              const results = useMemo(() => {
                 return items.filter(i => i.includes(deferredText));
              }, [deferredText, items]);

              return (
                <>
                  {/* Input uses the immediate value */}
                  <input value={text} onChange={(e) => setText(e.target.value)} />
                  <ResultsList results={results} />
                </>
              );
            }

common_workflows:
  - title: Controlled input with optimized filtering (React 18+)
    steps:
      - Use `useState` to hold the raw input value for the `<input>` element (immediate feedback).
      - Use `useDeferredValue` on the input state to get a lagged query term.
      - Use `useMemo` to calculate the filtered list, depending on the deferred value.
      - This keeps the input responsive while deferring the expensive rendering of the list.

  - title: Code‑splitting a route or large component
    steps:
      - Identify the component to split (e.g., a page route or a heavy visualization).
      - Ensure the component is a default export.
      - Use `React.lazy(() => import('./MyComponent'))` to import it.
      - Wrap the usage of the lazy component in a `<Suspense>` boundary.
      - Provide a meaningful `fallback` (e.g., a skeleton loader).

troubleshooting_cheatsheet:
  - symptom: “Warning: Each child in a list should have a unique 'key' prop.”
    cause: Missing or unstable `key` prop when rendering an array of elements using `.map()`.
    fix: Supply a deterministic `key` (usually an ID from the data) on the outermost element returned by the map function. Do not use array index unless the list is static and never reordered.

  - symptom: Component re‑renders even though it's wrapped in `memo`.
    cause: Parent component passes new references (functions, objects, arrays) as props on every render.
    fix: In the parent component, wrap callbacks in `useCallback` and object/array creation in `useMemo` to stabilize references.

  - symptom: Stale state or props inside a callback or effect (Stale Closure).
    cause: Relying on variables captured when the function or effect was defined (often with empty dependency arrays), but have since changed.
    fix: Use functional updates in `setState(c => c + 1)`. Ensure `useEffect` or `useCallback` dependency arrays are correct and include all necessary variables.

faq:
  - q: Do I still need `PureComponent` or `shouldComponentUpdate`?
    a: No. Use `React.memo` for function components and hooks (`useCallback`, `useMemo`) to control updates efficiently.

  - q: When should I choose `useReducer` over `useState`?
    a: Prefer `useReducer` when the state logic involves multiple sub-values, complex transitions, or when the next state depends significantly on the previous one.

external_resources:
  - label: React Documentation
    url: https://react.dev
  - label: Hooks API Reference
    url: https://react.dev/reference/react
  - label: TypeScript definitions (@types/react)
    url: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts
