meta:
spec\_name: onlyswaps-solver/expert-knowledge-pack
spec\_version: "0.3.0"
library\_version: "0.1.0"  # from Cargo.toml
generated: "2025-09-23"
language: rust
tags: \[blockchain, ethereum, cross-chain, agent, solver, rust, axum, alloy]
purpose: >
Provide an LLM-ready, expert-curated reference to the onlyswaps-solver Rust
agent that listens to multiple EVM chains, derives executable cross-chain
swap trades, and relays tokens via on-chain Router contracts. The pack
merges the exact public contracts (types, traits, fns) with practical guidance
to compose the solver, network bindings, executor, and HTTP health server into
a robust agent process.  &#x20;
guiding\_principles:
\- Treat chain IDs consistently—convert U256 → u64 using `normalise_chain_id` at module boundaries.&#x20;
\- Keep an in-flight request cache to avoid duplicate executions during rapid block updates; use TTL to permit safe retries.&#x20;
\- Fetch and snapshot chain state before solving; never solve against partially updated maps across chains.&#x20;
\- Validate execution preconditions (fee > 0, token match, balances) before emitting trades.&#x20;
\- Use typed ABI bindings generated by `alloy::sol!` for Router/ERC20 to avoid raw call string errors.&#x20;
\- Prefer `ProviderBuilder` + WS transport; attach a wallet for signing relays and approvals.&#x20;
\- Build deterministic local dev loops with two Anvil chains and the provided scripts to reproduce flows end‑to‑end.&#x20;
design\_notes: >
This pack was synthesized from the crate’s source files (`src/*.rs`), Cargo
metadata, Dockerfile, and README to reflect the exact public contracts and
de facto usage patterns observed in tests and the app entrypoint. Source
highlights: solver API and rules (src/solver.rs), model types (src/model.rs),
network bindings & ChainStateProvider impl (src/network.rs), trade executor
(src/executor.rs), HTTP server (src/api.rs), CLI/config (src/config.rs),
utilities (src/util.rs), and orchestration (src/app.rs, src/main.rs).
Build/run and env guidance was taken from README and scripts.    &#x20;

groups:

* id: config
  label: CLI & Configuration
  exports:

  * CliArgs
  * ConfigFile
  * NetworkConfig
  * load\_config\_file
    symbols:
    CliArgs:
    kind: struct
    summary: Command-line arguments for configuring the solver process (config path, private key, port).&#x20;
    definition:
    lang: rust
    code: |
    \#\[derive(Parser, Debug)]
    pub(crate) struct CliArgs {
    \#\[arg(short = 'c', long = "config-path", env = "SOLVER\_CONFIG\_PATH", default\_value = "\~/.solver/config.json")]
    pub config\_path: String,
    \#\[arg(short = 's', long = "private-key", env = "SOLVER\_PRIVATE\_KEY")]
    pub private\_key: String,
    \#\[arg(short = 'p', long = "port", env = "SOLVER\_PORT", default\_value = "8080")]
    pub port: u16,
    }
    guidance:

    * Load secrets from env for non-interactive runs; clap already wires `SOLVER_*` variables.&#x20;
    * Keep the port small and the health route unauthenticated; process-level signals handle shutdown.&#x20;
      example:
      lang: rust
      code: |
      use clap::Parser;
      use onlyswaps\_solver::config::CliArgs;
      fn main() {
      let args = CliArgs::parse();
      println!("config: {}, port: {}", args.config\_path, args.port);
      }
      since: "0.1.0"
      ConfigFile:
      kind: struct
      summary: Top-level JSON config holding a list of networks to connect to.&#x20;
      definition:
      lang: rust
      code: |
      \#\[derive(Deserialize, Debug, Clone)]
      pub(crate) struct ConfigFile {
      pub networks: Vec<NetworkConfig>,
      }
      guidance:
    * Validate addresses before boot to fail fast on typos; `Network::new` will parse/validate.&#x20;
    * Keep per-chain settings small: ws URL + token/router addresses + chain id.&#x20;
      example:
      lang: json
      code: |
      { "networks": \[{
      "chain\_id": 1337,
      "rpc\_url": "ws\://127.0.0.1:1337",
      "rusd\_address": "0x0000000000000000000000000000000000000001",
      "router\_address": "0x0000000000000000000000000000000000000002"
      }] }
      since: "0.1.0"
      NetworkConfig:
      kind: struct
      summary: Per-network connection and contract addresses.&#x20;
      definition:
      lang: rust
      code: |
      \#\[derive(Deserialize, Debug, Clone)]
      pub(crate) struct NetworkConfig {
      pub chain\_id: u64,
      pub rpc\_url: String,
      pub rusd\_address: String,
      pub router\_address: String,
      }
      guidance:
    * Use WS endpoints to enable subscriptions (block streams); HTTP won’t work for stream APIs.&#x20;
    * Keep chain IDs unique; they key the internal maps and streams.&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::config::NetworkConfig;
      let net = NetworkConfig {
      chain\_id: 1337,
      rpc\_url: "ws\://127.0.0.1:1337".into(),
      rusd\_address: "0x...".into(),
      router\_address: "0x...".into()
      };
      since: "0.1.0"
      load\_config\_file:
      kind: function
      summary: Reads and deserializes the JSON config file, expanding `~` and panicking on error.&#x20;
      definition:
      lang: rust
      code: |
      pub(crate) fn load\_config\_file(cli: \&CliArgs) -> ConfigFile {
      println!("loading config file {}", cli.config\_path);
      match fs::read(tilde(\&cli.config\_path).into\_owned()) {
      Ok(contents) => serde\_json::from\_slice(\&contents).unwrap\_or\_else(|\_| panic!("failed to parse config file at {}", cli.config\_path)),
      Err(err) => panic!("failed to read config file at {}: {:?}", cli.config\_path, err.to\_string()),
      }
      }
      guidance:
    * Prefer failing fast on invalid JSON; run a JSON schema check in CI if configs are shared.
    * Consider surfacing errors as `eyre::Result<ConfigFile>` if embedding in larger processes.
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::config::{CliArgs, load\_config\_file};
      let cli = CliArgs { config\_path: "./config.json".into(), private\_key: "deadbeef".into(), port: 8080 };
      let config = load\_config\_file(\&cli);
      assert!(!config.networks.is\_empty());
      since: "0.1.0"

* id: model
  label: Domain Model
  exports:

  * RequestId
  * ChainState
  * Transfer
  * Trade
  * BlockEvent
  * From<Transfer>\_for\_Trade
    symbols:
    RequestId:
    kind: type
    summary: Fixed-size identifier (\[u8; 32]) for swap requests.&#x20;
    definition:
    lang: rust
    code: |
    pub type RequestId = \[u8; 32];
    guidance:

    * Treat as opaque; compare by value and store in caches/sets as keys.&#x20;
    * Convert to ABI bytes when relaying (`trade.request_id.into()`).&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::model::RequestId;
      let rid: RequestId = \[0u8; 32];
      assert\_eq!(rid.len(), 32);
      since: "0.1.0"
      ChainState:
      kind: struct
      summary: Snapshot of balances, pending transfers, and fulfilled requests for a chain.&#x20;
      definition:
      lang: rust
      code: |
      \#\[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
      pub struct ChainState {
      pub token\_addr: Address,
      pub native\_balance: U256,
      pub token\_balance: U256,
      pub transfers: Vec<Transfer>,
      pub already\_fulfilled: Vec<RequestId>,
      }
      guidance:
    * Always refresh per new block; solving relies on current dest-chain balances.&#x20;
    * Guard against duplicate execution via `already_fulfilled` checks.&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::model::{ChainState, Transfer};
      use alloy::primitives::{Address, U256};
      let cs = ChainState { token\_addr: Address::ZERO, native\_balance: U256::from(1), token\_balance: U256::from(100), transfers: vec!\[], already\_fulfilled: vec!\[] };
      since: "0.1.0"
      Transfer:
      kind: struct
      summary: A single user swap request (Router parameters + request id).&#x20;
      definition:
      lang: rust
      code: |
      \#\[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
      pub struct Transfer {
      pub request\_id: RequestId,
      pub params: SwapRequestParameters,
      }
      guidance:
    * Values originate from on-chain Router storage via bindings; do not mutate.&#x20;
    * Convert to `Trade` via `Into` to execute on destination chain.&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::model::{Transfer, RequestId};
      use onlyswaps\_solver::eth::IRouter::SwapRequestParameters; // generated by alloy::sol!
      let t = Transfer { request\_id: \[0u8;32], params: unsafe { std::mem::zeroed() } }; // placeholder for demo
      since: "0.1.0"
      Trade:
      kind: struct
      summary: Executable instruction to relay tokens on the destination chain.&#x20;
      definition:
      lang: rust
      code: |
      \#\[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
      pub struct Trade {
      pub token\_addr: Address,
      pub src\_chain\_id: U256,
      pub dest\_chain\_id: U256,
      pub recipient\_addr: Address,
      pub request\_id: RequestId,
      pub swap\_amount: U256,
      }
      guidance:
    * Keep as a pure data object; execution happens in `TradeExecutor::execute`.&#x20;
    * Use `normalise_chain_id(trade.dest_chain_id)` when selecting per-chain bindings.&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::model::{Trade, RequestId};
      use alloy::primitives::{Address, U256};
      let tr = Trade { token\_addr: Address::ZERO, src\_chain\_id: U256::from(1), dest\_chain\_id: U256::from(2), recipient\_addr: Address::ZERO, request\_id:\[0u8;32], swap\_amount: U256::from(100) };
      since: "0.1.0"
      BlockEvent:
      kind: struct
      summary: Stream item representing (chain\_id, block\_number) for solver ticks.&#x20;
      definition:
      lang: rust
      code: |
      \#\[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
      pub(crate) struct BlockEvent {
      pub chain\_id: u64,
      pub block\_number: u64,
      }
      guidance:
    * Events are produced by `Network::stream_block_numbers()` via WS subscriptions.&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::model::BlockEvent;
      let ev = BlockEvent { chain\_id: 1337, block\_number: 42 };
      since: "0.1.0"
      From<Transfer>\_for\_Trade:
      kind: impl
      summary: `impl From<&Transfer> for Trade`—maps request parameters to an executable trade.&#x20;
      definition:
      lang: rust
      code: |
      impl From<\&Transfer> for Trade {
      fn from(transfer: \&Transfer) -> Self {
      Trade {
      token\_addr: transfer.params.tokenOut,
      src\_chain\_id: transfer.params.srcChainId,
      dest\_chain\_id: transfer.params.dstChainId,
      recipient\_addr: transfer.params.recipient,
      request\_id: transfer.request\_id,
      swap\_amount: transfer.params.amountOut,
      }
      }
      }
      guidance:
    * Prefer `Trade::from(&transfer)` (or `transfer.into()`) in solver paths.&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::model::{Transfer, Trade};
      fn to\_trade(t: \&Transfer) -> Trade { t.into() }
      since: "0.1.0"

* id: solver
  label: Solving Engine
  exports:

  * ChainStateProvider
  * Solver
  * Solver.from
  * Solver.fetch\_state
  * calculate\_trades
  * solve
    symbols:
    ChainStateProvider:
    kind: trait
    summary: Async provider for fetching a `ChainState` snapshot. Implemented by `Network<DynProvider>`.&#x20;
    definition:
    lang: rust
    code: |
    \#\[async\_trait]
    pub(crate) trait ChainStateProvider {
    async fn fetch\_state(\&self) -> eyre::Result<ChainState>;
    }
    guidance:

    * Implementations must query Router for unfulfilled requests and balances atomically per tick.&#x20;
    * Hide RPC faults behind `eyre::Result` to bubble up via solver loop.&#x20;
      example:
      lang: rust
      code: |
      use async\_trait::async\_trait;
      use onlyswaps\_solver::model::ChainState;
      \#\[async\_trait]
      trait ChainStateProvider { async fn fetch\_state(\&self) -> eyre::Result<ChainState>; }
      since: "0.1.0"
      Solver:
      kind: struct
      summary: Maintains per-chain state and produces trades on new blocks.&#x20;
      definition:
      lang: rust
      code: |
      pub(crate) struct Solver<'a, CSP> {
      states: std::collections::HashMap\<u64, ChainState>,
      chains: &'a std::collections::HashMap\<u64, CSP>,
      }
      guidance:
    * Construct with `from(&networks)` after networks are ready; it snapshots initial state.&#x20;
    * Use `fetch_state(chain_id, in_flight)` per new block; feed trades to executor if non-empty.&#x20;
      example:
      lang: rust
      code: |
      // Pseudocode sketch:
      // let mut solver = Solver::from(\&networks).await?;
      // let trades = solver.fetch\_state(chain\_id, \&inflight).await?;
      since: "0.1.0"
      Solver.from:
      kind: function
      summary: Builds a `Solver` and preloads `states` by calling `fetch_state()` on each chain.&#x20;
      definition:
      lang: rust
      code: |
      impl<'a, CSP: ChainStateProvider> Solver<'a, CSP> {
      pub async fn from(chains: &'a std::collections::HashMap\<u64, CSP>) -> eyre::Result<Self> {
      let mut states: std::collections::HashMap\<u64, ChainState> = std::collections::HashMap::new();
      for (chain\_id, chain) in chains { states.insert(\*chain\_id, chain.fetch\_state().await?); }
      Ok(Self { states, chains })
      }
      }
      guidance:
    * If any chain fails to load, return the error; don’t start partially initialized solvers.&#x20;
      example:
      lang: rust
      code: |
      // let mut solver = Solver::from(\&networks).await?;
      since: "0.1.0"
      Solver.fetch\_state:
      kind: function
      summary: Refreshes one chain’s state and returns newly solvable trades (skipping in-flight).&#x20;
      definition:
      lang: rust
      code: |
      pub async fn fetch\_state(\&mut self, chain\_id: u64, in\_flight: \&moka::sync::Cache\<RequestId, ()>) -> eyre::Result\<Vec<Trade>> {
      let chain = self.chains.get(\&chain\_id).expect("somehow got event for a non-existent chain");
      let updated\_state = chain.fetch\_state().await?;
      self.states.insert(chain\_id, updated\_state);
      Ok(calculate\_trades(chain\_id, \&self.states, in\_flight))
      }
      guidance:
    * Use a bounded TTL cache for `in_flight` to tolerate slow confirmations.&#x20;
      example:
      lang: rust
      code: |
      // let trades = solver.fetch\_state(chain\_id, \&inflight).await?;
      since: "0.1.0"
      calculate\_trades:
      kind: function
      summary: Pure function applying solver rules across current state to emit `Trade`s.&#x20;
      definition:
      lang: rust
      code: |
      fn calculate\_trades(chain\_id: u64, states: \&std::collections::HashMap\<u64, ChainState>, in\_flight: \&moka::sync::Cache\<RequestId, ()>) -> Vec<Trade> { /\* see source \*/ }
      guidance:
    * Skip any request already in `in_flight`.&#x20;
    * Operate on a cloned view to avoid balance reuse between transfers in a single tick.&#x20;
      example:
      lang: rust
      code: |
      // let trades = calculate\_trades(1, \&state\_map, \&inflight);
      since: "0.1.0"
      solve:
      kind: function
      summary: Per-transfer rule evaluation (fee, token match, balances, not executed/fulfilled).&#x20;
      definition:
      lang: rust
      code: |
      fn solve(transfer\_request: \&Transfer, trades: \&mut Vec<Trade>, states: \&mut std::collections::HashMap\<u64, ChainState>) { /\* see source \*/ }
      guidance:
    * Require `solverFee >= 1`, matching `tokenOut`, sufficient dest balances, and not `executed`.&#x20;
    * Decrement dest token balance immediately upon scheduling to avoid double-spend in same tick.&#x20;
      example:
      lang: rust
      code: |
      // internal helper; use via `calculate_trades`
      since: "0.1.0"

* id: network
  label: Chain Connectivity & State
  exports:

  * Network<P>
  * Network::create\_many
  * Network::new
  * Network::withdraw\_tokens
  * Network::stream\_block\_numbers
  * impl\_ChainStateProvider\_for\_Network<DynProvider>
    symbols:
    Network<P>:
    kind: struct
    summary: Generic network binding with provider, own address, and typed Router/ERC20 instances.&#x20;
    definition:
    lang: rust
    code: |
    pub(crate) struct Network<P> {
    pub chain\_id: u64,
    pub provider: P,
    pub own\_addr: Address,
    pub token: ERC20FaucetTokenInstance<P>,
    pub router: RouterInstance<P>,
    }
    guidance:

    * Keep instances per-chain keyed by `chain_id`; do not share instances across chains.&#x20;
      example:
      lang: rust
      code: |
      // Network is constructed via `new`/`create_many`
      since: "0.1.0"
      Network::create\_many:
      kind: function
      summary: Builds a map of `Network<DynProvider>` from a private key and a list of `NetworkConfig`.&#x20;
      definition:
      lang: rust
      code: |
      impl Network<DynProvider> {
      pub async fn create\_many(private\_key: \&str, network\_configs: &\[NetworkConfig]) -> eyre::Result\<std::collections::HashMap\<u64, Self>> { /\* see source \*/ }
      }
      guidance:
    * Performs faucet withdraw per chain on first boot; failures are logged then ignored.&#x20;
    * Ensure unique chain IDs; later maps/streams depend on uniqueness.&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::config::NetworkConfig;
      use onlyswaps\_solver::network::Network;
      let nets = Network::create\_many("0x<hexkey>", \&vec!\[NetworkConfig{
      chain\_id:1337, rpc\_url:"ws\://127.0.0.1:1337".into(), rusd\_address:"0x...".into(), router\_address:"0x...".into()
      }]).await?;
      since: "0.1.0"
      Network::new:
      kind: function
      summary: Connects a signer to a WS provider and constructs contract bindings.&#x20;
      definition:
      lang: rust
      code: |
      pub async fn new(signer: \&PrivateKeySigner, config: \&NetworkConfig) -> eyre::Result<Self> { /\* see source \*/ }
      guidance:
    * Use `ProviderBuilder::new().with_gas_estimation().wallet(...).connect_ws(...)`.&#x20;
    * Validate/parse addresses via `parse()?` to fail fast on misconfigurations.&#x20;
      example:
      lang: rust
      code: |
      // let net = Network::new(\&signer, \&cfg).await?;
      since: "0.1.0"
      Network::withdraw\_tokens:
      kind: function
      summary: Mints faucet tokens if balance below `min_balance`; otherwise no-op.&#x20;
      definition:
      lang: rust
      code: |
      impl\<P: Provider> Network<P> {
      pub async fn withdraw\_tokens(\&self) -> eyre::Result<()> { /\* see source \*/ }
      }
      guidance:
    * The check uses a large `min_balance` constant—tune for your test env.&#x20;
      example:
      lang: rust
      code: |
      // net.withdraw\_tokens().await?;
      since: "0.1.0"
      Network::stream\_block\_numbers:
      kind: function
      summary: Returns a boxed `Stream<BlockEvent>` of new block headers (chain\_id + number).&#x20;
      definition:
      lang: rust
      code: |
      pub async fn stream\_block\_numbers(\&self) -> eyre::Result\<std::pin::Pin\<Box\<dyn futures::Stream\<Item = BlockEvent> + Send>>> { /\* see source \*/ }
      guidance:
    * Requires WS providers; integrate with `select_all` to multiplex chains.&#x20;
      example:
      lang: rust
      code: |
      // let stream = network.stream\_block\_numbers().await?;
      since: "0.1.0"
      impl\_ChainStateProvider\_for\_Network<DynProvider>:
      kind: impl
      summary: Concrete `ChainStateProvider` impl that queries balances, fulfilled IDs, and unfulfilled swaps.&#x20;
      definition:
      lang: rust
      code: |
      \#\[async\_trait]
      impl ChainStateProvider for Network<DynProvider> {
      async fn fetch\_state(\&self) -> eyre::Result<ChainState> { /\* see source \*/ }
      }
      guidance:
    * Batches on-chain lookups and maps them into `Transfer` structs.&#x20;
      example:
      lang: rust
      code: |
      // let cs = net.fetch\_state().await?;
      since: "0.1.0"

* id: executor
  label: Trade Execution
  exports:

  * TradeExecutor<P>
  * TradeExecutor::new
  * TradeExecutor::execute
    symbols:
    TradeExecutor<P>:
    kind: struct
    summary: Holds per-chain Router/ERC20 references and executes trades by approve+relay.&#x20;
    definition:
    lang: rust
    code: |
    pub(crate) struct TradeExecutor<'a, P> {
    routers: std::collections::HashMap\<u64, &'a RouterInstance<P>>,
    tokens: std::collections::HashMap\<u64, &'a ERC20FaucetTokenInstance<P>>,
    }
    guidance:

    * Insert request into `in_flight` before sending transactions to avoid duplicates.&#x20;
    * Watch receipts for both `approve` and `relayTokens` to surface RPC errors.&#x20;
      example:
      lang: rust
      code: |
      // let exec = TradeExecutor::new(\&networks);
      // exec.execute(trades, \&mut inflight).await;
      since: "0.1.0"
      TradeExecutor::new:
      kind: function
      summary: Builds executor maps from chain\_id → {router, token} references.&#x20;
      definition:
      lang: rust
      code: |
      impl<'a, P: Provider> TradeExecutor<'a, P> {
      pub fn new(networks: &'a std::collections::HashMap\<u64, Network<P>>) -> Self { /\* see source \*/ }
      }
      guidance:
    * Ensure networks are stable (not dropped) for the lifetime of the executor.&#x20;
      example:
      lang: rust
      code: |
      // let exec = TradeExecutor::new(\&networks);
      since: "0.1.0"
      TradeExecutor::execute:
      kind: function
      summary: Approves token spend and calls `router.relayTokens(...)` for each trade.&#x20;
      definition:
      lang: rust
      code: |
      pub async fn execute(\&self, trades: Vec<Trade>, in\_flight: \&mut moka::sync::Cache\<RequestId, ()>) { /\* see source \*/ }
      guidance:
    * Nonce ordering may not guarantee inclusion immediately; expect to retry later.&#x20;
      example:
      lang: rust
      code: |
      // exec.execute(vec!\[trade], \&mut inflight).await;
      since: "0.1.0"

* id: api
  label: HTTP Health Server
  exports:

  * ApiServer
  * ApiServer::new
  * ApiServer::start
  * GET\_/health
    symbols:
    ApiServer:
    kind: struct
    summary: Minimal Axum server exposing a `/health` endpoint on the configured port.&#x20;
    definition:
    lang: rust
    code: |
    pub(crate) struct ApiServer { port: u16, app: axum::Router<()> }
    guidance:

    * Bind on `0.0.0.0` for containerized deployments.&#x20;
      example:
      lang: rust
      code: |
      // let api = ApiServer::new(8080); api.start().await?;
      since: "0.1.0"
      ApiServer::new:
      kind: function
      summary: Constructs a router with GET `/health`.&#x20;
      definition:
      lang: rust
      code: |
      impl ApiServer {
      pub fn new(port: u16) -> Self {
      let app = axum::Router::new().route("/health", axum::routing::get(healthcheck\_handler));
      Self { port, app }
      }
      }
      guidance:
    * Route set is intentionally minimal; extend here if you add metrics or readiness.
      example:
      lang: rust
      code: |
      let api = onlyswaps\_solver::api::ApiServer::new(8080);
      since: "0.1.0"
      ApiServer::start:
      kind: function
      summary: Binds TCP listener and serves Axum app until shutdown.&#x20;
      definition:
      lang: rust
      code: |
      pub async fn start(self) -> eyre::Result<()> {
      let listener = tokio::net::TcpListener::bind(("0.0.0.0", self.port)).await?;
      Ok(axum::serve(listener, self.app).await?)
      }
      guidance:
    * Use process signals (SIGINT/SIGTERM) from main to coordinate shutdown.&#x20;
      example:
      lang: rust
      code: |
      // ApiServer::new(8080).start().await?;
      since: "0.1.0"
      GET\_/health:
      kind: route
      summary: Health endpoint responding `"ok"`.&#x20;
      definition:
      lang: rust
      code: |
      async fn healthcheck\_handler() -> &'static str { "ok" }
      guidance:
    * Use for container liveness; no auth and constant body.&#x20;
      example:
      lang: bash
      code: |
      curl -s [http://127.0.0.1:8080/health](http://127.0.0.1:8080/health)
      since: "0.1.0"

* id: eth
  label: On‑chain Bindings (alloy::sol!)
  exports:

  * ERC20FaucetToken
  * Router
    symbols:
    ERC20FaucetToken:
    kind: binding
    summary: Typed ERC‑20 faucet token binding generated from the project ABI.&#x20;
    definition:
    lang: rust
    code: |
    sol!(
    \#\[allow(clippy::too\_many\_arguments)]
    \#\[derive(Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
    \#\[sol(rpc)]
    ERC20FaucetToken,
    "onlysubs-solidity/out/ERC20FaucetToken.sol/ERC20FaucetToken.json"
    );
    guidance:

    * Use `ERC20FaucetToken::new(addr, provider.clone())` to instantiate.&#x20;
      example:
      lang: rust
      code: |
      use alloy::providers::{ProviderBuilder, WsConnect};
      use onlyswaps\_solver::eth::ERC20FaucetToken;

      # async fn demo() -> eyre::Result<()> {

      let p = ProviderBuilder::new().connect\_ws(WsConnect::new("ws\://127.0.0.1:1337")).await?.erased();
      let tok = ERC20FaucetToken::new("0x0000000000000000000000000000000000000001".parse()?, p.clone());
      // tok.balanceOf(addr).call().await?;

      # Ok(()) }

    since: "0.1.0"
    Router:
    kind: binding
    summary: Typed Router binding for reading swap requests and relaying tokens.&#x20;
    definition:
    lang: rust
    code: |
    sol!(
    \#\[allow(clippy::too\_many\_arguments)]
    \#\[derive(Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
    \#\[sol(rpc)]
    Router,
    "onlysubs-solidity/out/Router.sol/Router.json",
    );
    guidance:

    * Access `getUnfulfilledSolverRefunds`, `getSwapRequestParameters`, and `relayTokens(...)`.&#x20;
      example:
      lang: rust
      code: |
      // let router = Router::new(addr, provider.clone());
      // let ids = router.getUnfulfilledSolverRefunds().call().await?;
      since: "0.1.0"

* id: util
  label: Utilities
  exports:

  * normalise\_chain\_id
    symbols:
    normalise\_chain\_id:
    kind: function
    summary: Convert a U256 chain id to u64 (low limb).&#x20;
    definition:
    lang: rust
    code: |
    pub fn normalise\_chain\_id(chain\_id: U256) -> u64 {
    chain\_id.as\_limbs()\[0]
    }
    guidance:

    * Use for map lookups keyed by `u64` chain ids; keep input as `U256` at ABI boundaries.&#x20;
      example:
      lang: rust
      code: |
      use onlyswaps\_solver::util::normalise\_chain\_id;
      use alloy::primitives::U256;
      assert\_eq!(normalise\_chain\_id(U256::from(1337)), 1337u64);
      since: "0.1.0"

* id: orchestration
  label: App & Main Orchestration
  exports:

  * App::start
  * main\_async
    symbols:
    App::start:
    kind: function
    summary: Multiplexes block streams across chains, solves, and executes trades; exits if stream ends.&#x20;
    definition:
    lang: rust
    code: |
    impl App {
    pub async fn start(networks: std::collections::HashMap\<u64, Network[alloy::providers::DynProvider](alloy::providers::DynProvider)>) -> eyre::Result<()> { /\* see source \*/ }
    }
    guidance:

    * Combine streams via `select_all` and drive one solve per incoming `BlockEvent`.&#x20;
    * Use `moka` TTL cache (\~30s) to avoid duplicate executions while pending.&#x20;
      example:
      lang: rust
      code: |
      // App::start(networks).await?;
      since: "0.1.0"
      main\_async:
      kind: function
      summary: Process entrypoint wiring CLI, config, networks, HTTP server, and signals.&#x20;
      definition:
      lang: rust
      code: |
      \#\[tokio::main]
      async fn main() -> eyre::Result<()> { /\* see source \*/ }
      guidance:
    * Use `tokio::select!` to race App, API server, and signal receivers; shut down cleanly on SIGINT/SIGTERM.&#x20;
      example:
      lang: bash
      code: |
      cargo run -- --config-path ./config-local.json --private-key 0x<hex>
      since: "0.1.0"

common\_workflows:

* name: local-two-anvil-e2e
  summary: Spin up two Anvil chains, deploy contracts, run solver, and request a swap end‑to‑end.&#x20;
  steps:

  * "Start two Anvil nodes with block time: `anvil --port 1337 --chain-id 1337 --block-time 3` and `anvil --port 1338 --chain-id 1338 --block-time 3`."  # filecite below
  * "Deploy onlysubs-solidity contracts to both chains using `forge script ...` (see README)."
  * "Run solver with local config and a dev private key."
  * "Trigger a swap using `request-swap.sh <src> <dst>` and observe logs."
    example:
    lang: bash
    code: |
    anvil --port 1337 --chain-id 1337 --block-time 3
    anvil --port 1338 --chain-id 1338 --block-time 3

    # ... deploy contracts per README ...

    cargo run -- --config-path ./config-local.json --private-key 0x59c6...
    ./request-swap.sh 1337 1338
    notes: "See README for exact Forge commands and env vars."&#x20;
* name: docker-build-run
  summary: Build the container image and run with a baked config.&#x20;
  steps:

  * "docker build ."
  * "docker run -p 8080:8080 -e SOLVER\_PRIVATE\_KEY=... onlyswaps-solver"
    notes: "Runtime image copies `config-default.json` and sets entrypoint accordingly."&#x20;
* name: healthcheck
  summary: Probe liveness over HTTP.&#x20;
  steps:

  * "Start the solver (or the API server in isolation)."
  * "curl [http://127.0.0.1:8080/health](http://127.0.0.1:8080/health)  # returns 'ok'"

troubleshooting\_cheatsheet:

* symptom: "stream of blocks ended unexpectedly"
  cause: "WS subscription terminated or provider dropped."
  fix: "Restart process or reconnect provider; ensure WS endpoint stability."&#x20;
* symptom: "error approving trade: <e>"
  cause: "Allowance/nonce/RPC issue during ERC20 approve."
  fix: "Retry after TTL; check signer funds and network gas estimation."&#x20;
* symptom: "No trades produced despite pending transfers"
  cause: "Preconditions failed (fee==0, token mismatch, insufficient dest balance, already fulfilled)."
  fix: "Inspect solver rules and chain state fields; correct config or balances."&#x20;

faq:

* q: "Why maintain an in‑flight cache if trades are idempotent?"
  a: "To avoid redundant relay attempts while previous txs are pending or reorged; entries expire after \~30s TTL."&#x20;
* q: "Can I add more chains dynamically?"
  a: "Not at runtime in this design; build the `networks` map up front via `Network::create_many` before constructing the solver."&#x20;
* q: "Where do Router parameters come from?"
  a: "From on‑chain queries via generated bindings (`getUnfulfilledSolverRefunds`, `getSwapRequestParameters`)."&#x20;

external\_resources:

* label: Alloy (providers & sol! bindings)
  url: [https://github.com/alloy-rs/alloy](https://github.com/alloy-rs/alloy)
* label: Axum (HTTP server)
  url: [https://docs.rs/axum/latest/axum/](https://docs.rs/axum/latest/axum/)
* label: Tokio (async runtime)
  url: [https://tokio.rs/](https://tokio.rs/)

